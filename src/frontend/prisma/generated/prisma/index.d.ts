/**
 * Client
 **/

import * as runtime from "./runtime/library.js";
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model Account
 *
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>;
/**
 * Model Session
 *
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>;
/**
 * Model VerificationToken
 *
 */
export type VerificationToken =
  $Result.DefaultSelection<Prisma.$VerificationTokenPayload>;
/**
 * Model Game
 *
 */
export type Game = $Result.DefaultSelection<Prisma.$GamePayload>;
/**
 * Model Genre
 *
 */
export type Genre = $Result.DefaultSelection<Prisma.$GenrePayload>;
/**
 * Model GameGenre
 *
 */
export type GameGenre = $Result.DefaultSelection<Prisma.$GameGenrePayload>;
/**
 * Model Screenshot
 *
 */
export type Screenshot = $Result.DefaultSelection<Prisma.$ScreenshotPayload>;
/**
 * Model Review
 *
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>;
/**
 * Model Cart
 *
 */
export type Cart = $Result.DefaultSelection<Prisma.$CartPayload>;
/**
 * Model CartItem
 *
 */
export type CartItem = $Result.DefaultSelection<Prisma.$CartItemPayload>;
/**
 * Model Order
 *
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>;
/**
 * Model OrderItem
 *
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>;
/**
 * Model FeaturedGame
 *
 */
export type FeaturedGame =
  $Result.DefaultSelection<Prisma.$FeaturedGamePayload>;
/**
 * Model RecommendedGame
 *
 */
export type RecommendedGame =
  $Result.DefaultSelection<Prisma.$RecommendedGamePayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const GameStatus: {
    NORMAL: "NORMAL";
    FEATURED: "FEATURED";
    RECOMMENDED: "RECOMMENDED";
    TRENDING: "TRENDING";
  };

  export type GameStatus = (typeof GameStatus)[keyof typeof GameStatus];

  export const RecommendationType: {
    SIMILAR: "SIMILAR";
    NEW_RELEASE: "NEW_RELEASE";
    POPULAR: "POPULAR";
    CUSTOM: "CUSTOM";
  };

  export type RecommendationType =
    (typeof RecommendationType)[keyof typeof RecommendationType];
}

export type GameStatus = $Enums.GameStatus;

export const GameStatus: typeof $Enums.GameStatus;

export type RecommendationType = $Enums.RecommendationType;

export const RecommendationType: typeof $Enums.RecommendationType;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = "log" extends keyof ClientOptions
    ? ClientOptions["log"] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions["log"]>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["other"] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(
    optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>
  );
  $on<V extends U>(
    eventType: V,
    callback: (
      event: V extends "query" ? Prisma.QueryEvent : Prisma.LogEvent
    ) => void
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (
      prisma: Omit<PrismaClient, runtime.ITXClientDenyList>
    ) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    }
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    "extends",
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Sessions
   * const sessions = await prisma.session.findMany()
   * ```
   */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more VerificationTokens
   * const verificationTokens = await prisma.verificationToken.findMany()
   * ```
   */
  get verificationToken(): Prisma.VerificationTokenDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.game`: Exposes CRUD operations for the **Game** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Games
   * const games = await prisma.game.findMany()
   * ```
   */
  get game(): Prisma.GameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.genre`: Exposes CRUD operations for the **Genre** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Genres
   * const genres = await prisma.genre.findMany()
   * ```
   */
  get genre(): Prisma.GenreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameGenre`: Exposes CRUD operations for the **GameGenre** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more GameGenres
   * const gameGenres = await prisma.gameGenre.findMany()
   * ```
   */
  get gameGenre(): Prisma.GameGenreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.screenshot`: Exposes CRUD operations for the **Screenshot** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Screenshots
   * const screenshots = await prisma.screenshot.findMany()
   * ```
   */
  get screenshot(): Prisma.ScreenshotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Reviews
   * const reviews = await prisma.review.findMany()
   * ```
   */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cart`: Exposes CRUD operations for the **Cart** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Carts
   * const carts = await prisma.cart.findMany()
   * ```
   */
  get cart(): Prisma.CartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cartItem`: Exposes CRUD operations for the **CartItem** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more CartItems
   * const cartItems = await prisma.cartItem.findMany()
   * ```
   */
  get cartItem(): Prisma.CartItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Orders
   * const orders = await prisma.order.findMany()
   * ```
   */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more OrderItems
   * const orderItems = await prisma.orderItem.findMany()
   * ```
   */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.featuredGame`: Exposes CRUD operations for the **FeaturedGame** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FeaturedGames
   * const featuredGames = await prisma.featuredGame.findMany()
   * ```
   */
  get featuredGame(): Prisma.FeaturedGameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recommendedGame`: Exposes CRUD operations for the **RecommendedGame** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more RecommendedGames
   * const recommendedGames = await prisma.recommendedGame.findMany()
   * ```
   */
  get recommendedGame(): Prisma.RecommendedGameDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> =
    T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<
    T extends (...args: any) => $Utils.JsPromise<any>,
  > = PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? "Please either choose `select` or `include`."
    : T extends SelectAndOmit
      ? "Please either choose `select` or `omit`."
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<
    __Either<O, K>
  >;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = O extends unknown ? _Either<O, K, strict> : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O
    ? O[K]
    : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never;
  export type At<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<
    T,
    U = Omit<T, "_avg" | "_sum" | "_count" | "_min" | "_max">,
  > = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<"OR", K>, Extends<"AND", K>>,
      Extends<"NOT", K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<
            UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
          >
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<
    T,
    K extends Enumerable<keyof T> | keyof T,
  > = Prisma__Pick<T, MaybeTupleToUnion<K>>;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    User: "User";
    Account: "Account";
    Session: "Session";
    VerificationToken: "VerificationToken";
    Game: "Game";
    Genre: "Genre";
    GameGenre: "GameGenre";
    Screenshot: "Screenshot";
    Review: "Review";
    Cart: "Cart";
    CartItem: "CartItem";
    Order: "Order";
    OrderItem: "OrderItem";
    FeaturedGame: "FeaturedGame";
    RecommendedGame: "RecommendedGame";
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<
      { extArgs: $Extensions.InternalArgs },
      $Utils.Record<string, any>
    > {
    returns: Prisma.TypeMap<
      this["params"]["extArgs"],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | "user"
        | "account"
        | "session"
        | "verificationToken"
        | "game"
        | "genre"
        | "gameGenre"
        | "screenshot"
        | "review"
        | "cart"
        | "cartItem"
        | "order"
        | "orderItem"
        | "featuredGame"
        | "recommendedGame";
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>;
        fields: Prisma.UserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser>;
          };
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCountArgs<ExtArgs>;
            result: $Utils.Optional<UserCountAggregateOutputType> | number;
          };
        };
      };
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>;
        fields: Prisma.AccountFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[];
          };
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[];
          };
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[];
          };
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAccount>;
          };
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AccountGroupByOutputType>[];
          };
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>;
            result: $Utils.Optional<AccountCountAggregateOutputType> | number;
          };
        };
      };
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>;
        fields: Prisma.SessionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSession>;
          };
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SessionGroupByOutputType>[];
          };
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>;
            result: $Utils.Optional<SessionCountAggregateOutputType> | number;
          };
        };
      };
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>;
        fields: Prisma.VerificationTokenFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[];
          };
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[];
          };
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[];
          };
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateVerificationToken>;
          };
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>;
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[];
          };
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<VerificationTokenCountAggregateOutputType>
              | number;
          };
        };
      };
      Game: {
        payload: Prisma.$GamePayload<ExtArgs>;
        fields: Prisma.GameFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.GameFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.GameFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GamePayload>;
          };
          findFirst: {
            args: Prisma.GameFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.GameFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GamePayload>;
          };
          findMany: {
            args: Prisma.GameFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[];
          };
          create: {
            args: Prisma.GameCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GamePayload>;
          };
          createMany: {
            args: Prisma.GameCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.GameCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[];
          };
          delete: {
            args: Prisma.GameDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GamePayload>;
          };
          update: {
            args: Prisma.GameUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GamePayload>;
          };
          deleteMany: {
            args: Prisma.GameDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.GameUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.GameUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[];
          };
          upsert: {
            args: Prisma.GameUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GamePayload>;
          };
          aggregate: {
            args: Prisma.GameAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateGame>;
          };
          groupBy: {
            args: Prisma.GameGroupByArgs<ExtArgs>;
            result: $Utils.Optional<GameGroupByOutputType>[];
          };
          count: {
            args: Prisma.GameCountArgs<ExtArgs>;
            result: $Utils.Optional<GameCountAggregateOutputType> | number;
          };
        };
      };
      Genre: {
        payload: Prisma.$GenrePayload<ExtArgs>;
        fields: Prisma.GenreFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.GenreFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GenrePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.GenreFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>;
          };
          findFirst: {
            args: Prisma.GenreFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GenrePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.GenreFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>;
          };
          findMany: {
            args: Prisma.GenreFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[];
          };
          create: {
            args: Prisma.GenreCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>;
          };
          createMany: {
            args: Prisma.GenreCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.GenreCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[];
          };
          delete: {
            args: Prisma.GenreDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>;
          };
          update: {
            args: Prisma.GenreUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>;
          };
          deleteMany: {
            args: Prisma.GenreDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.GenreUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.GenreUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[];
          };
          upsert: {
            args: Prisma.GenreUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>;
          };
          aggregate: {
            args: Prisma.GenreAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateGenre>;
          };
          groupBy: {
            args: Prisma.GenreGroupByArgs<ExtArgs>;
            result: $Utils.Optional<GenreGroupByOutputType>[];
          };
          count: {
            args: Prisma.GenreCountArgs<ExtArgs>;
            result: $Utils.Optional<GenreCountAggregateOutputType> | number;
          };
        };
      };
      GameGenre: {
        payload: Prisma.$GameGenrePayload<ExtArgs>;
        fields: Prisma.GameGenreFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.GameGenreFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GameGenrePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.GameGenreFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GameGenrePayload>;
          };
          findFirst: {
            args: Prisma.GameGenreFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GameGenrePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.GameGenreFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GameGenrePayload>;
          };
          findMany: {
            args: Prisma.GameGenreFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GameGenrePayload>[];
          };
          create: {
            args: Prisma.GameGenreCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GameGenrePayload>;
          };
          createMany: {
            args: Prisma.GameGenreCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.GameGenreCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GameGenrePayload>[];
          };
          delete: {
            args: Prisma.GameGenreDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GameGenrePayload>;
          };
          update: {
            args: Prisma.GameGenreUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GameGenrePayload>;
          };
          deleteMany: {
            args: Prisma.GameGenreDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.GameGenreUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.GameGenreUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GameGenrePayload>[];
          };
          upsert: {
            args: Prisma.GameGenreUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GameGenrePayload>;
          };
          aggregate: {
            args: Prisma.GameGenreAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateGameGenre>;
          };
          groupBy: {
            args: Prisma.GameGenreGroupByArgs<ExtArgs>;
            result: $Utils.Optional<GameGenreGroupByOutputType>[];
          };
          count: {
            args: Prisma.GameGenreCountArgs<ExtArgs>;
            result: $Utils.Optional<GameGenreCountAggregateOutputType> | number;
          };
        };
      };
      Screenshot: {
        payload: Prisma.$ScreenshotPayload<ExtArgs>;
        fields: Prisma.ScreenshotFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ScreenshotFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ScreenshotFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>;
          };
          findFirst: {
            args: Prisma.ScreenshotFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ScreenshotFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>;
          };
          findMany: {
            args: Prisma.ScreenshotFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>[];
          };
          create: {
            args: Prisma.ScreenshotCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>;
          };
          createMany: {
            args: Prisma.ScreenshotCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ScreenshotCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>[];
          };
          delete: {
            args: Prisma.ScreenshotDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>;
          };
          update: {
            args: Prisma.ScreenshotUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>;
          };
          deleteMany: {
            args: Prisma.ScreenshotDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ScreenshotUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ScreenshotUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>[];
          };
          upsert: {
            args: Prisma.ScreenshotUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>;
          };
          aggregate: {
            args: Prisma.ScreenshotAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateScreenshot>;
          };
          groupBy: {
            args: Prisma.ScreenshotGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ScreenshotGroupByOutputType>[];
          };
          count: {
            args: Prisma.ScreenshotCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ScreenshotCountAggregateOutputType>
              | number;
          };
        };
      };
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>;
        fields: Prisma.ReviewFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[];
          };
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[];
          };
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[];
          };
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateReview>;
          };
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ReviewGroupByOutputType>[];
          };
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>;
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number;
          };
        };
      };
      Cart: {
        payload: Prisma.$CartPayload<ExtArgs>;
        fields: Prisma.CartFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CartFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CartFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartPayload>;
          };
          findFirst: {
            args: Prisma.CartFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CartFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartPayload>;
          };
          findMany: {
            args: Prisma.CartFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[];
          };
          create: {
            args: Prisma.CartCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartPayload>;
          };
          createMany: {
            args: Prisma.CartCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.CartCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[];
          };
          delete: {
            args: Prisma.CartDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartPayload>;
          };
          update: {
            args: Prisma.CartUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartPayload>;
          };
          deleteMany: {
            args: Prisma.CartDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CartUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.CartUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[];
          };
          upsert: {
            args: Prisma.CartUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartPayload>;
          };
          aggregate: {
            args: Prisma.CartAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCart>;
          };
          groupBy: {
            args: Prisma.CartGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CartGroupByOutputType>[];
          };
          count: {
            args: Prisma.CartCountArgs<ExtArgs>;
            result: $Utils.Optional<CartCountAggregateOutputType> | number;
          };
        };
      };
      CartItem: {
        payload: Prisma.$CartItemPayload<ExtArgs>;
        fields: Prisma.CartItemFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CartItemFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CartItemFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>;
          };
          findFirst: {
            args: Prisma.CartItemFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CartItemFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>;
          };
          findMany: {
            args: Prisma.CartItemFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[];
          };
          create: {
            args: Prisma.CartItemCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>;
          };
          createMany: {
            args: Prisma.CartItemCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.CartItemCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[];
          };
          delete: {
            args: Prisma.CartItemDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>;
          };
          update: {
            args: Prisma.CartItemUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>;
          };
          deleteMany: {
            args: Prisma.CartItemDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CartItemUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.CartItemUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[];
          };
          upsert: {
            args: Prisma.CartItemUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>;
          };
          aggregate: {
            args: Prisma.CartItemAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCartItem>;
          };
          groupBy: {
            args: Prisma.CartItemGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CartItemGroupByOutputType>[];
          };
          count: {
            args: Prisma.CartItemCountArgs<ExtArgs>;
            result: $Utils.Optional<CartItemCountAggregateOutputType> | number;
          };
        };
      };
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>;
        fields: Prisma.OrderFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[];
          };
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[];
          };
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[];
          };
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateOrder>;
          };
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>;
            result: $Utils.Optional<OrderGroupByOutputType>[];
          };
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>;
            result: $Utils.Optional<OrderCountAggregateOutputType> | number;
          };
        };
      };
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>;
        fields: Prisma.OrderItemFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>;
          };
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>;
          };
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[];
          };
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>;
          };
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[];
          };
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>;
          };
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>;
          };
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[];
          };
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>;
          };
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateOrderItem>;
          };
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>;
            result: $Utils.Optional<OrderItemGroupByOutputType>[];
          };
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>;
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number;
          };
        };
      };
      FeaturedGame: {
        payload: Prisma.$FeaturedGamePayload<ExtArgs>;
        fields: Prisma.FeaturedGameFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FeaturedGameFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeaturedGamePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FeaturedGameFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeaturedGamePayload>;
          };
          findFirst: {
            args: Prisma.FeaturedGameFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeaturedGamePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FeaturedGameFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeaturedGamePayload>;
          };
          findMany: {
            args: Prisma.FeaturedGameFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeaturedGamePayload>[];
          };
          create: {
            args: Prisma.FeaturedGameCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeaturedGamePayload>;
          };
          createMany: {
            args: Prisma.FeaturedGameCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.FeaturedGameCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeaturedGamePayload>[];
          };
          delete: {
            args: Prisma.FeaturedGameDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeaturedGamePayload>;
          };
          update: {
            args: Prisma.FeaturedGameUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeaturedGamePayload>;
          };
          deleteMany: {
            args: Prisma.FeaturedGameDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FeaturedGameUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.FeaturedGameUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeaturedGamePayload>[];
          };
          upsert: {
            args: Prisma.FeaturedGameUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FeaturedGamePayload>;
          };
          aggregate: {
            args: Prisma.FeaturedGameAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFeaturedGame>;
          };
          groupBy: {
            args: Prisma.FeaturedGameGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FeaturedGameGroupByOutputType>[];
          };
          count: {
            args: Prisma.FeaturedGameCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<FeaturedGameCountAggregateOutputType>
              | number;
          };
        };
      };
      RecommendedGame: {
        payload: Prisma.$RecommendedGamePayload<ExtArgs>;
        fields: Prisma.RecommendedGameFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.RecommendedGameFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RecommendedGamePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.RecommendedGameFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RecommendedGamePayload>;
          };
          findFirst: {
            args: Prisma.RecommendedGameFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RecommendedGamePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.RecommendedGameFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RecommendedGamePayload>;
          };
          findMany: {
            args: Prisma.RecommendedGameFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RecommendedGamePayload>[];
          };
          create: {
            args: Prisma.RecommendedGameCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RecommendedGamePayload>;
          };
          createMany: {
            args: Prisma.RecommendedGameCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.RecommendedGameCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RecommendedGamePayload>[];
          };
          delete: {
            args: Prisma.RecommendedGameDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RecommendedGamePayload>;
          };
          update: {
            args: Prisma.RecommendedGameUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RecommendedGamePayload>;
          };
          deleteMany: {
            args: Prisma.RecommendedGameDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.RecommendedGameUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.RecommendedGameUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RecommendedGamePayload>[];
          };
          upsert: {
            args: Prisma.RecommendedGameUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RecommendedGamePayload>;
          };
          aggregate: {
            args: Prisma.RecommendedGameAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRecommendedGame>;
          };
          groupBy: {
            args: Prisma.RecommendedGameGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RecommendedGameGroupByOutputType>[];
          };
          count: {
            args: Prisma.RecommendedGameCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<RecommendedGameCountAggregateOutputType>
              | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    "define",
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = "pretty" | "colorless" | "minimal";
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
  }
  export type GlobalOmitConfig = {
    user?: UserOmit;
    account?: AccountOmit;
    session?: SessionOmit;
    verificationToken?: VerificationTokenOmit;
    game?: GameOmit;
    genre?: GenreOmit;
    gameGenre?: GameGenreOmit;
    screenshot?: ScreenshotOmit;
    review?: ReviewOmit;
    cart?: CartOmit;
    cartItem?: CartItemOmit;
    order?: OrderOmit;
    orderItem?: OrderItemOmit;
    featuredGame?: FeaturedGameOmit;
    recommendedGame?: RecommendedGameOmit;
  };

  /* Types for Logging */
  export type LogLevel = "info" | "query" | "warn" | "error";
  export type LogDefinition = {
    level: LogLevel;
    emit: "stdout" | "event";
  };

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T["level"] : T
  >;

  export type GetEvents<T extends any[]> =
    T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | "findUnique"
    | "findUniqueOrThrow"
    | "findMany"
    | "findFirst"
    | "findFirstOrThrow"
    | "create"
    | "createMany"
    | "createManyAndReturn"
    | "update"
    | "updateMany"
    | "updateManyAndReturn"
    | "upsert"
    | "delete"
    | "deleteMany"
    | "executeRaw"
    | "queryRaw"
    | "aggregate"
    | "count"
    | "runCommandRaw"
    | "findRaw"
    | "groupBy";

  // tested in getLogLevel.test.ts
  export function getLogLevel(
    log: Array<LogLevel | LogDefinition>
  ): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<
    Prisma.DefaultPrismaClient,
    runtime.ITXClientDenyList
  >;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number;
    sessions: number;
    orders: number;
    reviews: number;
  };

  export type UserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs;
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs;
    orders?: boolean | UserCountOutputTypeCountOrdersArgs;
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs;
  };

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AccountWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SessionWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrderWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ReviewWhereInput;
  };

  /**
   * Count Type GameCountOutputType
   */

  export type GameCountOutputType = {
    cartItems: number;
    genres: number;
    orderItems: number;
    reviews: number;
    screenshots: number;
    featuredGames: number;
    recommendedMain: number;
    recommendedRel: number;
  };

  export type GameCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    cartItems?: boolean | GameCountOutputTypeCountCartItemsArgs;
    genres?: boolean | GameCountOutputTypeCountGenresArgs;
    orderItems?: boolean | GameCountOutputTypeCountOrderItemsArgs;
    reviews?: boolean | GameCountOutputTypeCountReviewsArgs;
    screenshots?: boolean | GameCountOutputTypeCountScreenshotsArgs;
    featuredGames?: boolean | GameCountOutputTypeCountFeaturedGamesArgs;
    recommendedMain?: boolean | GameCountOutputTypeCountRecommendedMainArgs;
    recommendedRel?: boolean | GameCountOutputTypeCountRecommendedRelArgs;
  };

  // Custom InputTypes
  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GameCountOutputType
     */
    select?: GameCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountCartItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CartItemWhereInput;
  };

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountGenresArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: GameGenreWhereInput;
  };

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountOrderItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrderItemWhereInput;
  };

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountReviewsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ReviewWhereInput;
  };

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountScreenshotsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ScreenshotWhereInput;
  };

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountFeaturedGamesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FeaturedGameWhereInput;
  };

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountRecommendedMainArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RecommendedGameWhereInput;
  };

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountRecommendedRelArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RecommendedGameWhereInput;
  };

  /**
   * Count Type GenreCountOutputType
   */

  export type GenreCountOutputType = {
    games: number;
    subGenres: number;
  };

  export type GenreCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    games?: boolean | GenreCountOutputTypeCountGamesArgs;
    subGenres?: boolean | GenreCountOutputTypeCountSubGenresArgs;
  };

  // Custom InputTypes
  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GenreCountOutputType
     */
    select?: GenreCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeCountGamesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: GameGenreWhereInput;
  };

  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeCountSubGenresArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: GenreWhereInput;
  };

  /**
   * Count Type CartCountOutputType
   */

  export type CartCountOutputType = {
    items: number;
  };

  export type CartCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    items?: boolean | CartCountOutputTypeCountItemsArgs;
  };

  // Custom InputTypes
  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CartCountOutputType
     */
    select?: CartCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeCountItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CartItemWhereInput;
  };

  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number;
  };

  export type OrderCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs;
  };

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrderItemWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    email: string | null;
    emailVerified: Date | null;
    image: string | null;
    password: string | null;
    address: string | null;
    phone: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type UserMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    email: string | null;
    emailVerified: Date | null;
    image: string | null;
    password: string | null;
    address: string | null;
    phone: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type UserCountAggregateOutputType = {
    id: number;
    name: number;
    email: number;
    emailVerified: number;
    image: number;
    password: number;
    address: number;
    phone: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type UserMinAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    emailVerified?: true;
    image?: true;
    password?: true;
    address?: true;
    phone?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type UserMaxAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    emailVerified?: true;
    image?: true;
    password?: true;
    address?: true;
    phone?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type UserCountAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    emailVerified?: true;
    image?: true;
    password?: true;
    address?: true;
    phone?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type UserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserWhereInput;
    orderBy?:
      | UserOrderByWithAggregationInput
      | UserOrderByWithAggregationInput[];
    by: UserScalarFieldEnum[] | UserScalarFieldEnum;
    having?: UserScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserCountAggregateInputType | true;
    _min?: UserMinAggregateInputType;
    _max?: UserMaxAggregateInputType;
  };

  export type UserGroupByOutputType = {
    id: string;
    name: string | null;
    email: string | null;
    emailVerified: Date | null;
    image: string | null;
    password: string | null;
    address: string | null;
    phone: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      email?: boolean;
      emailVerified?: boolean;
      image?: boolean;
      password?: boolean;
      address?: boolean;
      phone?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      accounts?: boolean | User$accountsArgs<ExtArgs>;
      sessions?: boolean | User$sessionsArgs<ExtArgs>;
      cart?: boolean | User$cartArgs<ExtArgs>;
      orders?: boolean | User$ordersArgs<ExtArgs>;
      reviews?: boolean | User$reviewsArgs<ExtArgs>;
      _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      email?: boolean;
      emailVerified?: boolean;
      image?: boolean;
      password?: boolean;
      address?: boolean;
      phone?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      email?: boolean;
      emailVerified?: boolean;
      image?: boolean;
      password?: boolean;
      address?: boolean;
      phone?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectScalar = {
    id?: boolean;
    name?: boolean;
    email?: boolean;
    emailVerified?: boolean;
    image?: boolean;
    password?: boolean;
    address?: boolean;
    phone?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type UserOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "name"
    | "email"
    | "emailVerified"
    | "image"
    | "password"
    | "address"
    | "phone"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["user"]
  >;
  export type UserInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    accounts?: boolean | User$accountsArgs<ExtArgs>;
    sessions?: boolean | User$sessionsArgs<ExtArgs>;
    cart?: boolean | User$cartArgs<ExtArgs>;
    orders?: boolean | User$ordersArgs<ExtArgs>;
    reviews?: boolean | User$reviewsArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type UserIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type UserIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $UserPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "User";
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[];
      sessions: Prisma.$SessionPayload<ExtArgs>[];
      cart: Prisma.$CartPayload<ExtArgs> | null;
      orders: Prisma.$OrderPayload<ExtArgs>[];
      reviews: Prisma.$ReviewPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string | null;
        email: string | null;
        emailVerified: Date | null;
        image: string | null;
        password: string | null;
        address: string | null;
        phone: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["user"]
    >;
    composites: {};
  };

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> =
    $Result.GetResult<Prisma.$UserPayload, S>;

  type UserCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<UserFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: UserCountAggregateInputType | true;
  };

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["User"];
      meta: { name: "User" };
    };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs["orderBy"] }
        : { orderBy?: UserGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetUserGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$accountsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AccountPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$sessionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$SessionPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    cart<T extends User$cartArgs<ExtArgs> = {}>(
      args?: Subset<T, User$cartArgs<ExtArgs>>
    ): Prisma__CartClient<
      $Result.GetResult<
        Prisma.$CartPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    orders<T extends User$ordersArgs<ExtArgs> = {}>(
      args?: Subset<T, User$ordersArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$OrderPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$reviewsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ReviewPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", "String">;
    readonly name: FieldRef<"User", "String">;
    readonly email: FieldRef<"User", "String">;
    readonly emailVerified: FieldRef<"User", "DateTime">;
    readonly image: FieldRef<"User", "String">;
    readonly password: FieldRef<"User", "String">;
    readonly address: FieldRef<"User", "String">;
    readonly phone: FieldRef<"User", "String">;
    readonly createdAt: FieldRef<"User", "DateTime">;
    readonly updatedAt: FieldRef<"User", "DateTime">;
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User create
   */
  export type UserCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User update
   */
  export type UserUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to delete.
     */
    limit?: number;
  };

  /**
   * User.accounts
   */
  export type User$accountsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    where?: AccountWhereInput;
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    cursor?: AccountWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * User.sessions
   */
  export type User$sessionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    where?: SessionWhereInput;
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    cursor?: SessionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * User.cart
   */
  export type User$cartArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null;
    where?: CartWhereInput;
  };

  /**
   * User.orders
   */
  export type User$ordersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    where?: OrderWhereInput;
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    cursor?: OrderWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[];
  };

  /**
   * User.reviews
   */
  export type User$reviewsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    cursor?: ReviewWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
  };

  /**
   * User without action
   */
  export type UserDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
  };

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null;
    _avg: AccountAvgAggregateOutputType | null;
    _sum: AccountSumAggregateOutputType | null;
    _min: AccountMinAggregateOutputType | null;
    _max: AccountMaxAggregateOutputType | null;
  };

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null;
  };

  export type AccountSumAggregateOutputType = {
    expires_at: number | null;
  };

  export type AccountMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    type: string | null;
    provider: string | null;
    providerAccountId: string | null;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
  };

  export type AccountMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    type: string | null;
    provider: string | null;
    providerAccountId: string | null;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
  };

  export type AccountCountAggregateOutputType = {
    id: number;
    userId: number;
    type: number;
    provider: number;
    providerAccountId: number;
    refresh_token: number;
    access_token: number;
    expires_at: number;
    token_type: number;
    scope: number;
    id_token: number;
    session_state: number;
    _all: number;
  };

  export type AccountAvgAggregateInputType = {
    expires_at?: true;
  };

  export type AccountSumAggregateInputType = {
    expires_at?: true;
  };

  export type AccountMinAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    provider?: true;
    providerAccountId?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
  };

  export type AccountMaxAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    provider?: true;
    providerAccountId?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
  };

  export type AccountCountAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    provider?: true;
    providerAccountId?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
    _all?: true;
  };

  export type AccountAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Accounts
     **/
    _count?: true | AccountCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AccountAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AccountSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AccountMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AccountMaxAggregateInputType;
  };

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
    [P in keyof T & keyof AggregateAccount]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>;
  };

  export type AccountGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AccountWhereInput;
    orderBy?:
      | AccountOrderByWithAggregationInput
      | AccountOrderByWithAggregationInput[];
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum;
    having?: AccountScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AccountCountAggregateInputType | true;
    _avg?: AccountAvgAggregateInputType;
    _sum?: AccountSumAggregateInputType;
    _min?: AccountMinAggregateInputType;
    _max?: AccountMaxAggregateInputType;
  };

  export type AccountGroupByOutputType = {
    id: string;
    userId: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
    _count: AccountCountAggregateOutputType | null;
    _avg: AccountAvgAggregateOutputType | null;
    _sum: AccountSumAggregateOutputType | null;
    _min: AccountMinAggregateOutputType | null;
    _max: AccountMaxAggregateOutputType | null;
  };

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AccountGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof AccountGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>;
        }
      >
    >;

  export type AccountSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      type?: boolean;
      provider?: boolean;
      providerAccountId?: boolean;
      refresh_token?: boolean;
      access_token?: boolean;
      expires_at?: boolean;
      token_type?: boolean;
      scope?: boolean;
      id_token?: boolean;
      session_state?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["account"]
  >;

  export type AccountSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      type?: boolean;
      provider?: boolean;
      providerAccountId?: boolean;
      refresh_token?: boolean;
      access_token?: boolean;
      expires_at?: boolean;
      token_type?: boolean;
      scope?: boolean;
      id_token?: boolean;
      session_state?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["account"]
  >;

  export type AccountSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      type?: boolean;
      provider?: boolean;
      providerAccountId?: boolean;
      refresh_token?: boolean;
      access_token?: boolean;
      expires_at?: boolean;
      token_type?: boolean;
      scope?: boolean;
      id_token?: boolean;
      session_state?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["account"]
  >;

  export type AccountSelectScalar = {
    id?: boolean;
    userId?: boolean;
    type?: boolean;
    provider?: boolean;
    providerAccountId?: boolean;
    refresh_token?: boolean;
    access_token?: boolean;
    expires_at?: boolean;
    token_type?: boolean;
    scope?: boolean;
    id_token?: boolean;
    session_state?: boolean;
  };

  export type AccountOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "userId"
    | "type"
    | "provider"
    | "providerAccountId"
    | "refresh_token"
    | "access_token"
    | "expires_at"
    | "token_type"
    | "scope"
    | "id_token"
    | "session_state",
    ExtArgs["result"]["account"]
  >;
  export type AccountInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type AccountIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type AccountIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $AccountPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Account";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        type: string;
        provider: string;
        providerAccountId: string;
        refresh_token: string | null;
        access_token: string | null;
        expires_at: number | null;
        token_type: string | null;
        scope: string | null;
        id_token: string | null;
        session_state: string | null;
      },
      ExtArgs["result"]["account"]
    >;
    composites: {};
  };

  type AccountGetPayload<
    S extends boolean | null | undefined | AccountDefaultArgs,
  > = $Result.GetResult<Prisma.$AccountPayload, S>;

  type AccountCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<AccountFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: AccountCountAggregateInputType | true;
  };

  export interface AccountDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Account"];
      meta: { name: "Account" };
    };
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     *
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AccountFindManyArgs>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     *
     */
    create<T extends AccountCreateArgs>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AccountCreateManyArgs>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     *
     */
    delete<T extends AccountDeleteArgs>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AccountUpdateArgs>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AccountDeleteManyArgs>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AccountUpdateManyArgs>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<
        Prisma.$AccountPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
     **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], AccountCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AccountAggregateArgs>(
      args: Subset<T, AccountAggregateArgs>
    ): Prisma.PrismaPromise<GetAccountAggregateType<T>>;

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs["orderBy"] }
        : { orderBy?: AccountGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAccountGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Account model
     */
    readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", "String">;
    readonly userId: FieldRef<"Account", "String">;
    readonly type: FieldRef<"Account", "String">;
    readonly provider: FieldRef<"Account", "String">;
    readonly providerAccountId: FieldRef<"Account", "String">;
    readonly refresh_token: FieldRef<"Account", "String">;
    readonly access_token: FieldRef<"Account", "String">;
    readonly expires_at: FieldRef<"Account", "Int">;
    readonly token_type: FieldRef<"Account", "String">;
    readonly scope: FieldRef<"Account", "String">;
    readonly id_token: FieldRef<"Account", "String">;
    readonly session_state: FieldRef<"Account", "String">;
  }

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?:
      | AccountOrderByWithRelationInput
      | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account create
   */
  export type AccountCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>;
  };

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Account update
   */
  export type AccountUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>;
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>;
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput;
    /**
     * Limit how many Accounts to update.
     */
    limit?: number;
  };

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>;
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput;
    /**
     * Limit how many Accounts to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput;
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>;
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>;
  };

  /**
   * Account delete
   */
  export type AccountDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput;
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number;
  };

  /**
   * Account without action
   */
  export type AccountDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
  };

  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
  };

  export type SessionMinAggregateOutputType = {
    id: string | null;
    sessionToken: string | null;
    userId: string | null;
    expires: Date | null;
  };

  export type SessionMaxAggregateOutputType = {
    id: string | null;
    sessionToken: string | null;
    userId: string | null;
    expires: Date | null;
  };

  export type SessionCountAggregateOutputType = {
    id: number;
    sessionToken: number;
    userId: number;
    expires: number;
    _all: number;
  };

  export type SessionMinAggregateInputType = {
    id?: true;
    sessionToken?: true;
    userId?: true;
    expires?: true;
  };

  export type SessionMaxAggregateInputType = {
    id?: true;
    sessionToken?: true;
    userId?: true;
    expires?: true;
  };

  export type SessionCountAggregateInputType = {
    id?: true;
    sessionToken?: true;
    userId?: true;
    expires?: true;
    _all?: true;
  };

  export type SessionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Sessions
     **/
    _count?: true | SessionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SessionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SessionMaxAggregateInputType;
  };

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
    [P in keyof T & keyof AggregateSession]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>;
  };

  export type SessionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SessionWhereInput;
    orderBy?:
      | SessionOrderByWithAggregationInput
      | SessionOrderByWithAggregationInput[];
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum;
    having?: SessionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SessionCountAggregateInputType | true;
    _min?: SessionMinAggregateInputType;
    _max?: SessionMaxAggregateInputType;
  };

  export type SessionGroupByOutputType = {
    id: string;
    sessionToken: string;
    userId: string;
    expires: Date;
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
  };

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SessionGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof SessionGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>;
        }
      >
    >;

  export type SessionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      sessionToken?: boolean;
      userId?: boolean;
      expires?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["session"]
  >;

  export type SessionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      sessionToken?: boolean;
      userId?: boolean;
      expires?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["session"]
  >;

  export type SessionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      sessionToken?: boolean;
      userId?: boolean;
      expires?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["session"]
  >;

  export type SessionSelectScalar = {
    id?: boolean;
    sessionToken?: boolean;
    userId?: boolean;
    expires?: boolean;
  };

  export type SessionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "sessionToken" | "userId" | "expires",
    ExtArgs["result"]["session"]
  >;
  export type SessionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type SessionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type SessionIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $SessionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Session";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        sessionToken: string;
        userId: string;
        expires: Date;
      },
      ExtArgs["result"]["session"]
    >;
    composites: {};
  };

  type SessionGetPayload<
    S extends boolean | null | undefined | SessionDefaultArgs,
  > = $Result.GetResult<Prisma.$SessionPayload, S>;

  type SessionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<SessionFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: SessionCountAggregateInputType | true;
  };

  export interface SessionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Session"];
      meta: { name: "Session" };
    };
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(
      args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(
      args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     *
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SessionFindManyArgs>(
      args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     *
     */
    create<T extends SessionCreateArgs>(
      args: SelectSubset<T, SessionCreateArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SessionCreateManyArgs>(
      args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     *
     */
    delete<T extends SessionDeleteArgs>(
      args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SessionUpdateArgs>(
      args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SessionDeleteManyArgs>(
      args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SessionUpdateManyArgs>(
      args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(
      args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<
        Prisma.$SessionPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
     **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], SessionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SessionAggregateArgs>(
      args: Subset<T, SessionAggregateArgs>
    ): Prisma.PrismaPromise<GetSessionAggregateType<T>>;

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs["orderBy"] }
        : { orderBy?: SessionGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetSessionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Session model
     */
    readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", "String">;
    readonly sessionToken: FieldRef<"Session", "String">;
    readonly userId: FieldRef<"Session", "String">;
    readonly expires: FieldRef<"Session", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?:
      | SessionOrderByWithRelationInput
      | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session create
   */
  export type SessionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>;
  };

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Session update
   */
  export type SessionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>;
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>;
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput;
    /**
     * Limit how many Sessions to update.
     */
    limit?: number;
  };

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>;
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput;
    /**
     * Limit how many Sessions to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput;
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>;
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>;
  };

  /**
   * Session delete
   */
  export type SessionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput;
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number;
  };

  /**
   * Session without action
   */
  export type SessionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
  };

  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null;
    _min: VerificationTokenMinAggregateOutputType | null;
    _max: VerificationTokenMaxAggregateOutputType | null;
  };

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null;
    token: string | null;
    expires: Date | null;
  };

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null;
    token: string | null;
    expires: Date | null;
  };

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number;
    token: number;
    expires: number;
    _all: number;
  };

  export type VerificationTokenMinAggregateInputType = {
    identifier?: true;
    token?: true;
    expires?: true;
  };

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true;
    token?: true;
    expires?: true;
  };

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true;
    token?: true;
    expires?: true;
    _all?: true;
  };

  export type VerificationTokenAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned VerificationTokens
     **/
    _count?: true | VerificationTokenCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: VerificationTokenMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: VerificationTokenMaxAggregateInputType;
  };

  export type GetVerificationTokenAggregateType<
    T extends VerificationTokenAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateVerificationToken]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>;
  };

  export type VerificationTokenGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: VerificationTokenWhereInput;
    orderBy?:
      | VerificationTokenOrderByWithAggregationInput
      | VerificationTokenOrderByWithAggregationInput[];
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum;
    having?: VerificationTokenScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: VerificationTokenCountAggregateInputType | true;
    _min?: VerificationTokenMinAggregateInputType;
    _max?: VerificationTokenMaxAggregateInputType;
  };

  export type VerificationTokenGroupByOutputType = {
    identifier: string;
    token: string;
    expires: Date;
    _count: VerificationTokenCountAggregateOutputType | null;
    _min: VerificationTokenMinAggregateOutputType | null;
    _max: VerificationTokenMaxAggregateOutputType | null;
  };

  type GetVerificationTokenGroupByPayload<
    T extends VerificationTokenGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof VerificationTokenGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
          : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>;
      }
    >
  >;

  export type VerificationTokenSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      identifier?: boolean;
      token?: boolean;
      expires?: boolean;
    },
    ExtArgs["result"]["verificationToken"]
  >;

  export type VerificationTokenSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      identifier?: boolean;
      token?: boolean;
      expires?: boolean;
    },
    ExtArgs["result"]["verificationToken"]
  >;

  export type VerificationTokenSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      identifier?: boolean;
      token?: boolean;
      expires?: boolean;
    },
    ExtArgs["result"]["verificationToken"]
  >;

  export type VerificationTokenSelectScalar = {
    identifier?: boolean;
    token?: boolean;
    expires?: boolean;
  };

  export type VerificationTokenOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "identifier" | "token" | "expires",
    ExtArgs["result"]["verificationToken"]
  >;

  export type $VerificationTokenPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "VerificationToken";
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        identifier: string;
        token: string;
        expires: Date;
      },
      ExtArgs["result"]["verificationToken"]
    >;
    composites: {};
  };

  type VerificationTokenGetPayload<
    S extends boolean | null | undefined | VerificationTokenDefaultArgs,
  > = $Result.GetResult<Prisma.$VerificationTokenPayload, S>;

  type VerificationTokenCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    VerificationTokenFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: VerificationTokenCountAggregateInputType | true;
  };

  export interface VerificationTokenDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["VerificationToken"];
      meta: { name: "VerificationToken" };
    };
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(
      args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(
      args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(
      args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     *
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     *
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     *
     */
    findMany<T extends VerificationTokenFindManyArgs>(
      args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     *
     */
    create<T extends VerificationTokenCreateArgs>(
      args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends VerificationTokenCreateManyArgs>(
      args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(
      args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     *
     */
    delete<T extends VerificationTokenDeleteArgs>(
      args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends VerificationTokenUpdateArgs>(
      args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(
      args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(
      args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(
      args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(
      args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<
        Prisma.$VerificationTokenPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
     **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<
              T["select"],
              VerificationTokenCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends VerificationTokenAggregateArgs>(
      args: Subset<T, VerificationTokenAggregateArgs>
    ): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>;

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs["orderBy"] }
        : { orderBy?: VerificationTokenGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetVerificationTokenGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the VerificationToken model
     */
    readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", "String">;
    readonly token: FieldRef<"VerificationToken", "String">;
    readonly expires: FieldRef<"VerificationToken", "DateTime">;
  }

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?:
      | VerificationTokenScalarFieldEnum
      | VerificationTokenScalarFieldEnum[];
  };

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?:
      | VerificationTokenScalarFieldEnum
      | VerificationTokenScalarFieldEnum[];
  };

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    distinct?:
      | VerificationTokenScalarFieldEnum
      | VerificationTokenScalarFieldEnum[];
  };

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<
      VerificationTokenCreateInput,
      VerificationTokenUncheckedCreateInput
    >;
  };

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<
      VerificationTokenUpdateInput,
      VerificationTokenUncheckedUpdateInput
    >;
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<
      VerificationTokenUpdateManyMutationInput,
      VerificationTokenUncheckedUpdateManyInput
    >;
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput;
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number;
  };

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<
      VerificationTokenUpdateManyMutationInput,
      VerificationTokenUncheckedUpdateManyInput
    >;
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput;
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number;
  };

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput;
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<
      VerificationTokenCreateInput,
      VerificationTokenUncheckedCreateInput
    >;
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      VerificationTokenUpdateInput,
      VerificationTokenUncheckedUpdateInput
    >;
  };

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput;
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number;
  };

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null;
  };

  /**
   * Model Game
   */

  export type AggregateGame = {
    _count: GameCountAggregateOutputType | null;
    _avg: GameAvgAggregateOutputType | null;
    _sum: GameSumAggregateOutputType | null;
    _min: GameMinAggregateOutputType | null;
    _max: GameMaxAggregateOutputType | null;
  };

  export type GameAvgAggregateOutputType = {
    price: number | null;
    rating: number | null;
    discountedPrice: number | null;
  };

  export type GameSumAggregateOutputType = {
    price: number | null;
    rating: number | null;
    discountedPrice: number | null;
  };

  export type GameMinAggregateOutputType = {
    id: string | null;
    title: string | null;
    description: string | null;
    price: number | null;
    releaseDate: Date | null;
    developer: string | null;
    publisher: string | null;
    coverImageUrl: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    rating: number | null;
    discountedPrice: number | null;
    status: $Enums.GameStatus | null;
  };

  export type GameMaxAggregateOutputType = {
    id: string | null;
    title: string | null;
    description: string | null;
    price: number | null;
    releaseDate: Date | null;
    developer: string | null;
    publisher: string | null;
    coverImageUrl: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    rating: number | null;
    discountedPrice: number | null;
    status: $Enums.GameStatus | null;
  };

  export type GameCountAggregateOutputType = {
    id: number;
    title: number;
    description: number;
    price: number;
    releaseDate: number;
    developer: number;
    publisher: number;
    coverImageUrl: number;
    createdAt: number;
    updatedAt: number;
    rating: number;
    discountedPrice: number;
    status: number;
    _all: number;
  };

  export type GameAvgAggregateInputType = {
    price?: true;
    rating?: true;
    discountedPrice?: true;
  };

  export type GameSumAggregateInputType = {
    price?: true;
    rating?: true;
    discountedPrice?: true;
  };

  export type GameMinAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    price?: true;
    releaseDate?: true;
    developer?: true;
    publisher?: true;
    coverImageUrl?: true;
    createdAt?: true;
    updatedAt?: true;
    rating?: true;
    discountedPrice?: true;
    status?: true;
  };

  export type GameMaxAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    price?: true;
    releaseDate?: true;
    developer?: true;
    publisher?: true;
    coverImageUrl?: true;
    createdAt?: true;
    updatedAt?: true;
    rating?: true;
    discountedPrice?: true;
    status?: true;
  };

  export type GameCountAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    price?: true;
    releaseDate?: true;
    developer?: true;
    publisher?: true;
    coverImageUrl?: true;
    createdAt?: true;
    updatedAt?: true;
    rating?: true;
    discountedPrice?: true;
    status?: true;
    _all?: true;
  };

  export type GameAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Game to aggregate.
     */
    where?: GameWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: GameWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Games from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Games.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Games
     **/
    _count?: true | GameCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: GameAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: GameSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: GameMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: GameMaxAggregateInputType;
  };

  export type GetGameAggregateType<T extends GameAggregateArgs> = {
    [P in keyof T & keyof AggregateGame]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame[P]>
      : GetScalarType<T[P], AggregateGame[P]>;
  };

  export type GameGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: GameWhereInput;
    orderBy?:
      | GameOrderByWithAggregationInput
      | GameOrderByWithAggregationInput[];
    by: GameScalarFieldEnum[] | GameScalarFieldEnum;
    having?: GameScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: GameCountAggregateInputType | true;
    _avg?: GameAvgAggregateInputType;
    _sum?: GameSumAggregateInputType;
    _min?: GameMinAggregateInputType;
    _max?: GameMaxAggregateInputType;
  };

  export type GameGroupByOutputType = {
    id: string;
    title: string;
    description: string;
    price: number;
    releaseDate: Date;
    developer: string;
    publisher: string;
    coverImageUrl: string;
    createdAt: Date;
    updatedAt: Date;
    rating: number;
    discountedPrice: number | null;
    status: $Enums.GameStatus;
    _count: GameCountAggregateOutputType | null;
    _avg: GameAvgAggregateOutputType | null;
    _sum: GameSumAggregateOutputType | null;
    _min: GameMinAggregateOutputType | null;
    _max: GameMaxAggregateOutputType | null;
  };

  type GetGameGroupByPayload<T extends GameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof GameGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], GameGroupByOutputType[P]>
          : GetScalarType<T[P], GameGroupByOutputType[P]>;
      }
    >
  >;

  export type GameSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      price?: boolean;
      releaseDate?: boolean;
      developer?: boolean;
      publisher?: boolean;
      coverImageUrl?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      rating?: boolean;
      discountedPrice?: boolean;
      status?: boolean;
      cartItems?: boolean | Game$cartItemsArgs<ExtArgs>;
      genres?: boolean | Game$genresArgs<ExtArgs>;
      orderItems?: boolean | Game$orderItemsArgs<ExtArgs>;
      reviews?: boolean | Game$reviewsArgs<ExtArgs>;
      screenshots?: boolean | Game$screenshotsArgs<ExtArgs>;
      featuredGames?: boolean | Game$featuredGamesArgs<ExtArgs>;
      recommendedMain?: boolean | Game$recommendedMainArgs<ExtArgs>;
      recommendedRel?: boolean | Game$recommendedRelArgs<ExtArgs>;
      _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["game"]
  >;

  export type GameSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      price?: boolean;
      releaseDate?: boolean;
      developer?: boolean;
      publisher?: boolean;
      coverImageUrl?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      rating?: boolean;
      discountedPrice?: boolean;
      status?: boolean;
    },
    ExtArgs["result"]["game"]
  >;

  export type GameSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      price?: boolean;
      releaseDate?: boolean;
      developer?: boolean;
      publisher?: boolean;
      coverImageUrl?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      rating?: boolean;
      discountedPrice?: boolean;
      status?: boolean;
    },
    ExtArgs["result"]["game"]
  >;

  export type GameSelectScalar = {
    id?: boolean;
    title?: boolean;
    description?: boolean;
    price?: boolean;
    releaseDate?: boolean;
    developer?: boolean;
    publisher?: boolean;
    coverImageUrl?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    rating?: boolean;
    discountedPrice?: boolean;
    status?: boolean;
  };

  export type GameOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "title"
    | "description"
    | "price"
    | "releaseDate"
    | "developer"
    | "publisher"
    | "coverImageUrl"
    | "createdAt"
    | "updatedAt"
    | "rating"
    | "discountedPrice"
    | "status",
    ExtArgs["result"]["game"]
  >;
  export type GameInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    cartItems?: boolean | Game$cartItemsArgs<ExtArgs>;
    genres?: boolean | Game$genresArgs<ExtArgs>;
    orderItems?: boolean | Game$orderItemsArgs<ExtArgs>;
    reviews?: boolean | Game$reviewsArgs<ExtArgs>;
    screenshots?: boolean | Game$screenshotsArgs<ExtArgs>;
    featuredGames?: boolean | Game$featuredGamesArgs<ExtArgs>;
    recommendedMain?: boolean | Game$recommendedMainArgs<ExtArgs>;
    recommendedRel?: boolean | Game$recommendedRelArgs<ExtArgs>;
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type GameIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type GameIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $GamePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Game";
    objects: {
      cartItems: Prisma.$CartItemPayload<ExtArgs>[];
      genres: Prisma.$GameGenrePayload<ExtArgs>[];
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[];
      reviews: Prisma.$ReviewPayload<ExtArgs>[];
      screenshots: Prisma.$ScreenshotPayload<ExtArgs>[];
      featuredGames: Prisma.$FeaturedGamePayload<ExtArgs>[];
      recommendedMain: Prisma.$RecommendedGamePayload<ExtArgs>[];
      recommendedRel: Prisma.$RecommendedGamePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        title: string;
        description: string;
        price: number;
        releaseDate: Date;
        developer: string;
        publisher: string;
        coverImageUrl: string;
        createdAt: Date;
        updatedAt: Date;
        rating: number;
        discountedPrice: number | null;
        status: $Enums.GameStatus;
      },
      ExtArgs["result"]["game"]
    >;
    composites: {};
  };

  type GameGetPayload<S extends boolean | null | undefined | GameDefaultArgs> =
    $Result.GetResult<Prisma.$GamePayload, S>;

  type GameCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<GameFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: GameCountAggregateInputType | true;
  };

  export interface GameDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Game"];
      meta: { name: "Game" };
    };
    /**
     * Find zero or one Game that matches the filter.
     * @param {GameFindUniqueArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameFindUniqueArgs>(
      args: SelectSubset<T, GameFindUniqueArgs<ExtArgs>>
    ): Prisma__GameClient<
      $Result.GetResult<
        Prisma.$GamePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Game that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameFindUniqueOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameFindUniqueOrThrowArgs>(
      args: SelectSubset<T, GameFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GameClient<
      $Result.GetResult<
        Prisma.$GamePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameFindFirstArgs>(
      args?: SelectSubset<T, GameFindFirstArgs<ExtArgs>>
    ): Prisma__GameClient<
      $Result.GetResult<
        Prisma.$GamePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GameFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GameClient<
      $Result.GetResult<
        Prisma.$GamePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Games
     * const games = await prisma.game.findMany()
     *
     * // Get first 10 Games
     * const games = await prisma.game.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const gameWithIdOnly = await prisma.game.findMany({ select: { id: true } })
     *
     */
    findMany<T extends GameFindManyArgs>(
      args?: SelectSubset<T, GameFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$GamePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Game.
     * @param {GameCreateArgs} args - Arguments to create a Game.
     * @example
     * // Create one Game
     * const Game = await prisma.game.create({
     *   data: {
     *     // ... data to create a Game
     *   }
     * })
     *
     */
    create<T extends GameCreateArgs>(
      args: SelectSubset<T, GameCreateArgs<ExtArgs>>
    ): Prisma__GameClient<
      $Result.GetResult<
        Prisma.$GamePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Games.
     * @param {GameCreateManyArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends GameCreateManyArgs>(
      args?: SelectSubset<T, GameCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Games and returns the data saved in the database.
     * @param {GameCreateManyAndReturnArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends GameCreateManyAndReturnArgs>(
      args?: SelectSubset<T, GameCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$GamePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Game.
     * @param {GameDeleteArgs} args - Arguments to delete one Game.
     * @example
     * // Delete one Game
     * const Game = await prisma.game.delete({
     *   where: {
     *     // ... filter to delete one Game
     *   }
     * })
     *
     */
    delete<T extends GameDeleteArgs>(
      args: SelectSubset<T, GameDeleteArgs<ExtArgs>>
    ): Prisma__GameClient<
      $Result.GetResult<
        Prisma.$GamePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Game.
     * @param {GameUpdateArgs} args - Arguments to update one Game.
     * @example
     * // Update one Game
     * const game = await prisma.game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends GameUpdateArgs>(
      args: SelectSubset<T, GameUpdateArgs<ExtArgs>>
    ): Prisma__GameClient<
      $Result.GetResult<
        Prisma.$GamePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Games.
     * @param {GameDeleteManyArgs} args - Arguments to filter Games to delete.
     * @example
     * // Delete a few Games
     * const { count } = await prisma.game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends GameDeleteManyArgs>(
      args?: SelectSubset<T, GameDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends GameUpdateManyArgs>(
      args: SelectSubset<T, GameUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Games and returns the data updated in the database.
     * @param {GameUpdateManyAndReturnArgs} args - Arguments to update many Games.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends GameUpdateManyAndReturnArgs>(
      args: SelectSubset<T, GameUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$GamePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Game.
     * @param {GameUpsertArgs} args - Arguments to update or create a Game.
     * @example
     * // Update or create a Game
     * const game = await prisma.game.upsert({
     *   create: {
     *     // ... data to create a Game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game we want to update
     *   }
     * })
     */
    upsert<T extends GameUpsertArgs>(
      args: SelectSubset<T, GameUpsertArgs<ExtArgs>>
    ): Prisma__GameClient<
      $Result.GetResult<
        Prisma.$GamePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCountArgs} args - Arguments to filter Games to count.
     * @example
     * // Count the number of Games
     * const count = await prisma.game.count({
     *   where: {
     *     // ... the filter for the Games we want to count
     *   }
     * })
     **/
    count<T extends GameCountArgs>(
      args?: Subset<T, GameCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], GameCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends GameAggregateArgs>(
      args: Subset<T, GameAggregateArgs>
    ): Prisma.PrismaPromise<GetGameAggregateType<T>>;

    /**
     * Group by Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends GameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameGroupByArgs["orderBy"] }
        : { orderBy?: GameGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, GameGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetGameGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Game model
     */
    readonly fields: GameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    cartItems<T extends Game$cartItemsArgs<ExtArgs> = {}>(
      args?: Subset<T, Game$cartItemsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CartItemPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    genres<T extends Game$genresArgs<ExtArgs> = {}>(
      args?: Subset<T, Game$genresArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$GameGenrePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    orderItems<T extends Game$orderItemsArgs<ExtArgs> = {}>(
      args?: Subset<T, Game$orderItemsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$OrderItemPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    reviews<T extends Game$reviewsArgs<ExtArgs> = {}>(
      args?: Subset<T, Game$reviewsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ReviewPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    screenshots<T extends Game$screenshotsArgs<ExtArgs> = {}>(
      args?: Subset<T, Game$screenshotsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ScreenshotPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    featuredGames<T extends Game$featuredGamesArgs<ExtArgs> = {}>(
      args?: Subset<T, Game$featuredGamesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$FeaturedGamePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    recommendedMain<T extends Game$recommendedMainArgs<ExtArgs> = {}>(
      args?: Subset<T, Game$recommendedMainArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$RecommendedGamePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    recommendedRel<T extends Game$recommendedRelArgs<ExtArgs> = {}>(
      args?: Subset<T, Game$recommendedRelArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$RecommendedGamePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Game model
   */
  interface GameFieldRefs {
    readonly id: FieldRef<"Game", "String">;
    readonly title: FieldRef<"Game", "String">;
    readonly description: FieldRef<"Game", "String">;
    readonly price: FieldRef<"Game", "Float">;
    readonly releaseDate: FieldRef<"Game", "DateTime">;
    readonly developer: FieldRef<"Game", "String">;
    readonly publisher: FieldRef<"Game", "String">;
    readonly coverImageUrl: FieldRef<"Game", "String">;
    readonly createdAt: FieldRef<"Game", "DateTime">;
    readonly updatedAt: FieldRef<"Game", "DateTime">;
    readonly rating: FieldRef<"Game", "Float">;
    readonly discountedPrice: FieldRef<"Game", "Float">;
    readonly status: FieldRef<"Game", "GameStatus">;
  }

  // Custom InputTypes
  /**
   * Game findUnique
   */
  export type GameFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null;
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput;
  };

  /**
   * Game findUniqueOrThrow
   */
  export type GameFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null;
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput;
  };

  /**
   * Game findFirst
   */
  export type GameFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null;
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Games from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Games.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[];
  };

  /**
   * Game findFirstOrThrow
   */
  export type GameFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null;
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Games from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Games.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[];
  };

  /**
   * Game findMany
   */
  export type GameFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null;
    /**
     * Filter, which Games to fetch.
     */
    where?: GameWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Games.
     */
    cursor?: GameWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Games from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Games.
     */
    skip?: number;
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[];
  };

  /**
   * Game create
   */
  export type GameCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null;
    /**
     * The data needed to create a Game.
     */
    data: XOR<GameCreateInput, GameUncheckedCreateInput>;
  };

  /**
   * Game createMany
   */
  export type GameCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Game createManyAndReturn
   */
  export type GameCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null;
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Game update
   */
  export type GameUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null;
    /**
     * The data needed to update a Game.
     */
    data: XOR<GameUpdateInput, GameUncheckedUpdateInput>;
    /**
     * Choose, which Game to update.
     */
    where: GameWhereUniqueInput;
  };

  /**
   * Game updateMany
   */
  export type GameUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>;
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput;
    /**
     * Limit how many Games to update.
     */
    limit?: number;
  };

  /**
   * Game updateManyAndReturn
   */
  export type GameUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null;
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>;
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput;
    /**
     * Limit how many Games to update.
     */
    limit?: number;
  };

  /**
   * Game upsert
   */
  export type GameUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null;
    /**
     * The filter to search for the Game to update in case it exists.
     */
    where: GameWhereUniqueInput;
    /**
     * In case the Game found by the `where` argument doesn't exist, create a new Game with this data.
     */
    create: XOR<GameCreateInput, GameUncheckedCreateInput>;
    /**
     * In case the Game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameUpdateInput, GameUncheckedUpdateInput>;
  };

  /**
   * Game delete
   */
  export type GameDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null;
    /**
     * Filter which Game to delete.
     */
    where: GameWhereUniqueInput;
  };

  /**
   * Game deleteMany
   */
  export type GameDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Games to delete
     */
    where?: GameWhereInput;
    /**
     * Limit how many Games to delete.
     */
    limit?: number;
  };

  /**
   * Game.cartItems
   */
  export type Game$cartItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null;
    where?: CartItemWhereInput;
    orderBy?:
      | CartItemOrderByWithRelationInput
      | CartItemOrderByWithRelationInput[];
    cursor?: CartItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[];
  };

  /**
   * Game.genres
   */
  export type Game$genresArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GameGenre
     */
    select?: GameGenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GameGenre
     */
    omit?: GameGenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreInclude<ExtArgs> | null;
    where?: GameGenreWhereInput;
    orderBy?:
      | GameGenreOrderByWithRelationInput
      | GameGenreOrderByWithRelationInput[];
    cursor?: GameGenreWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: GameGenreScalarFieldEnum | GameGenreScalarFieldEnum[];
  };

  /**
   * Game.orderItems
   */
  export type Game$orderItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    where?: OrderItemWhereInput;
    orderBy?:
      | OrderItemOrderByWithRelationInput
      | OrderItemOrderByWithRelationInput[];
    cursor?: OrderItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[];
  };

  /**
   * Game.reviews
   */
  export type Game$reviewsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    cursor?: ReviewWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
  };

  /**
   * Game.screenshots
   */
  export type Game$screenshotsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null;
    where?: ScreenshotWhereInput;
    orderBy?:
      | ScreenshotOrderByWithRelationInput
      | ScreenshotOrderByWithRelationInput[];
    cursor?: ScreenshotWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ScreenshotScalarFieldEnum | ScreenshotScalarFieldEnum[];
  };

  /**
   * Game.featuredGames
   */
  export type Game$featuredGamesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeaturedGame
     */
    select?: FeaturedGameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FeaturedGame
     */
    omit?: FeaturedGameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedGameInclude<ExtArgs> | null;
    where?: FeaturedGameWhereInput;
    orderBy?:
      | FeaturedGameOrderByWithRelationInput
      | FeaturedGameOrderByWithRelationInput[];
    cursor?: FeaturedGameWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FeaturedGameScalarFieldEnum | FeaturedGameScalarFieldEnum[];
  };

  /**
   * Game.recommendedMain
   */
  export type Game$recommendedMainArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RecommendedGame
     */
    select?: RecommendedGameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RecommendedGame
     */
    omit?: RecommendedGameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedGameInclude<ExtArgs> | null;
    where?: RecommendedGameWhereInput;
    orderBy?:
      | RecommendedGameOrderByWithRelationInput
      | RecommendedGameOrderByWithRelationInput[];
    cursor?: RecommendedGameWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | RecommendedGameScalarFieldEnum
      | RecommendedGameScalarFieldEnum[];
  };

  /**
   * Game.recommendedRel
   */
  export type Game$recommendedRelArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RecommendedGame
     */
    select?: RecommendedGameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RecommendedGame
     */
    omit?: RecommendedGameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedGameInclude<ExtArgs> | null;
    where?: RecommendedGameWhereInput;
    orderBy?:
      | RecommendedGameOrderByWithRelationInput
      | RecommendedGameOrderByWithRelationInput[];
    cursor?: RecommendedGameWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | RecommendedGameScalarFieldEnum
      | RecommendedGameScalarFieldEnum[];
  };

  /**
   * Game without action
   */
  export type GameDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null;
  };

  /**
   * Model Genre
   */

  export type AggregateGenre = {
    _count: GenreCountAggregateOutputType | null;
    _min: GenreMinAggregateOutputType | null;
    _max: GenreMaxAggregateOutputType | null;
  };

  export type GenreMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    parentId: string | null;
  };

  export type GenreMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    parentId: string | null;
  };

  export type GenreCountAggregateOutputType = {
    id: number;
    name: number;
    parentId: number;
    _all: number;
  };

  export type GenreMinAggregateInputType = {
    id?: true;
    name?: true;
    parentId?: true;
  };

  export type GenreMaxAggregateInputType = {
    id?: true;
    name?: true;
    parentId?: true;
  };

  export type GenreCountAggregateInputType = {
    id?: true;
    name?: true;
    parentId?: true;
    _all?: true;
  };

  export type GenreAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Genre to aggregate.
     */
    where?: GenreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: GenreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Genres.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Genres
     **/
    _count?: true | GenreCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: GenreMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: GenreMaxAggregateInputType;
  };

  export type GetGenreAggregateType<T extends GenreAggregateArgs> = {
    [P in keyof T & keyof AggregateGenre]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenre[P]>
      : GetScalarType<T[P], AggregateGenre[P]>;
  };

  export type GenreGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: GenreWhereInput;
    orderBy?:
      | GenreOrderByWithAggregationInput
      | GenreOrderByWithAggregationInput[];
    by: GenreScalarFieldEnum[] | GenreScalarFieldEnum;
    having?: GenreScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: GenreCountAggregateInputType | true;
    _min?: GenreMinAggregateInputType;
    _max?: GenreMaxAggregateInputType;
  };

  export type GenreGroupByOutputType = {
    id: string;
    name: string;
    parentId: string | null;
    _count: GenreCountAggregateOutputType | null;
    _min: GenreMinAggregateOutputType | null;
    _max: GenreMaxAggregateOutputType | null;
  };

  type GetGenreGroupByPayload<T extends GenreGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<GenreGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof GenreGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenreGroupByOutputType[P]>
            : GetScalarType<T[P], GenreGroupByOutputType[P]>;
        }
      >
    >;

  export type GenreSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      parentId?: boolean;
      games?: boolean | Genre$gamesArgs<ExtArgs>;
      parent?: boolean | Genre$parentArgs<ExtArgs>;
      subGenres?: boolean | Genre$subGenresArgs<ExtArgs>;
      _count?: boolean | GenreCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["genre"]
  >;

  export type GenreSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      parentId?: boolean;
      parent?: boolean | Genre$parentArgs<ExtArgs>;
    },
    ExtArgs["result"]["genre"]
  >;

  export type GenreSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      parentId?: boolean;
      parent?: boolean | Genre$parentArgs<ExtArgs>;
    },
    ExtArgs["result"]["genre"]
  >;

  export type GenreSelectScalar = {
    id?: boolean;
    name?: boolean;
    parentId?: boolean;
  };

  export type GenreOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "name" | "parentId",
    ExtArgs["result"]["genre"]
  >;
  export type GenreInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    games?: boolean | Genre$gamesArgs<ExtArgs>;
    parent?: boolean | Genre$parentArgs<ExtArgs>;
    subGenres?: boolean | Genre$subGenresArgs<ExtArgs>;
    _count?: boolean | GenreCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type GenreIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    parent?: boolean | Genre$parentArgs<ExtArgs>;
  };
  export type GenreIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    parent?: boolean | Genre$parentArgs<ExtArgs>;
  };

  export type $GenrePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Genre";
    objects: {
      games: Prisma.$GameGenrePayload<ExtArgs>[];
      parent: Prisma.$GenrePayload<ExtArgs> | null;
      subGenres: Prisma.$GenrePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        parentId: string | null;
      },
      ExtArgs["result"]["genre"]
    >;
    composites: {};
  };

  type GenreGetPayload<
    S extends boolean | null | undefined | GenreDefaultArgs,
  > = $Result.GetResult<Prisma.$GenrePayload, S>;

  type GenreCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<GenreFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: GenreCountAggregateInputType | true;
  };

  export interface GenreDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Genre"];
      meta: { name: "Genre" };
    };
    /**
     * Find zero or one Genre that matches the filter.
     * @param {GenreFindUniqueArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GenreFindUniqueArgs>(
      args: SelectSubset<T, GenreFindUniqueArgs<ExtArgs>>
    ): Prisma__GenreClient<
      $Result.GetResult<
        Prisma.$GenrePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Genre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GenreFindUniqueOrThrowArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GenreFindUniqueOrThrowArgs>(
      args: SelectSubset<T, GenreFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GenreClient<
      $Result.GetResult<
        Prisma.$GenrePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Genre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindFirstArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GenreFindFirstArgs>(
      args?: SelectSubset<T, GenreFindFirstArgs<ExtArgs>>
    ): Prisma__GenreClient<
      $Result.GetResult<
        Prisma.$GenrePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Genre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindFirstOrThrowArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GenreFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GenreFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GenreClient<
      $Result.GetResult<
        Prisma.$GenrePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Genres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genres
     * const genres = await prisma.genre.findMany()
     *
     * // Get first 10 Genres
     * const genres = await prisma.genre.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const genreWithIdOnly = await prisma.genre.findMany({ select: { id: true } })
     *
     */
    findMany<T extends GenreFindManyArgs>(
      args?: SelectSubset<T, GenreFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$GenrePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Genre.
     * @param {GenreCreateArgs} args - Arguments to create a Genre.
     * @example
     * // Create one Genre
     * const Genre = await prisma.genre.create({
     *   data: {
     *     // ... data to create a Genre
     *   }
     * })
     *
     */
    create<T extends GenreCreateArgs>(
      args: SelectSubset<T, GenreCreateArgs<ExtArgs>>
    ): Prisma__GenreClient<
      $Result.GetResult<
        Prisma.$GenrePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Genres.
     * @param {GenreCreateManyArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genre = await prisma.genre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends GenreCreateManyArgs>(
      args?: SelectSubset<T, GenreCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Genres and returns the data saved in the database.
     * @param {GenreCreateManyAndReturnArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genre = await prisma.genre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Genres and only return the `id`
     * const genreWithIdOnly = await prisma.genre.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends GenreCreateManyAndReturnArgs>(
      args?: SelectSubset<T, GenreCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$GenrePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Genre.
     * @param {GenreDeleteArgs} args - Arguments to delete one Genre.
     * @example
     * // Delete one Genre
     * const Genre = await prisma.genre.delete({
     *   where: {
     *     // ... filter to delete one Genre
     *   }
     * })
     *
     */
    delete<T extends GenreDeleteArgs>(
      args: SelectSubset<T, GenreDeleteArgs<ExtArgs>>
    ): Prisma__GenreClient<
      $Result.GetResult<
        Prisma.$GenrePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Genre.
     * @param {GenreUpdateArgs} args - Arguments to update one Genre.
     * @example
     * // Update one Genre
     * const genre = await prisma.genre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends GenreUpdateArgs>(
      args: SelectSubset<T, GenreUpdateArgs<ExtArgs>>
    ): Prisma__GenreClient<
      $Result.GetResult<
        Prisma.$GenrePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Genres.
     * @param {GenreDeleteManyArgs} args - Arguments to filter Genres to delete.
     * @example
     * // Delete a few Genres
     * const { count } = await prisma.genre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends GenreDeleteManyArgs>(
      args?: SelectSubset<T, GenreDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genres
     * const genre = await prisma.genre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends GenreUpdateManyArgs>(
      args: SelectSubset<T, GenreUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Genres and returns the data updated in the database.
     * @param {GenreUpdateManyAndReturnArgs} args - Arguments to update many Genres.
     * @example
     * // Update many Genres
     * const genre = await prisma.genre.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Genres and only return the `id`
     * const genreWithIdOnly = await prisma.genre.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends GenreUpdateManyAndReturnArgs>(
      args: SelectSubset<T, GenreUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$GenrePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Genre.
     * @param {GenreUpsertArgs} args - Arguments to update or create a Genre.
     * @example
     * // Update or create a Genre
     * const genre = await prisma.genre.upsert({
     *   create: {
     *     // ... data to create a Genre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Genre we want to update
     *   }
     * })
     */
    upsert<T extends GenreUpsertArgs>(
      args: SelectSubset<T, GenreUpsertArgs<ExtArgs>>
    ): Prisma__GenreClient<
      $Result.GetResult<
        Prisma.$GenrePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreCountArgs} args - Arguments to filter Genres to count.
     * @example
     * // Count the number of Genres
     * const count = await prisma.genre.count({
     *   where: {
     *     // ... the filter for the Genres we want to count
     *   }
     * })
     **/
    count<T extends GenreCountArgs>(
      args?: Subset<T, GenreCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], GenreCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends GenreAggregateArgs>(
      args: Subset<T, GenreAggregateArgs>
    ): Prisma.PrismaPromise<GetGenreAggregateType<T>>;

    /**
     * Group by Genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends GenreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenreGroupByArgs["orderBy"] }
        : { orderBy?: GenreGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, GenreGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetGenreGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Genre model
     */
    readonly fields: GenreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Genre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GenreClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    games<T extends Genre$gamesArgs<ExtArgs> = {}>(
      args?: Subset<T, Genre$gamesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$GameGenrePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    parent<T extends Genre$parentArgs<ExtArgs> = {}>(
      args?: Subset<T, Genre$parentArgs<ExtArgs>>
    ): Prisma__GenreClient<
      $Result.GetResult<
        Prisma.$GenrePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    subGenres<T extends Genre$subGenresArgs<ExtArgs> = {}>(
      args?: Subset<T, Genre$subGenresArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$GenrePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Genre model
   */
  interface GenreFieldRefs {
    readonly id: FieldRef<"Genre", "String">;
    readonly name: FieldRef<"Genre", "String">;
    readonly parentId: FieldRef<"Genre", "String">;
  }

  // Custom InputTypes
  /**
   * Genre findUnique
   */
  export type GenreFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null;
    /**
     * Filter, which Genre to fetch.
     */
    where: GenreWhereUniqueInput;
  };

  /**
   * Genre findUniqueOrThrow
   */
  export type GenreFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null;
    /**
     * Filter, which Genre to fetch.
     */
    where: GenreWhereUniqueInput;
  };

  /**
   * Genre findFirst
   */
  export type GenreFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null;
    /**
     * Filter, which Genre to fetch.
     */
    where?: GenreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Genres.
     */
    cursor?: GenreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Genres.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Genres.
     */
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[];
  };

  /**
   * Genre findFirstOrThrow
   */
  export type GenreFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null;
    /**
     * Filter, which Genre to fetch.
     */
    where?: GenreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Genres.
     */
    cursor?: GenreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Genres.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Genres.
     */
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[];
  };

  /**
   * Genre findMany
   */
  export type GenreFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null;
    /**
     * Filter, which Genres to fetch.
     */
    where?: GenreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Genres.
     */
    cursor?: GenreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Genres.
     */
    skip?: number;
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[];
  };

  /**
   * Genre create
   */
  export type GenreCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null;
    /**
     * The data needed to create a Genre.
     */
    data: XOR<GenreCreateInput, GenreUncheckedCreateInput>;
  };

  /**
   * Genre createMany
   */
  export type GenreCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Genres.
     */
    data: GenreCreateManyInput | GenreCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Genre createManyAndReturn
   */
  export type GenreCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null;
    /**
     * The data used to create many Genres.
     */
    data: GenreCreateManyInput | GenreCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Genre update
   */
  export type GenreUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null;
    /**
     * The data needed to update a Genre.
     */
    data: XOR<GenreUpdateInput, GenreUncheckedUpdateInput>;
    /**
     * Choose, which Genre to update.
     */
    where: GenreWhereUniqueInput;
  };

  /**
   * Genre updateMany
   */
  export type GenreUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Genres.
     */
    data: XOR<GenreUpdateManyMutationInput, GenreUncheckedUpdateManyInput>;
    /**
     * Filter which Genres to update
     */
    where?: GenreWhereInput;
    /**
     * Limit how many Genres to update.
     */
    limit?: number;
  };

  /**
   * Genre updateManyAndReturn
   */
  export type GenreUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null;
    /**
     * The data used to update Genres.
     */
    data: XOR<GenreUpdateManyMutationInput, GenreUncheckedUpdateManyInput>;
    /**
     * Filter which Genres to update
     */
    where?: GenreWhereInput;
    /**
     * Limit how many Genres to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Genre upsert
   */
  export type GenreUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null;
    /**
     * The filter to search for the Genre to update in case it exists.
     */
    where: GenreWhereUniqueInput;
    /**
     * In case the Genre found by the `where` argument doesn't exist, create a new Genre with this data.
     */
    create: XOR<GenreCreateInput, GenreUncheckedCreateInput>;
    /**
     * In case the Genre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenreUpdateInput, GenreUncheckedUpdateInput>;
  };

  /**
   * Genre delete
   */
  export type GenreDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null;
    /**
     * Filter which Genre to delete.
     */
    where: GenreWhereUniqueInput;
  };

  /**
   * Genre deleteMany
   */
  export type GenreDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Genres to delete
     */
    where?: GenreWhereInput;
    /**
     * Limit how many Genres to delete.
     */
    limit?: number;
  };

  /**
   * Genre.games
   */
  export type Genre$gamesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GameGenre
     */
    select?: GameGenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GameGenre
     */
    omit?: GameGenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreInclude<ExtArgs> | null;
    where?: GameGenreWhereInput;
    orderBy?:
      | GameGenreOrderByWithRelationInput
      | GameGenreOrderByWithRelationInput[];
    cursor?: GameGenreWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: GameGenreScalarFieldEnum | GameGenreScalarFieldEnum[];
  };

  /**
   * Genre.parent
   */
  export type Genre$parentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null;
    where?: GenreWhereInput;
  };

  /**
   * Genre.subGenres
   */
  export type Genre$subGenresArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null;
    where?: GenreWhereInput;
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[];
    cursor?: GenreWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[];
  };

  /**
   * Genre without action
   */
  export type GenreDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null;
  };

  /**
   * Model GameGenre
   */

  export type AggregateGameGenre = {
    _count: GameGenreCountAggregateOutputType | null;
    _min: GameGenreMinAggregateOutputType | null;
    _max: GameGenreMaxAggregateOutputType | null;
  };

  export type GameGenreMinAggregateOutputType = {
    gameId: string | null;
    genreId: string | null;
  };

  export type GameGenreMaxAggregateOutputType = {
    gameId: string | null;
    genreId: string | null;
  };

  export type GameGenreCountAggregateOutputType = {
    gameId: number;
    genreId: number;
    _all: number;
  };

  export type GameGenreMinAggregateInputType = {
    gameId?: true;
    genreId?: true;
  };

  export type GameGenreMaxAggregateInputType = {
    gameId?: true;
    genreId?: true;
  };

  export type GameGenreCountAggregateInputType = {
    gameId?: true;
    genreId?: true;
    _all?: true;
  };

  export type GameGenreAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which GameGenre to aggregate.
     */
    where?: GameGenreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of GameGenres to fetch.
     */
    orderBy?:
      | GameGenreOrderByWithRelationInput
      | GameGenreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: GameGenreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` GameGenres from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` GameGenres.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned GameGenres
     **/
    _count?: true | GameGenreCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: GameGenreMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: GameGenreMaxAggregateInputType;
  };

  export type GetGameGenreAggregateType<T extends GameGenreAggregateArgs> = {
    [P in keyof T & keyof AggregateGameGenre]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameGenre[P]>
      : GetScalarType<T[P], AggregateGameGenre[P]>;
  };

  export type GameGenreGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: GameGenreWhereInput;
    orderBy?:
      | GameGenreOrderByWithAggregationInput
      | GameGenreOrderByWithAggregationInput[];
    by: GameGenreScalarFieldEnum[] | GameGenreScalarFieldEnum;
    having?: GameGenreScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: GameGenreCountAggregateInputType | true;
    _min?: GameGenreMinAggregateInputType;
    _max?: GameGenreMaxAggregateInputType;
  };

  export type GameGenreGroupByOutputType = {
    gameId: string;
    genreId: string;
    _count: GameGenreCountAggregateOutputType | null;
    _min: GameGenreMinAggregateOutputType | null;
    _max: GameGenreMaxAggregateOutputType | null;
  };

  type GetGameGenreGroupByPayload<T extends GameGenreGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<GameGenreGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof GameGenreGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameGenreGroupByOutputType[P]>
            : GetScalarType<T[P], GameGenreGroupByOutputType[P]>;
        }
      >
    >;

  export type GameGenreSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      gameId?: boolean;
      genreId?: boolean;
      game?: boolean | GameDefaultArgs<ExtArgs>;
      genre?: boolean | GenreDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["gameGenre"]
  >;

  export type GameGenreSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      gameId?: boolean;
      genreId?: boolean;
      game?: boolean | GameDefaultArgs<ExtArgs>;
      genre?: boolean | GenreDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["gameGenre"]
  >;

  export type GameGenreSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      gameId?: boolean;
      genreId?: boolean;
      game?: boolean | GameDefaultArgs<ExtArgs>;
      genre?: boolean | GenreDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["gameGenre"]
  >;

  export type GameGenreSelectScalar = {
    gameId?: boolean;
    genreId?: boolean;
  };

  export type GameGenreOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<"gameId" | "genreId", ExtArgs["result"]["gameGenre"]>;
  export type GameGenreInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    game?: boolean | GameDefaultArgs<ExtArgs>;
    genre?: boolean | GenreDefaultArgs<ExtArgs>;
  };
  export type GameGenreIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    game?: boolean | GameDefaultArgs<ExtArgs>;
    genre?: boolean | GenreDefaultArgs<ExtArgs>;
  };
  export type GameGenreIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    game?: boolean | GameDefaultArgs<ExtArgs>;
    genre?: boolean | GenreDefaultArgs<ExtArgs>;
  };

  export type $GameGenrePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "GameGenre";
    objects: {
      game: Prisma.$GamePayload<ExtArgs>;
      genre: Prisma.$GenrePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        gameId: string;
        genreId: string;
      },
      ExtArgs["result"]["gameGenre"]
    >;
    composites: {};
  };

  type GameGenreGetPayload<
    S extends boolean | null | undefined | GameGenreDefaultArgs,
  > = $Result.GetResult<Prisma.$GameGenrePayload, S>;

  type GameGenreCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    GameGenreFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: GameGenreCountAggregateInputType | true;
  };

  export interface GameGenreDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["GameGenre"];
      meta: { name: "GameGenre" };
    };
    /**
     * Find zero or one GameGenre that matches the filter.
     * @param {GameGenreFindUniqueArgs} args - Arguments to find a GameGenre
     * @example
     * // Get one GameGenre
     * const gameGenre = await prisma.gameGenre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameGenreFindUniqueArgs>(
      args: SelectSubset<T, GameGenreFindUniqueArgs<ExtArgs>>
    ): Prisma__GameGenreClient<
      $Result.GetResult<
        Prisma.$GameGenrePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one GameGenre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameGenreFindUniqueOrThrowArgs} args - Arguments to find a GameGenre
     * @example
     * // Get one GameGenre
     * const gameGenre = await prisma.gameGenre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameGenreFindUniqueOrThrowArgs>(
      args: SelectSubset<T, GameGenreFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GameGenreClient<
      $Result.GetResult<
        Prisma.$GameGenrePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first GameGenre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGenreFindFirstArgs} args - Arguments to find a GameGenre
     * @example
     * // Get one GameGenre
     * const gameGenre = await prisma.gameGenre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameGenreFindFirstArgs>(
      args?: SelectSubset<T, GameGenreFindFirstArgs<ExtArgs>>
    ): Prisma__GameGenreClient<
      $Result.GetResult<
        Prisma.$GameGenrePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first GameGenre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGenreFindFirstOrThrowArgs} args - Arguments to find a GameGenre
     * @example
     * // Get one GameGenre
     * const gameGenre = await prisma.gameGenre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameGenreFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GameGenreFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GameGenreClient<
      $Result.GetResult<
        Prisma.$GameGenrePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more GameGenres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGenreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameGenres
     * const gameGenres = await prisma.gameGenre.findMany()
     *
     * // Get first 10 GameGenres
     * const gameGenres = await prisma.gameGenre.findMany({ take: 10 })
     *
     * // Only select the `gameId`
     * const gameGenreWithGameIdOnly = await prisma.gameGenre.findMany({ select: { gameId: true } })
     *
     */
    findMany<T extends GameGenreFindManyArgs>(
      args?: SelectSubset<T, GameGenreFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$GameGenrePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a GameGenre.
     * @param {GameGenreCreateArgs} args - Arguments to create a GameGenre.
     * @example
     * // Create one GameGenre
     * const GameGenre = await prisma.gameGenre.create({
     *   data: {
     *     // ... data to create a GameGenre
     *   }
     * })
     *
     */
    create<T extends GameGenreCreateArgs>(
      args: SelectSubset<T, GameGenreCreateArgs<ExtArgs>>
    ): Prisma__GameGenreClient<
      $Result.GetResult<
        Prisma.$GameGenrePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many GameGenres.
     * @param {GameGenreCreateManyArgs} args - Arguments to create many GameGenres.
     * @example
     * // Create many GameGenres
     * const gameGenre = await prisma.gameGenre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends GameGenreCreateManyArgs>(
      args?: SelectSubset<T, GameGenreCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many GameGenres and returns the data saved in the database.
     * @param {GameGenreCreateManyAndReturnArgs} args - Arguments to create many GameGenres.
     * @example
     * // Create many GameGenres
     * const gameGenre = await prisma.gameGenre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many GameGenres and only return the `gameId`
     * const gameGenreWithGameIdOnly = await prisma.gameGenre.createManyAndReturn({
     *   select: { gameId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends GameGenreCreateManyAndReturnArgs>(
      args?: SelectSubset<T, GameGenreCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$GameGenrePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a GameGenre.
     * @param {GameGenreDeleteArgs} args - Arguments to delete one GameGenre.
     * @example
     * // Delete one GameGenre
     * const GameGenre = await prisma.gameGenre.delete({
     *   where: {
     *     // ... filter to delete one GameGenre
     *   }
     * })
     *
     */
    delete<T extends GameGenreDeleteArgs>(
      args: SelectSubset<T, GameGenreDeleteArgs<ExtArgs>>
    ): Prisma__GameGenreClient<
      $Result.GetResult<
        Prisma.$GameGenrePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one GameGenre.
     * @param {GameGenreUpdateArgs} args - Arguments to update one GameGenre.
     * @example
     * // Update one GameGenre
     * const gameGenre = await prisma.gameGenre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends GameGenreUpdateArgs>(
      args: SelectSubset<T, GameGenreUpdateArgs<ExtArgs>>
    ): Prisma__GameGenreClient<
      $Result.GetResult<
        Prisma.$GameGenrePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more GameGenres.
     * @param {GameGenreDeleteManyArgs} args - Arguments to filter GameGenres to delete.
     * @example
     * // Delete a few GameGenres
     * const { count } = await prisma.gameGenre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends GameGenreDeleteManyArgs>(
      args?: SelectSubset<T, GameGenreDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more GameGenres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGenreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameGenres
     * const gameGenre = await prisma.gameGenre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends GameGenreUpdateManyArgs>(
      args: SelectSubset<T, GameGenreUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more GameGenres and returns the data updated in the database.
     * @param {GameGenreUpdateManyAndReturnArgs} args - Arguments to update many GameGenres.
     * @example
     * // Update many GameGenres
     * const gameGenre = await prisma.gameGenre.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more GameGenres and only return the `gameId`
     * const gameGenreWithGameIdOnly = await prisma.gameGenre.updateManyAndReturn({
     *   select: { gameId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends GameGenreUpdateManyAndReturnArgs>(
      args: SelectSubset<T, GameGenreUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$GameGenrePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one GameGenre.
     * @param {GameGenreUpsertArgs} args - Arguments to update or create a GameGenre.
     * @example
     * // Update or create a GameGenre
     * const gameGenre = await prisma.gameGenre.upsert({
     *   create: {
     *     // ... data to create a GameGenre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameGenre we want to update
     *   }
     * })
     */
    upsert<T extends GameGenreUpsertArgs>(
      args: SelectSubset<T, GameGenreUpsertArgs<ExtArgs>>
    ): Prisma__GameGenreClient<
      $Result.GetResult<
        Prisma.$GameGenrePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of GameGenres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGenreCountArgs} args - Arguments to filter GameGenres to count.
     * @example
     * // Count the number of GameGenres
     * const count = await prisma.gameGenre.count({
     *   where: {
     *     // ... the filter for the GameGenres we want to count
     *   }
     * })
     **/
    count<T extends GameGenreCountArgs>(
      args?: Subset<T, GameGenreCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], GameGenreCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a GameGenre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGenreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends GameGenreAggregateArgs>(
      args: Subset<T, GameGenreAggregateArgs>
    ): Prisma.PrismaPromise<GetGameGenreAggregateType<T>>;

    /**
     * Group by GameGenre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGenreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends GameGenreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameGenreGroupByArgs["orderBy"] }
        : { orderBy?: GameGenreGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, GameGenreGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetGameGenreGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the GameGenre model
     */
    readonly fields: GameGenreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameGenre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameGenreClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    game<T extends GameDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, GameDefaultArgs<ExtArgs>>
    ): Prisma__GameClient<
      | $Result.GetResult<
          Prisma.$GamePayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    genre<T extends GenreDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, GenreDefaultArgs<ExtArgs>>
    ): Prisma__GenreClient<
      | $Result.GetResult<
          Prisma.$GenrePayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the GameGenre model
   */
  interface GameGenreFieldRefs {
    readonly gameId: FieldRef<"GameGenre", "String">;
    readonly genreId: FieldRef<"GameGenre", "String">;
  }

  // Custom InputTypes
  /**
   * GameGenre findUnique
   */
  export type GameGenreFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GameGenre
     */
    select?: GameGenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GameGenre
     */
    omit?: GameGenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreInclude<ExtArgs> | null;
    /**
     * Filter, which GameGenre to fetch.
     */
    where: GameGenreWhereUniqueInput;
  };

  /**
   * GameGenre findUniqueOrThrow
   */
  export type GameGenreFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GameGenre
     */
    select?: GameGenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GameGenre
     */
    omit?: GameGenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreInclude<ExtArgs> | null;
    /**
     * Filter, which GameGenre to fetch.
     */
    where: GameGenreWhereUniqueInput;
  };

  /**
   * GameGenre findFirst
   */
  export type GameGenreFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GameGenre
     */
    select?: GameGenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GameGenre
     */
    omit?: GameGenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreInclude<ExtArgs> | null;
    /**
     * Filter, which GameGenre to fetch.
     */
    where?: GameGenreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of GameGenres to fetch.
     */
    orderBy?:
      | GameGenreOrderByWithRelationInput
      | GameGenreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for GameGenres.
     */
    cursor?: GameGenreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` GameGenres from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` GameGenres.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of GameGenres.
     */
    distinct?: GameGenreScalarFieldEnum | GameGenreScalarFieldEnum[];
  };

  /**
   * GameGenre findFirstOrThrow
   */
  export type GameGenreFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GameGenre
     */
    select?: GameGenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GameGenre
     */
    omit?: GameGenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreInclude<ExtArgs> | null;
    /**
     * Filter, which GameGenre to fetch.
     */
    where?: GameGenreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of GameGenres to fetch.
     */
    orderBy?:
      | GameGenreOrderByWithRelationInput
      | GameGenreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for GameGenres.
     */
    cursor?: GameGenreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` GameGenres from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` GameGenres.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of GameGenres.
     */
    distinct?: GameGenreScalarFieldEnum | GameGenreScalarFieldEnum[];
  };

  /**
   * GameGenre findMany
   */
  export type GameGenreFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GameGenre
     */
    select?: GameGenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GameGenre
     */
    omit?: GameGenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreInclude<ExtArgs> | null;
    /**
     * Filter, which GameGenres to fetch.
     */
    where?: GameGenreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of GameGenres to fetch.
     */
    orderBy?:
      | GameGenreOrderByWithRelationInput
      | GameGenreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing GameGenres.
     */
    cursor?: GameGenreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` GameGenres from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` GameGenres.
     */
    skip?: number;
    distinct?: GameGenreScalarFieldEnum | GameGenreScalarFieldEnum[];
  };

  /**
   * GameGenre create
   */
  export type GameGenreCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GameGenre
     */
    select?: GameGenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GameGenre
     */
    omit?: GameGenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreInclude<ExtArgs> | null;
    /**
     * The data needed to create a GameGenre.
     */
    data: XOR<GameGenreCreateInput, GameGenreUncheckedCreateInput>;
  };

  /**
   * GameGenre createMany
   */
  export type GameGenreCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many GameGenres.
     */
    data: GameGenreCreateManyInput | GameGenreCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * GameGenre createManyAndReturn
   */
  export type GameGenreCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GameGenre
     */
    select?: GameGenreSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the GameGenre
     */
    omit?: GameGenreOmit<ExtArgs> | null;
    /**
     * The data used to create many GameGenres.
     */
    data: GameGenreCreateManyInput | GameGenreCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * GameGenre update
   */
  export type GameGenreUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GameGenre
     */
    select?: GameGenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GameGenre
     */
    omit?: GameGenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreInclude<ExtArgs> | null;
    /**
     * The data needed to update a GameGenre.
     */
    data: XOR<GameGenreUpdateInput, GameGenreUncheckedUpdateInput>;
    /**
     * Choose, which GameGenre to update.
     */
    where: GameGenreWhereUniqueInput;
  };

  /**
   * GameGenre updateMany
   */
  export type GameGenreUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update GameGenres.
     */
    data: XOR<
      GameGenreUpdateManyMutationInput,
      GameGenreUncheckedUpdateManyInput
    >;
    /**
     * Filter which GameGenres to update
     */
    where?: GameGenreWhereInput;
    /**
     * Limit how many GameGenres to update.
     */
    limit?: number;
  };

  /**
   * GameGenre updateManyAndReturn
   */
  export type GameGenreUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GameGenre
     */
    select?: GameGenreSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the GameGenre
     */
    omit?: GameGenreOmit<ExtArgs> | null;
    /**
     * The data used to update GameGenres.
     */
    data: XOR<
      GameGenreUpdateManyMutationInput,
      GameGenreUncheckedUpdateManyInput
    >;
    /**
     * Filter which GameGenres to update
     */
    where?: GameGenreWhereInput;
    /**
     * Limit how many GameGenres to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * GameGenre upsert
   */
  export type GameGenreUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GameGenre
     */
    select?: GameGenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GameGenre
     */
    omit?: GameGenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreInclude<ExtArgs> | null;
    /**
     * The filter to search for the GameGenre to update in case it exists.
     */
    where: GameGenreWhereUniqueInput;
    /**
     * In case the GameGenre found by the `where` argument doesn't exist, create a new GameGenre with this data.
     */
    create: XOR<GameGenreCreateInput, GameGenreUncheckedCreateInput>;
    /**
     * In case the GameGenre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameGenreUpdateInput, GameGenreUncheckedUpdateInput>;
  };

  /**
   * GameGenre delete
   */
  export type GameGenreDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GameGenre
     */
    select?: GameGenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GameGenre
     */
    omit?: GameGenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreInclude<ExtArgs> | null;
    /**
     * Filter which GameGenre to delete.
     */
    where: GameGenreWhereUniqueInput;
  };

  /**
   * GameGenre deleteMany
   */
  export type GameGenreDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which GameGenres to delete
     */
    where?: GameGenreWhereInput;
    /**
     * Limit how many GameGenres to delete.
     */
    limit?: number;
  };

  /**
   * GameGenre without action
   */
  export type GameGenreDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GameGenre
     */
    select?: GameGenreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the GameGenre
     */
    omit?: GameGenreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameGenreInclude<ExtArgs> | null;
  };

  /**
   * Model Screenshot
   */

  export type AggregateScreenshot = {
    _count: ScreenshotCountAggregateOutputType | null;
    _min: ScreenshotMinAggregateOutputType | null;
    _max: ScreenshotMaxAggregateOutputType | null;
  };

  export type ScreenshotMinAggregateOutputType = {
    id: string | null;
    gameId: string | null;
    imageUrl: string | null;
    caption: string | null;
  };

  export type ScreenshotMaxAggregateOutputType = {
    id: string | null;
    gameId: string | null;
    imageUrl: string | null;
    caption: string | null;
  };

  export type ScreenshotCountAggregateOutputType = {
    id: number;
    gameId: number;
    imageUrl: number;
    caption: number;
    _all: number;
  };

  export type ScreenshotMinAggregateInputType = {
    id?: true;
    gameId?: true;
    imageUrl?: true;
    caption?: true;
  };

  export type ScreenshotMaxAggregateInputType = {
    id?: true;
    gameId?: true;
    imageUrl?: true;
    caption?: true;
  };

  export type ScreenshotCountAggregateInputType = {
    id?: true;
    gameId?: true;
    imageUrl?: true;
    caption?: true;
    _all?: true;
  };

  export type ScreenshotAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Screenshot to aggregate.
     */
    where?: ScreenshotWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Screenshots to fetch.
     */
    orderBy?:
      | ScreenshotOrderByWithRelationInput
      | ScreenshotOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ScreenshotWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Screenshots from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Screenshots.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Screenshots
     **/
    _count?: true | ScreenshotCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ScreenshotMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ScreenshotMaxAggregateInputType;
  };

  export type GetScreenshotAggregateType<T extends ScreenshotAggregateArgs> = {
    [P in keyof T & keyof AggregateScreenshot]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScreenshot[P]>
      : GetScalarType<T[P], AggregateScreenshot[P]>;
  };

  export type ScreenshotGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ScreenshotWhereInput;
    orderBy?:
      | ScreenshotOrderByWithAggregationInput
      | ScreenshotOrderByWithAggregationInput[];
    by: ScreenshotScalarFieldEnum[] | ScreenshotScalarFieldEnum;
    having?: ScreenshotScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ScreenshotCountAggregateInputType | true;
    _min?: ScreenshotMinAggregateInputType;
    _max?: ScreenshotMaxAggregateInputType;
  };

  export type ScreenshotGroupByOutputType = {
    id: string;
    gameId: string;
    imageUrl: string;
    caption: string | null;
    _count: ScreenshotCountAggregateOutputType | null;
    _min: ScreenshotMinAggregateOutputType | null;
    _max: ScreenshotMaxAggregateOutputType | null;
  };

  type GetScreenshotGroupByPayload<T extends ScreenshotGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ScreenshotGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof ScreenshotGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScreenshotGroupByOutputType[P]>
            : GetScalarType<T[P], ScreenshotGroupByOutputType[P]>;
        }
      >
    >;

  export type ScreenshotSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      gameId?: boolean;
      imageUrl?: boolean;
      caption?: boolean;
      game?: boolean | GameDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["screenshot"]
  >;

  export type ScreenshotSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      gameId?: boolean;
      imageUrl?: boolean;
      caption?: boolean;
      game?: boolean | GameDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["screenshot"]
  >;

  export type ScreenshotSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      gameId?: boolean;
      imageUrl?: boolean;
      caption?: boolean;
      game?: boolean | GameDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["screenshot"]
  >;

  export type ScreenshotSelectScalar = {
    id?: boolean;
    gameId?: boolean;
    imageUrl?: boolean;
    caption?: boolean;
  };

  export type ScreenshotOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "gameId" | "imageUrl" | "caption",
    ExtArgs["result"]["screenshot"]
  >;
  export type ScreenshotInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    game?: boolean | GameDefaultArgs<ExtArgs>;
  };
  export type ScreenshotIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    game?: boolean | GameDefaultArgs<ExtArgs>;
  };
  export type ScreenshotIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    game?: boolean | GameDefaultArgs<ExtArgs>;
  };

  export type $ScreenshotPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Screenshot";
    objects: {
      game: Prisma.$GamePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        gameId: string;
        imageUrl: string;
        caption: string | null;
      },
      ExtArgs["result"]["screenshot"]
    >;
    composites: {};
  };

  type ScreenshotGetPayload<
    S extends boolean | null | undefined | ScreenshotDefaultArgs,
  > = $Result.GetResult<Prisma.$ScreenshotPayload, S>;

  type ScreenshotCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    ScreenshotFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ScreenshotCountAggregateInputType | true;
  };

  export interface ScreenshotDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Screenshot"];
      meta: { name: "Screenshot" };
    };
    /**
     * Find zero or one Screenshot that matches the filter.
     * @param {ScreenshotFindUniqueArgs} args - Arguments to find a Screenshot
     * @example
     * // Get one Screenshot
     * const screenshot = await prisma.screenshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScreenshotFindUniqueArgs>(
      args: SelectSubset<T, ScreenshotFindUniqueArgs<ExtArgs>>
    ): Prisma__ScreenshotClient<
      $Result.GetResult<
        Prisma.$ScreenshotPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Screenshot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScreenshotFindUniqueOrThrowArgs} args - Arguments to find a Screenshot
     * @example
     * // Get one Screenshot
     * const screenshot = await prisma.screenshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScreenshotFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ScreenshotFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ScreenshotClient<
      $Result.GetResult<
        Prisma.$ScreenshotPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Screenshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenshotFindFirstArgs} args - Arguments to find a Screenshot
     * @example
     * // Get one Screenshot
     * const screenshot = await prisma.screenshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScreenshotFindFirstArgs>(
      args?: SelectSubset<T, ScreenshotFindFirstArgs<ExtArgs>>
    ): Prisma__ScreenshotClient<
      $Result.GetResult<
        Prisma.$ScreenshotPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Screenshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenshotFindFirstOrThrowArgs} args - Arguments to find a Screenshot
     * @example
     * // Get one Screenshot
     * const screenshot = await prisma.screenshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScreenshotFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ScreenshotFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ScreenshotClient<
      $Result.GetResult<
        Prisma.$ScreenshotPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Screenshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Screenshots
     * const screenshots = await prisma.screenshot.findMany()
     *
     * // Get first 10 Screenshots
     * const screenshots = await prisma.screenshot.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const screenshotWithIdOnly = await prisma.screenshot.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ScreenshotFindManyArgs>(
      args?: SelectSubset<T, ScreenshotFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ScreenshotPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Screenshot.
     * @param {ScreenshotCreateArgs} args - Arguments to create a Screenshot.
     * @example
     * // Create one Screenshot
     * const Screenshot = await prisma.screenshot.create({
     *   data: {
     *     // ... data to create a Screenshot
     *   }
     * })
     *
     */
    create<T extends ScreenshotCreateArgs>(
      args: SelectSubset<T, ScreenshotCreateArgs<ExtArgs>>
    ): Prisma__ScreenshotClient<
      $Result.GetResult<
        Prisma.$ScreenshotPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Screenshots.
     * @param {ScreenshotCreateManyArgs} args - Arguments to create many Screenshots.
     * @example
     * // Create many Screenshots
     * const screenshot = await prisma.screenshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ScreenshotCreateManyArgs>(
      args?: SelectSubset<T, ScreenshotCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Screenshots and returns the data saved in the database.
     * @param {ScreenshotCreateManyAndReturnArgs} args - Arguments to create many Screenshots.
     * @example
     * // Create many Screenshots
     * const screenshot = await prisma.screenshot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Screenshots and only return the `id`
     * const screenshotWithIdOnly = await prisma.screenshot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ScreenshotCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ScreenshotCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ScreenshotPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Screenshot.
     * @param {ScreenshotDeleteArgs} args - Arguments to delete one Screenshot.
     * @example
     * // Delete one Screenshot
     * const Screenshot = await prisma.screenshot.delete({
     *   where: {
     *     // ... filter to delete one Screenshot
     *   }
     * })
     *
     */
    delete<T extends ScreenshotDeleteArgs>(
      args: SelectSubset<T, ScreenshotDeleteArgs<ExtArgs>>
    ): Prisma__ScreenshotClient<
      $Result.GetResult<
        Prisma.$ScreenshotPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Screenshot.
     * @param {ScreenshotUpdateArgs} args - Arguments to update one Screenshot.
     * @example
     * // Update one Screenshot
     * const screenshot = await prisma.screenshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ScreenshotUpdateArgs>(
      args: SelectSubset<T, ScreenshotUpdateArgs<ExtArgs>>
    ): Prisma__ScreenshotClient<
      $Result.GetResult<
        Prisma.$ScreenshotPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Screenshots.
     * @param {ScreenshotDeleteManyArgs} args - Arguments to filter Screenshots to delete.
     * @example
     * // Delete a few Screenshots
     * const { count } = await prisma.screenshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ScreenshotDeleteManyArgs>(
      args?: SelectSubset<T, ScreenshotDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Screenshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Screenshots
     * const screenshot = await prisma.screenshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ScreenshotUpdateManyArgs>(
      args: SelectSubset<T, ScreenshotUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Screenshots and returns the data updated in the database.
     * @param {ScreenshotUpdateManyAndReturnArgs} args - Arguments to update many Screenshots.
     * @example
     * // Update many Screenshots
     * const screenshot = await prisma.screenshot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Screenshots and only return the `id`
     * const screenshotWithIdOnly = await prisma.screenshot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ScreenshotUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ScreenshotUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ScreenshotPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Screenshot.
     * @param {ScreenshotUpsertArgs} args - Arguments to update or create a Screenshot.
     * @example
     * // Update or create a Screenshot
     * const screenshot = await prisma.screenshot.upsert({
     *   create: {
     *     // ... data to create a Screenshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Screenshot we want to update
     *   }
     * })
     */
    upsert<T extends ScreenshotUpsertArgs>(
      args: SelectSubset<T, ScreenshotUpsertArgs<ExtArgs>>
    ): Prisma__ScreenshotClient<
      $Result.GetResult<
        Prisma.$ScreenshotPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Screenshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenshotCountArgs} args - Arguments to filter Screenshots to count.
     * @example
     * // Count the number of Screenshots
     * const count = await prisma.screenshot.count({
     *   where: {
     *     // ... the filter for the Screenshots we want to count
     *   }
     * })
     **/
    count<T extends ScreenshotCountArgs>(
      args?: Subset<T, ScreenshotCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ScreenshotCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Screenshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ScreenshotAggregateArgs>(
      args: Subset<T, ScreenshotAggregateArgs>
    ): Prisma.PrismaPromise<GetScreenshotAggregateType<T>>;

    /**
     * Group by Screenshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ScreenshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScreenshotGroupByArgs["orderBy"] }
        : { orderBy?: ScreenshotGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ScreenshotGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetScreenshotGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Screenshot model
     */
    readonly fields: ScreenshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Screenshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScreenshotClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    game<T extends GameDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, GameDefaultArgs<ExtArgs>>
    ): Prisma__GameClient<
      | $Result.GetResult<
          Prisma.$GamePayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Screenshot model
   */
  interface ScreenshotFieldRefs {
    readonly id: FieldRef<"Screenshot", "String">;
    readonly gameId: FieldRef<"Screenshot", "String">;
    readonly imageUrl: FieldRef<"Screenshot", "String">;
    readonly caption: FieldRef<"Screenshot", "String">;
  }

  // Custom InputTypes
  /**
   * Screenshot findUnique
   */
  export type ScreenshotFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null;
    /**
     * Filter, which Screenshot to fetch.
     */
    where: ScreenshotWhereUniqueInput;
  };

  /**
   * Screenshot findUniqueOrThrow
   */
  export type ScreenshotFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null;
    /**
     * Filter, which Screenshot to fetch.
     */
    where: ScreenshotWhereUniqueInput;
  };

  /**
   * Screenshot findFirst
   */
  export type ScreenshotFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null;
    /**
     * Filter, which Screenshot to fetch.
     */
    where?: ScreenshotWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Screenshots to fetch.
     */
    orderBy?:
      | ScreenshotOrderByWithRelationInput
      | ScreenshotOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Screenshots.
     */
    cursor?: ScreenshotWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Screenshots from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Screenshots.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Screenshots.
     */
    distinct?: ScreenshotScalarFieldEnum | ScreenshotScalarFieldEnum[];
  };

  /**
   * Screenshot findFirstOrThrow
   */
  export type ScreenshotFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null;
    /**
     * Filter, which Screenshot to fetch.
     */
    where?: ScreenshotWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Screenshots to fetch.
     */
    orderBy?:
      | ScreenshotOrderByWithRelationInput
      | ScreenshotOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Screenshots.
     */
    cursor?: ScreenshotWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Screenshots from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Screenshots.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Screenshots.
     */
    distinct?: ScreenshotScalarFieldEnum | ScreenshotScalarFieldEnum[];
  };

  /**
   * Screenshot findMany
   */
  export type ScreenshotFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null;
    /**
     * Filter, which Screenshots to fetch.
     */
    where?: ScreenshotWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Screenshots to fetch.
     */
    orderBy?:
      | ScreenshotOrderByWithRelationInput
      | ScreenshotOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Screenshots.
     */
    cursor?: ScreenshotWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Screenshots from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Screenshots.
     */
    skip?: number;
    distinct?: ScreenshotScalarFieldEnum | ScreenshotScalarFieldEnum[];
  };

  /**
   * Screenshot create
   */
  export type ScreenshotCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null;
    /**
     * The data needed to create a Screenshot.
     */
    data: XOR<ScreenshotCreateInput, ScreenshotUncheckedCreateInput>;
  };

  /**
   * Screenshot createMany
   */
  export type ScreenshotCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Screenshots.
     */
    data: ScreenshotCreateManyInput | ScreenshotCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Screenshot createManyAndReturn
   */
  export type ScreenshotCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null;
    /**
     * The data used to create many Screenshots.
     */
    data: ScreenshotCreateManyInput | ScreenshotCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Screenshot update
   */
  export type ScreenshotUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null;
    /**
     * The data needed to update a Screenshot.
     */
    data: XOR<ScreenshotUpdateInput, ScreenshotUncheckedUpdateInput>;
    /**
     * Choose, which Screenshot to update.
     */
    where: ScreenshotWhereUniqueInput;
  };

  /**
   * Screenshot updateMany
   */
  export type ScreenshotUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Screenshots.
     */
    data: XOR<
      ScreenshotUpdateManyMutationInput,
      ScreenshotUncheckedUpdateManyInput
    >;
    /**
     * Filter which Screenshots to update
     */
    where?: ScreenshotWhereInput;
    /**
     * Limit how many Screenshots to update.
     */
    limit?: number;
  };

  /**
   * Screenshot updateManyAndReturn
   */
  export type ScreenshotUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null;
    /**
     * The data used to update Screenshots.
     */
    data: XOR<
      ScreenshotUpdateManyMutationInput,
      ScreenshotUncheckedUpdateManyInput
    >;
    /**
     * Filter which Screenshots to update
     */
    where?: ScreenshotWhereInput;
    /**
     * Limit how many Screenshots to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Screenshot upsert
   */
  export type ScreenshotUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null;
    /**
     * The filter to search for the Screenshot to update in case it exists.
     */
    where: ScreenshotWhereUniqueInput;
    /**
     * In case the Screenshot found by the `where` argument doesn't exist, create a new Screenshot with this data.
     */
    create: XOR<ScreenshotCreateInput, ScreenshotUncheckedCreateInput>;
    /**
     * In case the Screenshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScreenshotUpdateInput, ScreenshotUncheckedUpdateInput>;
  };

  /**
   * Screenshot delete
   */
  export type ScreenshotDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null;
    /**
     * Filter which Screenshot to delete.
     */
    where: ScreenshotWhereUniqueInput;
  };

  /**
   * Screenshot deleteMany
   */
  export type ScreenshotDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Screenshots to delete
     */
    where?: ScreenshotWhereInput;
    /**
     * Limit how many Screenshots to delete.
     */
    limit?: number;
  };

  /**
   * Screenshot without action
   */
  export type ScreenshotDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null;
  };

  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null;
    _avg: ReviewAvgAggregateOutputType | null;
    _sum: ReviewSumAggregateOutputType | null;
    _min: ReviewMinAggregateOutputType | null;
    _max: ReviewMaxAggregateOutputType | null;
  };

  export type ReviewAvgAggregateOutputType = {
    rating: number | null;
  };

  export type ReviewSumAggregateOutputType = {
    rating: number | null;
  };

  export type ReviewMinAggregateOutputType = {
    id: string | null;
    rating: number | null;
    comment: string | null;
    createdAt: Date | null;
    userId: string | null;
    gameId: string | null;
  };

  export type ReviewMaxAggregateOutputType = {
    id: string | null;
    rating: number | null;
    comment: string | null;
    createdAt: Date | null;
    userId: string | null;
    gameId: string | null;
  };

  export type ReviewCountAggregateOutputType = {
    id: number;
    rating: number;
    comment: number;
    createdAt: number;
    userId: number;
    gameId: number;
    _all: number;
  };

  export type ReviewAvgAggregateInputType = {
    rating?: true;
  };

  export type ReviewSumAggregateInputType = {
    rating?: true;
  };

  export type ReviewMinAggregateInputType = {
    id?: true;
    rating?: true;
    comment?: true;
    createdAt?: true;
    userId?: true;
    gameId?: true;
  };

  export type ReviewMaxAggregateInputType = {
    id?: true;
    rating?: true;
    comment?: true;
    createdAt?: true;
    userId?: true;
    gameId?: true;
  };

  export type ReviewCountAggregateInputType = {
    id?: true;
    rating?: true;
    comment?: true;
    createdAt?: true;
    userId?: true;
    gameId?: true;
    _all?: true;
  };

  export type ReviewAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reviews.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Reviews
     **/
    _count?: true | ReviewCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ReviewAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ReviewSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ReviewMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ReviewMaxAggregateInputType;
  };

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
    [P in keyof T & keyof AggregateReview]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>;
  };

  export type ReviewGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ReviewWhereInput;
    orderBy?:
      | ReviewOrderByWithAggregationInput
      | ReviewOrderByWithAggregationInput[];
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum;
    having?: ReviewScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ReviewCountAggregateInputType | true;
    _avg?: ReviewAvgAggregateInputType;
    _sum?: ReviewSumAggregateInputType;
    _min?: ReviewMinAggregateInputType;
    _max?: ReviewMaxAggregateInputType;
  };

  export type ReviewGroupByOutputType = {
    id: string;
    rating: number;
    comment: string | null;
    createdAt: Date;
    userId: string;
    gameId: string;
    _count: ReviewCountAggregateOutputType | null;
    _avg: ReviewAvgAggregateOutputType | null;
    _sum: ReviewSumAggregateOutputType | null;
    _min: ReviewMinAggregateOutputType | null;
    _max: ReviewMaxAggregateOutputType | null;
  };

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ReviewGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof ReviewGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>;
        }
      >
    >;

  export type ReviewSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      rating?: boolean;
      comment?: boolean;
      createdAt?: boolean;
      userId?: boolean;
      gameId?: boolean;
      game?: boolean | GameDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["review"]
  >;

  export type ReviewSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      rating?: boolean;
      comment?: boolean;
      createdAt?: boolean;
      userId?: boolean;
      gameId?: boolean;
      game?: boolean | GameDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["review"]
  >;

  export type ReviewSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      rating?: boolean;
      comment?: boolean;
      createdAt?: boolean;
      userId?: boolean;
      gameId?: boolean;
      game?: boolean | GameDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["review"]
  >;

  export type ReviewSelectScalar = {
    id?: boolean;
    rating?: boolean;
    comment?: boolean;
    createdAt?: boolean;
    userId?: boolean;
    gameId?: boolean;
  };

  export type ReviewOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "rating" | "comment" | "createdAt" | "userId" | "gameId",
    ExtArgs["result"]["review"]
  >;
  export type ReviewInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    game?: boolean | GameDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type ReviewIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    game?: boolean | GameDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type ReviewIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    game?: boolean | GameDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $ReviewPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Review";
    objects: {
      game: Prisma.$GamePayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        rating: number;
        comment: string | null;
        createdAt: Date;
        userId: string;
        gameId: string;
      },
      ExtArgs["result"]["review"]
    >;
    composites: {};
  };

  type ReviewGetPayload<
    S extends boolean | null | undefined | ReviewDefaultArgs,
  > = $Result.GetResult<Prisma.$ReviewPayload, S>;

  type ReviewCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ReviewFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: ReviewCountAggregateInputType | true;
  };

  export interface ReviewDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Review"];
      meta: { name: "Review" };
    };
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(
      args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(
      args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     *
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ReviewFindManyArgs>(
      args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     *
     */
    create<T extends ReviewCreateArgs>(
      args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ReviewCreateManyArgs>(
      args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     *
     */
    delete<T extends ReviewDeleteArgs>(
      args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ReviewUpdateArgs>(
      args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ReviewDeleteManyArgs>(
      args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ReviewUpdateManyArgs>(
      args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(
      args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
     **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ReviewCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ReviewAggregateArgs>(
      args: Subset<T, ReviewAggregateArgs>
    ): Prisma.PrismaPromise<GetReviewAggregateType<T>>;

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs["orderBy"] }
        : { orderBy?: ReviewGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetReviewGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Review model
     */
    readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    game<T extends GameDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, GameDefaultArgs<ExtArgs>>
    ): Prisma__GameClient<
      | $Result.GetResult<
          Prisma.$GamePayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", "String">;
    readonly rating: FieldRef<"Review", "Float">;
    readonly comment: FieldRef<"Review", "String">;
    readonly createdAt: FieldRef<"Review", "DateTime">;
    readonly userId: FieldRef<"Review", "String">;
    readonly gameId: FieldRef<"Review", "String">;
  }

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput;
  };

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput;
  };

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reviews.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
  };

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reviews.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
  };

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reviews.
     */
    skip?: number;
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
  };

  /**
   * Review create
   */
  export type ReviewCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>;
  };

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Review update
   */
  export type ReviewUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>;
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput;
  };

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>;
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput;
    /**
     * Limit how many Reviews to update.
     */
    limit?: number;
  };

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>;
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput;
    /**
     * Limit how many Reviews to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput;
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>;
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>;
  };

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput;
  };

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput;
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number;
  };

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
  };

  /**
   * Model Cart
   */

  export type AggregateCart = {
    _count: CartCountAggregateOutputType | null;
    _min: CartMinAggregateOutputType | null;
    _max: CartMaxAggregateOutputType | null;
  };

  export type CartMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type CartMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type CartCountAggregateOutputType = {
    id: number;
    userId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type CartMinAggregateInputType = {
    id?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type CartMaxAggregateInputType = {
    id?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type CartCountAggregateInputType = {
    id?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type CartAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Cart to aggregate.
     */
    where?: CartWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CartWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Carts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Carts
     **/
    _count?: true | CartCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CartMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CartMaxAggregateInputType;
  };

  export type GetCartAggregateType<T extends CartAggregateArgs> = {
    [P in keyof T & keyof AggregateCart]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCart[P]>
      : GetScalarType<T[P], AggregateCart[P]>;
  };

  export type CartGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CartWhereInput;
    orderBy?:
      | CartOrderByWithAggregationInput
      | CartOrderByWithAggregationInput[];
    by: CartScalarFieldEnum[] | CartScalarFieldEnum;
    having?: CartScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CartCountAggregateInputType | true;
    _min?: CartMinAggregateInputType;
    _max?: CartMaxAggregateInputType;
  };

  export type CartGroupByOutputType = {
    id: string;
    userId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: CartCountAggregateOutputType | null;
    _min: CartMinAggregateOutputType | null;
    _max: CartMaxAggregateOutputType | null;
  };

  type GetCartGroupByPayload<T extends CartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof CartGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], CartGroupByOutputType[P]>
          : GetScalarType<T[P], CartGroupByOutputType[P]>;
      }
    >
  >;

  export type CartSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      items?: boolean | Cart$itemsArgs<ExtArgs>;
      _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["cart"]
  >;

  export type CartSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["cart"]
  >;

  export type CartSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["cart"]
  >;

  export type CartSelectScalar = {
    id?: boolean;
    userId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type CartOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "userId" | "createdAt" | "updatedAt",
    ExtArgs["result"]["cart"]
  >;
  export type CartInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    items?: boolean | Cart$itemsArgs<ExtArgs>;
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type CartIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type CartIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $CartPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Cart";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
      items: Prisma.$CartItemPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["cart"]
    >;
    composites: {};
  };

  type CartGetPayload<S extends boolean | null | undefined | CartDefaultArgs> =
    $Result.GetResult<Prisma.$CartPayload, S>;

  type CartCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<CartFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: CartCountAggregateInputType | true;
  };

  export interface CartDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Cart"];
      meta: { name: "Cart" };
    };
    /**
     * Find zero or one Cart that matches the filter.
     * @param {CartFindUniqueArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartFindUniqueArgs>(
      args: SelectSubset<T, CartFindUniqueArgs<ExtArgs>>
    ): Prisma__CartClient<
      $Result.GetResult<
        Prisma.$CartPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Cart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartFindUniqueOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CartFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CartClient<
      $Result.GetResult<
        Prisma.$CartPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Cart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartFindFirstArgs>(
      args?: SelectSubset<T, CartFindFirstArgs<ExtArgs>>
    ): Prisma__CartClient<
      $Result.GetResult<
        Prisma.$CartPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Cart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CartFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CartClient<
      $Result.GetResult<
        Prisma.$CartPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Carts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carts
     * const carts = await prisma.cart.findMany()
     *
     * // Get first 10 Carts
     * const carts = await prisma.cart.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const cartWithIdOnly = await prisma.cart.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CartFindManyArgs>(
      args?: SelectSubset<T, CartFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CartPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Cart.
     * @param {CartCreateArgs} args - Arguments to create a Cart.
     * @example
     * // Create one Cart
     * const Cart = await prisma.cart.create({
     *   data: {
     *     // ... data to create a Cart
     *   }
     * })
     *
     */
    create<T extends CartCreateArgs>(
      args: SelectSubset<T, CartCreateArgs<ExtArgs>>
    ): Prisma__CartClient<
      $Result.GetResult<
        Prisma.$CartPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Carts.
     * @param {CartCreateManyArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CartCreateManyArgs>(
      args?: SelectSubset<T, CartCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Carts and returns the data saved in the database.
     * @param {CartCreateManyAndReturnArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Carts and only return the `id`
     * const cartWithIdOnly = await prisma.cart.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CartCreateManyAndReturnArgs>(
      args?: SelectSubset<T, CartCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CartPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Cart.
     * @param {CartDeleteArgs} args - Arguments to delete one Cart.
     * @example
     * // Delete one Cart
     * const Cart = await prisma.cart.delete({
     *   where: {
     *     // ... filter to delete one Cart
     *   }
     * })
     *
     */
    delete<T extends CartDeleteArgs>(
      args: SelectSubset<T, CartDeleteArgs<ExtArgs>>
    ): Prisma__CartClient<
      $Result.GetResult<
        Prisma.$CartPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Cart.
     * @param {CartUpdateArgs} args - Arguments to update one Cart.
     * @example
     * // Update one Cart
     * const cart = await prisma.cart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CartUpdateArgs>(
      args: SelectSubset<T, CartUpdateArgs<ExtArgs>>
    ): Prisma__CartClient<
      $Result.GetResult<
        Prisma.$CartPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Carts.
     * @param {CartDeleteManyArgs} args - Arguments to filter Carts to delete.
     * @example
     * // Delete a few Carts
     * const { count } = await prisma.cart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CartDeleteManyArgs>(
      args?: SelectSubset<T, CartDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CartUpdateManyArgs>(
      args: SelectSubset<T, CartUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Carts and returns the data updated in the database.
     * @param {CartUpdateManyAndReturnArgs} args - Arguments to update many Carts.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Carts and only return the `id`
     * const cartWithIdOnly = await prisma.cart.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CartUpdateManyAndReturnArgs>(
      args: SelectSubset<T, CartUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CartPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Cart.
     * @param {CartUpsertArgs} args - Arguments to update or create a Cart.
     * @example
     * // Update or create a Cart
     * const cart = await prisma.cart.upsert({
     *   create: {
     *     // ... data to create a Cart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cart we want to update
     *   }
     * })
     */
    upsert<T extends CartUpsertArgs>(
      args: SelectSubset<T, CartUpsertArgs<ExtArgs>>
    ): Prisma__CartClient<
      $Result.GetResult<
        Prisma.$CartPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartCountArgs} args - Arguments to filter Carts to count.
     * @example
     * // Count the number of Carts
     * const count = await prisma.cart.count({
     *   where: {
     *     // ... the filter for the Carts we want to count
     *   }
     * })
     **/
    count<T extends CartCountArgs>(
      args?: Subset<T, CartCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], CartCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CartAggregateArgs>(
      args: Subset<T, CartAggregateArgs>
    ): Prisma.PrismaPromise<GetCartAggregateType<T>>;

    /**
     * Group by Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartGroupByArgs["orderBy"] }
        : { orderBy?: CartGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CartGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetCartGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Cart model
     */
    readonly fields: CartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    items<T extends Cart$itemsArgs<ExtArgs> = {}>(
      args?: Subset<T, Cart$itemsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CartItemPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Cart model
   */
  interface CartFieldRefs {
    readonly id: FieldRef<"Cart", "String">;
    readonly userId: FieldRef<"Cart", "String">;
    readonly createdAt: FieldRef<"Cart", "DateTime">;
    readonly updatedAt: FieldRef<"Cart", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Cart findUnique
   */
  export type CartFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null;
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput;
  };

  /**
   * Cart findUniqueOrThrow
   */
  export type CartFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null;
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput;
  };

  /**
   * Cart findFirst
   */
  export type CartFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null;
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Carts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[];
  };

  /**
   * Cart findFirstOrThrow
   */
  export type CartFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null;
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Carts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[];
  };

  /**
   * Cart findMany
   */
  export type CartFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null;
    /**
     * Filter, which Carts to fetch.
     */
    where?: CartWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Carts.
     */
    cursor?: CartWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Carts.
     */
    skip?: number;
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[];
  };

  /**
   * Cart create
   */
  export type CartCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null;
    /**
     * The data needed to create a Cart.
     */
    data: XOR<CartCreateInput, CartUncheckedCreateInput>;
  };

  /**
   * Cart createMany
   */
  export type CartCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Cart createManyAndReturn
   */
  export type CartCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Cart update
   */
  export type CartUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null;
    /**
     * The data needed to update a Cart.
     */
    data: XOR<CartUpdateInput, CartUncheckedUpdateInput>;
    /**
     * Choose, which Cart to update.
     */
    where: CartWhereUniqueInput;
  };

  /**
   * Cart updateMany
   */
  export type CartUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>;
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput;
    /**
     * Limit how many Carts to update.
     */
    limit?: number;
  };

  /**
   * Cart updateManyAndReturn
   */
  export type CartUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>;
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput;
    /**
     * Limit how many Carts to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Cart upsert
   */
  export type CartUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null;
    /**
     * The filter to search for the Cart to update in case it exists.
     */
    where: CartWhereUniqueInput;
    /**
     * In case the Cart found by the `where` argument doesn't exist, create a new Cart with this data.
     */
    create: XOR<CartCreateInput, CartUncheckedCreateInput>;
    /**
     * In case the Cart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartUpdateInput, CartUncheckedUpdateInput>;
  };

  /**
   * Cart delete
   */
  export type CartDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null;
    /**
     * Filter which Cart to delete.
     */
    where: CartWhereUniqueInput;
  };

  /**
   * Cart deleteMany
   */
  export type CartDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Carts to delete
     */
    where?: CartWhereInput;
    /**
     * Limit how many Carts to delete.
     */
    limit?: number;
  };

  /**
   * Cart.items
   */
  export type Cart$itemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null;
    where?: CartItemWhereInput;
    orderBy?:
      | CartItemOrderByWithRelationInput
      | CartItemOrderByWithRelationInput[];
    cursor?: CartItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[];
  };

  /**
   * Cart without action
   */
  export type CartDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null;
  };

  /**
   * Model CartItem
   */

  export type AggregateCartItem = {
    _count: CartItemCountAggregateOutputType | null;
    _avg: CartItemAvgAggregateOutputType | null;
    _sum: CartItemSumAggregateOutputType | null;
    _min: CartItemMinAggregateOutputType | null;
    _max: CartItemMaxAggregateOutputType | null;
  };

  export type CartItemAvgAggregateOutputType = {
    quantity: number | null;
  };

  export type CartItemSumAggregateOutputType = {
    quantity: number | null;
  };

  export type CartItemMinAggregateOutputType = {
    id: string | null;
    cartId: string | null;
    gameId: string | null;
    quantity: number | null;
    addedAt: Date | null;
  };

  export type CartItemMaxAggregateOutputType = {
    id: string | null;
    cartId: string | null;
    gameId: string | null;
    quantity: number | null;
    addedAt: Date | null;
  };

  export type CartItemCountAggregateOutputType = {
    id: number;
    cartId: number;
    gameId: number;
    quantity: number;
    addedAt: number;
    _all: number;
  };

  export type CartItemAvgAggregateInputType = {
    quantity?: true;
  };

  export type CartItemSumAggregateInputType = {
    quantity?: true;
  };

  export type CartItemMinAggregateInputType = {
    id?: true;
    cartId?: true;
    gameId?: true;
    quantity?: true;
    addedAt?: true;
  };

  export type CartItemMaxAggregateInputType = {
    id?: true;
    cartId?: true;
    gameId?: true;
    quantity?: true;
    addedAt?: true;
  };

  export type CartItemCountAggregateInputType = {
    id?: true;
    cartId?: true;
    gameId?: true;
    quantity?: true;
    addedAt?: true;
    _all?: true;
  };

  export type CartItemAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which CartItem to aggregate.
     */
    where?: CartItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CartItems to fetch.
     */
    orderBy?:
      | CartItemOrderByWithRelationInput
      | CartItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CartItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CartItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned CartItems
     **/
    _count?: true | CartItemCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CartItemAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CartItemSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CartItemMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CartItemMaxAggregateInputType;
  };

  export type GetCartItemAggregateType<T extends CartItemAggregateArgs> = {
    [P in keyof T & keyof AggregateCartItem]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCartItem[P]>
      : GetScalarType<T[P], AggregateCartItem[P]>;
  };

  export type CartItemGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CartItemWhereInput;
    orderBy?:
      | CartItemOrderByWithAggregationInput
      | CartItemOrderByWithAggregationInput[];
    by: CartItemScalarFieldEnum[] | CartItemScalarFieldEnum;
    having?: CartItemScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CartItemCountAggregateInputType | true;
    _avg?: CartItemAvgAggregateInputType;
    _sum?: CartItemSumAggregateInputType;
    _min?: CartItemMinAggregateInputType;
    _max?: CartItemMaxAggregateInputType;
  };

  export type CartItemGroupByOutputType = {
    id: string;
    cartId: string;
    gameId: string;
    quantity: number;
    addedAt: Date;
    _count: CartItemCountAggregateOutputType | null;
    _avg: CartItemAvgAggregateOutputType | null;
    _sum: CartItemSumAggregateOutputType | null;
    _min: CartItemMinAggregateOutputType | null;
    _max: CartItemMaxAggregateOutputType | null;
  };

  type GetCartItemGroupByPayload<T extends CartItemGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<CartItemGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof CartItemGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartItemGroupByOutputType[P]>
            : GetScalarType<T[P], CartItemGroupByOutputType[P]>;
        }
      >
    >;

  export type CartItemSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      cartId?: boolean;
      gameId?: boolean;
      quantity?: boolean;
      addedAt?: boolean;
      cart?: boolean | CartDefaultArgs<ExtArgs>;
      game?: boolean | GameDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["cartItem"]
  >;

  export type CartItemSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      cartId?: boolean;
      gameId?: boolean;
      quantity?: boolean;
      addedAt?: boolean;
      cart?: boolean | CartDefaultArgs<ExtArgs>;
      game?: boolean | GameDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["cartItem"]
  >;

  export type CartItemSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      cartId?: boolean;
      gameId?: boolean;
      quantity?: boolean;
      addedAt?: boolean;
      cart?: boolean | CartDefaultArgs<ExtArgs>;
      game?: boolean | GameDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["cartItem"]
  >;

  export type CartItemSelectScalar = {
    id?: boolean;
    cartId?: boolean;
    gameId?: boolean;
    quantity?: boolean;
    addedAt?: boolean;
  };

  export type CartItemOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "cartId" | "gameId" | "quantity" | "addedAt",
    ExtArgs["result"]["cartItem"]
  >;
  export type CartItemInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    cart?: boolean | CartDefaultArgs<ExtArgs>;
    game?: boolean | GameDefaultArgs<ExtArgs>;
  };
  export type CartItemIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    cart?: boolean | CartDefaultArgs<ExtArgs>;
    game?: boolean | GameDefaultArgs<ExtArgs>;
  };
  export type CartItemIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    cart?: boolean | CartDefaultArgs<ExtArgs>;
    game?: boolean | GameDefaultArgs<ExtArgs>;
  };

  export type $CartItemPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "CartItem";
    objects: {
      cart: Prisma.$CartPayload<ExtArgs>;
      game: Prisma.$GamePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        cartId: string;
        gameId: string;
        quantity: number;
        addedAt: Date;
      },
      ExtArgs["result"]["cartItem"]
    >;
    composites: {};
  };

  type CartItemGetPayload<
    S extends boolean | null | undefined | CartItemDefaultArgs,
  > = $Result.GetResult<Prisma.$CartItemPayload, S>;

  type CartItemCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<CartItemFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: CartItemCountAggregateInputType | true;
  };

  export interface CartItemDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["CartItem"];
      meta: { name: "CartItem" };
    };
    /**
     * Find zero or one CartItem that matches the filter.
     * @param {CartItemFindUniqueArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartItemFindUniqueArgs>(
      args: SelectSubset<T, CartItemFindUniqueArgs<ExtArgs>>
    ): Prisma__CartItemClient<
      $Result.GetResult<
        Prisma.$CartItemPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one CartItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartItemFindUniqueOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartItemFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CartItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CartItemClient<
      $Result.GetResult<
        Prisma.$CartItemPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first CartItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartItemFindFirstArgs>(
      args?: SelectSubset<T, CartItemFindFirstArgs<ExtArgs>>
    ): Prisma__CartItemClient<
      $Result.GetResult<
        Prisma.$CartItemPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first CartItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CartItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CartItemClient<
      $Result.GetResult<
        Prisma.$CartItemPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more CartItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CartItems
     * const cartItems = await prisma.cartItem.findMany()
     *
     * // Get first 10 CartItems
     * const cartItems = await prisma.cartItem.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CartItemFindManyArgs>(
      args?: SelectSubset<T, CartItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CartItemPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a CartItem.
     * @param {CartItemCreateArgs} args - Arguments to create a CartItem.
     * @example
     * // Create one CartItem
     * const CartItem = await prisma.cartItem.create({
     *   data: {
     *     // ... data to create a CartItem
     *   }
     * })
     *
     */
    create<T extends CartItemCreateArgs>(
      args: SelectSubset<T, CartItemCreateArgs<ExtArgs>>
    ): Prisma__CartItemClient<
      $Result.GetResult<
        Prisma.$CartItemPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many CartItems.
     * @param {CartItemCreateManyArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItem = await prisma.cartItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CartItemCreateManyArgs>(
      args?: SelectSubset<T, CartItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many CartItems and returns the data saved in the database.
     * @param {CartItemCreateManyAndReturnArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItem = await prisma.cartItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many CartItems and only return the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CartItemCreateManyAndReturnArgs>(
      args?: SelectSubset<T, CartItemCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CartItemPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a CartItem.
     * @param {CartItemDeleteArgs} args - Arguments to delete one CartItem.
     * @example
     * // Delete one CartItem
     * const CartItem = await prisma.cartItem.delete({
     *   where: {
     *     // ... filter to delete one CartItem
     *   }
     * })
     *
     */
    delete<T extends CartItemDeleteArgs>(
      args: SelectSubset<T, CartItemDeleteArgs<ExtArgs>>
    ): Prisma__CartItemClient<
      $Result.GetResult<
        Prisma.$CartItemPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one CartItem.
     * @param {CartItemUpdateArgs} args - Arguments to update one CartItem.
     * @example
     * // Update one CartItem
     * const cartItem = await prisma.cartItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CartItemUpdateArgs>(
      args: SelectSubset<T, CartItemUpdateArgs<ExtArgs>>
    ): Prisma__CartItemClient<
      $Result.GetResult<
        Prisma.$CartItemPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more CartItems.
     * @param {CartItemDeleteManyArgs} args - Arguments to filter CartItems to delete.
     * @example
     * // Delete a few CartItems
     * const { count } = await prisma.cartItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CartItemDeleteManyArgs>(
      args?: SelectSubset<T, CartItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CartItems
     * const cartItem = await prisma.cartItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CartItemUpdateManyArgs>(
      args: SelectSubset<T, CartItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more CartItems and returns the data updated in the database.
     * @param {CartItemUpdateManyAndReturnArgs} args - Arguments to update many CartItems.
     * @example
     * // Update many CartItems
     * const cartItem = await prisma.cartItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more CartItems and only return the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CartItemUpdateManyAndReturnArgs>(
      args: SelectSubset<T, CartItemUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CartItemPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one CartItem.
     * @param {CartItemUpsertArgs} args - Arguments to update or create a CartItem.
     * @example
     * // Update or create a CartItem
     * const cartItem = await prisma.cartItem.upsert({
     *   create: {
     *     // ... data to create a CartItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CartItem we want to update
     *   }
     * })
     */
    upsert<T extends CartItemUpsertArgs>(
      args: SelectSubset<T, CartItemUpsertArgs<ExtArgs>>
    ): Prisma__CartItemClient<
      $Result.GetResult<
        Prisma.$CartItemPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemCountArgs} args - Arguments to filter CartItems to count.
     * @example
     * // Count the number of CartItems
     * const count = await prisma.cartItem.count({
     *   where: {
     *     // ... the filter for the CartItems we want to count
     *   }
     * })
     **/
    count<T extends CartItemCountArgs>(
      args?: Subset<T, CartItemCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], CartItemCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CartItemAggregateArgs>(
      args: Subset<T, CartItemAggregateArgs>
    ): Prisma.PrismaPromise<GetCartItemAggregateType<T>>;

    /**
     * Group by CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CartItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartItemGroupByArgs["orderBy"] }
        : { orderBy?: CartItemGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CartItemGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetCartItemGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the CartItem model
     */
    readonly fields: CartItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CartItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartItemClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    cart<T extends CartDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CartDefaultArgs<ExtArgs>>
    ): Prisma__CartClient<
      | $Result.GetResult<
          Prisma.$CartPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    game<T extends GameDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, GameDefaultArgs<ExtArgs>>
    ): Prisma__GameClient<
      | $Result.GetResult<
          Prisma.$GamePayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the CartItem model
   */
  interface CartItemFieldRefs {
    readonly id: FieldRef<"CartItem", "String">;
    readonly cartId: FieldRef<"CartItem", "String">;
    readonly gameId: FieldRef<"CartItem", "String">;
    readonly quantity: FieldRef<"CartItem", "Int">;
    readonly addedAt: FieldRef<"CartItem", "DateTime">;
  }

  // Custom InputTypes
  /**
   * CartItem findUnique
   */
  export type CartItemFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null;
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput;
  };

  /**
   * CartItem findUniqueOrThrow
   */
  export type CartItemFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null;
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput;
  };

  /**
   * CartItem findFirst
   */
  export type CartItemFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null;
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CartItems to fetch.
     */
    orderBy?:
      | CartItemOrderByWithRelationInput
      | CartItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CartItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[];
  };

  /**
   * CartItem findFirstOrThrow
   */
  export type CartItemFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null;
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CartItems to fetch.
     */
    orderBy?:
      | CartItemOrderByWithRelationInput
      | CartItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CartItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[];
  };

  /**
   * CartItem findMany
   */
  export type CartItemFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null;
    /**
     * Filter, which CartItems to fetch.
     */
    where?: CartItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CartItems to fetch.
     */
    orderBy?:
      | CartItemOrderByWithRelationInput
      | CartItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing CartItems.
     */
    cursor?: CartItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CartItems.
     */
    skip?: number;
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[];
  };

  /**
   * CartItem create
   */
  export type CartItemCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null;
    /**
     * The data needed to create a CartItem.
     */
    data: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>;
  };

  /**
   * CartItem createMany
   */
  export type CartItemCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many CartItems.
     */
    data: CartItemCreateManyInput | CartItemCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * CartItem createManyAndReturn
   */
  export type CartItemCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null;
    /**
     * The data used to create many CartItems.
     */
    data: CartItemCreateManyInput | CartItemCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * CartItem update
   */
  export type CartItemUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null;
    /**
     * The data needed to update a CartItem.
     */
    data: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>;
    /**
     * Choose, which CartItem to update.
     */
    where: CartItemWhereUniqueInput;
  };

  /**
   * CartItem updateMany
   */
  export type CartItemUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update CartItems.
     */
    data: XOR<
      CartItemUpdateManyMutationInput,
      CartItemUncheckedUpdateManyInput
    >;
    /**
     * Filter which CartItems to update
     */
    where?: CartItemWhereInput;
    /**
     * Limit how many CartItems to update.
     */
    limit?: number;
  };

  /**
   * CartItem updateManyAndReturn
   */
  export type CartItemUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null;
    /**
     * The data used to update CartItems.
     */
    data: XOR<
      CartItemUpdateManyMutationInput,
      CartItemUncheckedUpdateManyInput
    >;
    /**
     * Filter which CartItems to update
     */
    where?: CartItemWhereInput;
    /**
     * Limit how many CartItems to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * CartItem upsert
   */
  export type CartItemUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null;
    /**
     * The filter to search for the CartItem to update in case it exists.
     */
    where: CartItemWhereUniqueInput;
    /**
     * In case the CartItem found by the `where` argument doesn't exist, create a new CartItem with this data.
     */
    create: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>;
    /**
     * In case the CartItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>;
  };

  /**
   * CartItem delete
   */
  export type CartItemDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null;
    /**
     * Filter which CartItem to delete.
     */
    where: CartItemWhereUniqueInput;
  };

  /**
   * CartItem deleteMany
   */
  export type CartItemDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which CartItems to delete
     */
    where?: CartItemWhereInput;
    /**
     * Limit how many CartItems to delete.
     */
    limit?: number;
  };

  /**
   * CartItem without action
   */
  export type CartItemDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null;
  };

  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null;
    _avg: OrderAvgAggregateOutputType | null;
    _sum: OrderSumAggregateOutputType | null;
    _min: OrderMinAggregateOutputType | null;
    _max: OrderMaxAggregateOutputType | null;
  };

  export type OrderAvgAggregateOutputType = {
    totalAmount: number | null;
  };

  export type OrderSumAggregateOutputType = {
    totalAmount: number | null;
  };

  export type OrderMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    totalAmount: number | null;
    status: string | null;
    createdAt: Date | null;
  };

  export type OrderMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    totalAmount: number | null;
    status: string | null;
    createdAt: Date | null;
  };

  export type OrderCountAggregateOutputType = {
    id: number;
    userId: number;
    totalAmount: number;
    status: number;
    createdAt: number;
    _all: number;
  };

  export type OrderAvgAggregateInputType = {
    totalAmount?: true;
  };

  export type OrderSumAggregateInputType = {
    totalAmount?: true;
  };

  export type OrderMinAggregateInputType = {
    id?: true;
    userId?: true;
    totalAmount?: true;
    status?: true;
    createdAt?: true;
  };

  export type OrderMaxAggregateInputType = {
    id?: true;
    userId?: true;
    totalAmount?: true;
    status?: true;
    createdAt?: true;
  };

  export type OrderCountAggregateInputType = {
    id?: true;
    userId?: true;
    totalAmount?: true;
    status?: true;
    createdAt?: true;
    _all?: true;
  };

  export type OrderAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Orders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Orders
     **/
    _count?: true | OrderCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: OrderAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: OrderSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: OrderMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: OrderMaxAggregateInputType;
  };

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
    [P in keyof T & keyof AggregateOrder]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>;
  };

  export type OrderGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrderWhereInput;
    orderBy?:
      | OrderOrderByWithAggregationInput
      | OrderOrderByWithAggregationInput[];
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum;
    having?: OrderScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: OrderCountAggregateInputType | true;
    _avg?: OrderAvgAggregateInputType;
    _sum?: OrderSumAggregateInputType;
    _min?: OrderMinAggregateInputType;
    _max?: OrderMaxAggregateInputType;
  };

  export type OrderGroupByOutputType = {
    id: string;
    userId: string;
    totalAmount: number;
    status: string;
    createdAt: Date;
    _count: OrderCountAggregateOutputType | null;
    _avg: OrderAvgAggregateOutputType | null;
    _sum: OrderSumAggregateOutputType | null;
    _min: OrderMinAggregateOutputType | null;
    _max: OrderMaxAggregateOutputType | null;
  };

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<OrderGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof OrderGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>;
        }
      >
    >;

  export type OrderSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      totalAmount?: boolean;
      status?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      items?: boolean | Order$itemsArgs<ExtArgs>;
      _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["order"]
  >;

  export type OrderSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      totalAmount?: boolean;
      status?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["order"]
  >;

  export type OrderSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      totalAmount?: boolean;
      status?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["order"]
  >;

  export type OrderSelectScalar = {
    id?: boolean;
    userId?: boolean;
    totalAmount?: boolean;
    status?: boolean;
    createdAt?: boolean;
  };

  export type OrderOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "userId" | "totalAmount" | "status" | "createdAt",
    ExtArgs["result"]["order"]
  >;
  export type OrderInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    items?: boolean | Order$itemsArgs<ExtArgs>;
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type OrderIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type OrderIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $OrderPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Order";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
      items: Prisma.$OrderItemPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        totalAmount: number;
        status: string;
        createdAt: Date;
      },
      ExtArgs["result"]["order"]
    >;
    composites: {};
  };

  type OrderGetPayload<
    S extends boolean | null | undefined | OrderDefaultArgs,
  > = $Result.GetResult<Prisma.$OrderPayload, S>;

  type OrderCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<OrderFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: OrderCountAggregateInputType | true;
  };

  export interface OrderDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Order"];
      meta: { name: "Order" };
    };
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(
      args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<
        Prisma.$OrderPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(
      args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<
        Prisma.$OrderPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(
      args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<
        Prisma.$OrderPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<
        Prisma.$OrderPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     *
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     *
     */
    findMany<T extends OrderFindManyArgs>(
      args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrderPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     *
     */
    create<T extends OrderCreateArgs>(
      args: SelectSubset<T, OrderCreateArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<
        Prisma.$OrderPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends OrderCreateManyArgs>(
      args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(
      args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrderPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     *
     */
    delete<T extends OrderDeleteArgs>(
      args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<
        Prisma.$OrderPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends OrderUpdateArgs>(
      args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<
        Prisma.$OrderPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends OrderDeleteManyArgs>(
      args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends OrderUpdateManyArgs>(
      args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(
      args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrderPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(
      args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<
        Prisma.$OrderPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
     **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], OrderCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends OrderAggregateArgs>(
      args: Subset<T, OrderAggregateArgs>
    ): Prisma.PrismaPromise<GetOrderAggregateType<T>>;

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs["orderBy"] }
        : { orderBy?: OrderGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetOrderGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Order model
     */
    readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    items<T extends Order$itemsArgs<ExtArgs> = {}>(
      args?: Subset<T, Order$itemsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$OrderItemPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", "String">;
    readonly userId: FieldRef<"Order", "String">;
    readonly totalAmount: FieldRef<"Order", "Float">;
    readonly status: FieldRef<"Order", "String">;
    readonly createdAt: FieldRef<"Order", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput;
  };

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput;
  };

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Orders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[];
  };

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Orders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[];
  };

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Orders.
     */
    skip?: number;
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[];
  };

  /**
   * Order create
   */
  export type OrderCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>;
  };

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Order update
   */
  export type OrderUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>;
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput;
  };

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>;
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput;
    /**
     * Limit how many Orders to update.
     */
    limit?: number;
  };

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>;
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput;
    /**
     * Limit how many Orders to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput;
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>;
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>;
  };

  /**
   * Order delete
   */
  export type OrderDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput;
  };

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput;
    /**
     * Limit how many Orders to delete.
     */
    limit?: number;
  };

  /**
   * Order.items
   */
  export type Order$itemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    where?: OrderItemWhereInput;
    orderBy?:
      | OrderItemOrderByWithRelationInput
      | OrderItemOrderByWithRelationInput[];
    cursor?: OrderItemWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[];
  };

  /**
   * Order without action
   */
  export type OrderDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
  };

  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null;
    _avg: OrderItemAvgAggregateOutputType | null;
    _sum: OrderItemSumAggregateOutputType | null;
    _min: OrderItemMinAggregateOutputType | null;
    _max: OrderItemMaxAggregateOutputType | null;
  };

  export type OrderItemAvgAggregateOutputType = {
    price: number | null;
    quantity: number | null;
  };

  export type OrderItemSumAggregateOutputType = {
    price: number | null;
    quantity: number | null;
  };

  export type OrderItemMinAggregateOutputType = {
    id: string | null;
    orderId: string | null;
    gameId: string | null;
    price: number | null;
    quantity: number | null;
  };

  export type OrderItemMaxAggregateOutputType = {
    id: string | null;
    orderId: string | null;
    gameId: string | null;
    price: number | null;
    quantity: number | null;
  };

  export type OrderItemCountAggregateOutputType = {
    id: number;
    orderId: number;
    gameId: number;
    price: number;
    quantity: number;
    _all: number;
  };

  export type OrderItemAvgAggregateInputType = {
    price?: true;
    quantity?: true;
  };

  export type OrderItemSumAggregateInputType = {
    price?: true;
    quantity?: true;
  };

  export type OrderItemMinAggregateInputType = {
    id?: true;
    orderId?: true;
    gameId?: true;
    price?: true;
    quantity?: true;
  };

  export type OrderItemMaxAggregateInputType = {
    id?: true;
    orderId?: true;
    gameId?: true;
    price?: true;
    quantity?: true;
  };

  export type OrderItemCountAggregateInputType = {
    id?: true;
    orderId?: true;
    gameId?: true;
    price?: true;
    quantity?: true;
    _all?: true;
  };

  export type OrderItemAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrderItems to fetch.
     */
    orderBy?:
      | OrderItemOrderByWithRelationInput
      | OrderItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrderItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned OrderItems
     **/
    _count?: true | OrderItemCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: OrderItemAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: OrderItemSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: OrderItemMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: OrderItemMaxAggregateInputType;
  };

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
    [P in keyof T & keyof AggregateOrderItem]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>;
  };

  export type OrderItemGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrderItemWhereInput;
    orderBy?:
      | OrderItemOrderByWithAggregationInput
      | OrderItemOrderByWithAggregationInput[];
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum;
    having?: OrderItemScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: OrderItemCountAggregateInputType | true;
    _avg?: OrderItemAvgAggregateInputType;
    _sum?: OrderItemSumAggregateInputType;
    _min?: OrderItemMinAggregateInputType;
    _max?: OrderItemMaxAggregateInputType;
  };

  export type OrderItemGroupByOutputType = {
    id: string;
    orderId: string;
    gameId: string;
    price: number;
    quantity: number;
    _count: OrderItemCountAggregateOutputType | null;
    _avg: OrderItemAvgAggregateOutputType | null;
    _sum: OrderItemSumAggregateOutputType | null;
    _min: OrderItemMinAggregateOutputType | null;
    _max: OrderItemMaxAggregateOutputType | null;
  };

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<OrderItemGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof OrderItemGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>;
        }
      >
    >;

  export type OrderItemSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      orderId?: boolean;
      gameId?: boolean;
      price?: boolean;
      quantity?: boolean;
      game?: boolean | GameDefaultArgs<ExtArgs>;
      order?: boolean | OrderDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["orderItem"]
  >;

  export type OrderItemSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      orderId?: boolean;
      gameId?: boolean;
      price?: boolean;
      quantity?: boolean;
      game?: boolean | GameDefaultArgs<ExtArgs>;
      order?: boolean | OrderDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["orderItem"]
  >;

  export type OrderItemSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      orderId?: boolean;
      gameId?: boolean;
      price?: boolean;
      quantity?: boolean;
      game?: boolean | GameDefaultArgs<ExtArgs>;
      order?: boolean | OrderDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["orderItem"]
  >;

  export type OrderItemSelectScalar = {
    id?: boolean;
    orderId?: boolean;
    gameId?: boolean;
    price?: boolean;
    quantity?: boolean;
  };

  export type OrderItemOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "orderId" | "gameId" | "price" | "quantity",
    ExtArgs["result"]["orderItem"]
  >;
  export type OrderItemInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    game?: boolean | GameDefaultArgs<ExtArgs>;
    order?: boolean | OrderDefaultArgs<ExtArgs>;
  };
  export type OrderItemIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    game?: boolean | GameDefaultArgs<ExtArgs>;
    order?: boolean | OrderDefaultArgs<ExtArgs>;
  };
  export type OrderItemIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    game?: boolean | GameDefaultArgs<ExtArgs>;
    order?: boolean | OrderDefaultArgs<ExtArgs>;
  };

  export type $OrderItemPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "OrderItem";
    objects: {
      game: Prisma.$GamePayload<ExtArgs>;
      order: Prisma.$OrderPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        orderId: string;
        gameId: string;
        price: number;
        quantity: number;
      },
      ExtArgs["result"]["orderItem"]
    >;
    composites: {};
  };

  type OrderItemGetPayload<
    S extends boolean | null | undefined | OrderItemDefaultArgs,
  > = $Result.GetResult<Prisma.$OrderItemPayload, S>;

  type OrderItemCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    OrderItemFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: OrderItemCountAggregateInputType | true;
  };

  export interface OrderItemDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["OrderItem"];
      meta: { name: "OrderItem" };
    };
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(
      args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>
    ): Prisma__OrderItemClient<
      $Result.GetResult<
        Prisma.$OrderItemPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(
      args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrderItemClient<
      $Result.GetResult<
        Prisma.$OrderItemPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(
      args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>
    ): Prisma__OrderItemClient<
      $Result.GetResult<
        Prisma.$OrderItemPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrderItemClient<
      $Result.GetResult<
        Prisma.$OrderItemPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     *
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     *
     */
    findMany<T extends OrderItemFindManyArgs>(
      args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrderItemPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     *
     */
    create<T extends OrderItemCreateArgs>(
      args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>
    ): Prisma__OrderItemClient<
      $Result.GetResult<
        Prisma.$OrderItemPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends OrderItemCreateManyArgs>(
      args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(
      args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrderItemPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     *
     */
    delete<T extends OrderItemDeleteArgs>(
      args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>
    ): Prisma__OrderItemClient<
      $Result.GetResult<
        Prisma.$OrderItemPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends OrderItemUpdateArgs>(
      args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>
    ): Prisma__OrderItemClient<
      $Result.GetResult<
        Prisma.$OrderItemPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(
      args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends OrderItemUpdateManyArgs>(
      args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(
      args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrderItemPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(
      args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>
    ): Prisma__OrderItemClient<
      $Result.GetResult<
        Prisma.$OrderItemPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
     **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], OrderItemCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends OrderItemAggregateArgs>(
      args: Subset<T, OrderItemAggregateArgs>
    ): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>;

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs["orderBy"] }
        : { orderBy?: OrderItemGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetOrderItemGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the OrderItem model
     */
    readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    game<T extends GameDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, GameDefaultArgs<ExtArgs>>
    ): Prisma__GameClient<
      | $Result.GetResult<
          Prisma.$GamePayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrderDefaultArgs<ExtArgs>>
    ): Prisma__OrderClient<
      | $Result.GetResult<
          Prisma.$OrderPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", "String">;
    readonly orderId: FieldRef<"OrderItem", "String">;
    readonly gameId: FieldRef<"OrderItem", "String">;
    readonly price: FieldRef<"OrderItem", "Float">;
    readonly quantity: FieldRef<"OrderItem", "Int">;
  }

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput;
  };

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput;
  };

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrderItems to fetch.
     */
    orderBy?:
      | OrderItemOrderByWithRelationInput
      | OrderItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrderItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[];
  };

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrderItems to fetch.
     */
    orderBy?:
      | OrderItemOrderByWithRelationInput
      | OrderItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrderItems.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[];
  };

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrderItems to fetch.
     */
    orderBy?:
      | OrderItemOrderByWithRelationInput
      | OrderItemOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrderItems.
     */
    skip?: number;
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[];
  };

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>;
  };

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>;
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput;
  };

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<
      OrderItemUpdateManyMutationInput,
      OrderItemUncheckedUpdateManyInput
    >;
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput;
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number;
  };

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * The data used to update OrderItems.
     */
    data: XOR<
      OrderItemUpdateManyMutationInput,
      OrderItemUncheckedUpdateManyInput
    >;
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput;
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput;
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>;
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>;
  };

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput;
  };

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput;
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number;
  };

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null;
  };

  /**
   * Model FeaturedGame
   */

  export type AggregateFeaturedGame = {
    _count: FeaturedGameCountAggregateOutputType | null;
    _avg: FeaturedGameAvgAggregateOutputType | null;
    _sum: FeaturedGameSumAggregateOutputType | null;
    _min: FeaturedGameMinAggregateOutputType | null;
    _max: FeaturedGameMaxAggregateOutputType | null;
  };

  export type FeaturedGameAvgAggregateOutputType = {
    priority: number | null;
  };

  export type FeaturedGameSumAggregateOutputType = {
    priority: number | null;
  };

  export type FeaturedGameMinAggregateOutputType = {
    id: string | null;
    gameId: string | null;
    startDate: Date | null;
    endDate: Date | null;
    priority: number | null;
    createdAt: Date | null;
  };

  export type FeaturedGameMaxAggregateOutputType = {
    id: string | null;
    gameId: string | null;
    startDate: Date | null;
    endDate: Date | null;
    priority: number | null;
    createdAt: Date | null;
  };

  export type FeaturedGameCountAggregateOutputType = {
    id: number;
    gameId: number;
    startDate: number;
    endDate: number;
    priority: number;
    createdAt: number;
    _all: number;
  };

  export type FeaturedGameAvgAggregateInputType = {
    priority?: true;
  };

  export type FeaturedGameSumAggregateInputType = {
    priority?: true;
  };

  export type FeaturedGameMinAggregateInputType = {
    id?: true;
    gameId?: true;
    startDate?: true;
    endDate?: true;
    priority?: true;
    createdAt?: true;
  };

  export type FeaturedGameMaxAggregateInputType = {
    id?: true;
    gameId?: true;
    startDate?: true;
    endDate?: true;
    priority?: true;
    createdAt?: true;
  };

  export type FeaturedGameCountAggregateInputType = {
    id?: true;
    gameId?: true;
    startDate?: true;
    endDate?: true;
    priority?: true;
    createdAt?: true;
    _all?: true;
  };

  export type FeaturedGameAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FeaturedGame to aggregate.
     */
    where?: FeaturedGameWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FeaturedGames to fetch.
     */
    orderBy?:
      | FeaturedGameOrderByWithRelationInput
      | FeaturedGameOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FeaturedGameWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FeaturedGames from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FeaturedGames.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FeaturedGames
     **/
    _count?: true | FeaturedGameCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FeaturedGameAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FeaturedGameSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FeaturedGameMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FeaturedGameMaxAggregateInputType;
  };

  export type GetFeaturedGameAggregateType<
    T extends FeaturedGameAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateFeaturedGame]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeaturedGame[P]>
      : GetScalarType<T[P], AggregateFeaturedGame[P]>;
  };

  export type FeaturedGameGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FeaturedGameWhereInput;
    orderBy?:
      | FeaturedGameOrderByWithAggregationInput
      | FeaturedGameOrderByWithAggregationInput[];
    by: FeaturedGameScalarFieldEnum[] | FeaturedGameScalarFieldEnum;
    having?: FeaturedGameScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FeaturedGameCountAggregateInputType | true;
    _avg?: FeaturedGameAvgAggregateInputType;
    _sum?: FeaturedGameSumAggregateInputType;
    _min?: FeaturedGameMinAggregateInputType;
    _max?: FeaturedGameMaxAggregateInputType;
  };

  export type FeaturedGameGroupByOutputType = {
    id: string;
    gameId: string;
    startDate: Date;
    endDate: Date;
    priority: number;
    createdAt: Date;
    _count: FeaturedGameCountAggregateOutputType | null;
    _avg: FeaturedGameAvgAggregateOutputType | null;
    _sum: FeaturedGameSumAggregateOutputType | null;
    _min: FeaturedGameMinAggregateOutputType | null;
    _max: FeaturedGameMaxAggregateOutputType | null;
  };

  type GetFeaturedGameGroupByPayload<T extends FeaturedGameGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FeaturedGameGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof FeaturedGameGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeaturedGameGroupByOutputType[P]>
            : GetScalarType<T[P], FeaturedGameGroupByOutputType[P]>;
        }
      >
    >;

  export type FeaturedGameSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      gameId?: boolean;
      startDate?: boolean;
      endDate?: boolean;
      priority?: boolean;
      createdAt?: boolean;
      game?: boolean | GameDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["featuredGame"]
  >;

  export type FeaturedGameSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      gameId?: boolean;
      startDate?: boolean;
      endDate?: boolean;
      priority?: boolean;
      createdAt?: boolean;
      game?: boolean | GameDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["featuredGame"]
  >;

  export type FeaturedGameSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      gameId?: boolean;
      startDate?: boolean;
      endDate?: boolean;
      priority?: boolean;
      createdAt?: boolean;
      game?: boolean | GameDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["featuredGame"]
  >;

  export type FeaturedGameSelectScalar = {
    id?: boolean;
    gameId?: boolean;
    startDate?: boolean;
    endDate?: boolean;
    priority?: boolean;
    createdAt?: boolean;
  };

  export type FeaturedGameOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "gameId" | "startDate" | "endDate" | "priority" | "createdAt",
    ExtArgs["result"]["featuredGame"]
  >;
  export type FeaturedGameInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    game?: boolean | GameDefaultArgs<ExtArgs>;
  };
  export type FeaturedGameIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    game?: boolean | GameDefaultArgs<ExtArgs>;
  };
  export type FeaturedGameIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    game?: boolean | GameDefaultArgs<ExtArgs>;
  };

  export type $FeaturedGamePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "FeaturedGame";
    objects: {
      game: Prisma.$GamePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        gameId: string;
        startDate: Date;
        endDate: Date;
        priority: number;
        createdAt: Date;
      },
      ExtArgs["result"]["featuredGame"]
    >;
    composites: {};
  };

  type FeaturedGameGetPayload<
    S extends boolean | null | undefined | FeaturedGameDefaultArgs,
  > = $Result.GetResult<Prisma.$FeaturedGamePayload, S>;

  type FeaturedGameCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    FeaturedGameFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: FeaturedGameCountAggregateInputType | true;
  };

  export interface FeaturedGameDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["FeaturedGame"];
      meta: { name: "FeaturedGame" };
    };
    /**
     * Find zero or one FeaturedGame that matches the filter.
     * @param {FeaturedGameFindUniqueArgs} args - Arguments to find a FeaturedGame
     * @example
     * // Get one FeaturedGame
     * const featuredGame = await prisma.featuredGame.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeaturedGameFindUniqueArgs>(
      args: SelectSubset<T, FeaturedGameFindUniqueArgs<ExtArgs>>
    ): Prisma__FeaturedGameClient<
      $Result.GetResult<
        Prisma.$FeaturedGamePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one FeaturedGame that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeaturedGameFindUniqueOrThrowArgs} args - Arguments to find a FeaturedGame
     * @example
     * // Get one FeaturedGame
     * const featuredGame = await prisma.featuredGame.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeaturedGameFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FeaturedGameFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FeaturedGameClient<
      $Result.GetResult<
        Prisma.$FeaturedGamePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FeaturedGame that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedGameFindFirstArgs} args - Arguments to find a FeaturedGame
     * @example
     * // Get one FeaturedGame
     * const featuredGame = await prisma.featuredGame.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeaturedGameFindFirstArgs>(
      args?: SelectSubset<T, FeaturedGameFindFirstArgs<ExtArgs>>
    ): Prisma__FeaturedGameClient<
      $Result.GetResult<
        Prisma.$FeaturedGamePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FeaturedGame that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedGameFindFirstOrThrowArgs} args - Arguments to find a FeaturedGame
     * @example
     * // Get one FeaturedGame
     * const featuredGame = await prisma.featuredGame.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeaturedGameFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FeaturedGameFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FeaturedGameClient<
      $Result.GetResult<
        Prisma.$FeaturedGamePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more FeaturedGames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedGameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeaturedGames
     * const featuredGames = await prisma.featuredGame.findMany()
     *
     * // Get first 10 FeaturedGames
     * const featuredGames = await prisma.featuredGame.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const featuredGameWithIdOnly = await prisma.featuredGame.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FeaturedGameFindManyArgs>(
      args?: SelectSubset<T, FeaturedGameFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FeaturedGamePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a FeaturedGame.
     * @param {FeaturedGameCreateArgs} args - Arguments to create a FeaturedGame.
     * @example
     * // Create one FeaturedGame
     * const FeaturedGame = await prisma.featuredGame.create({
     *   data: {
     *     // ... data to create a FeaturedGame
     *   }
     * })
     *
     */
    create<T extends FeaturedGameCreateArgs>(
      args: SelectSubset<T, FeaturedGameCreateArgs<ExtArgs>>
    ): Prisma__FeaturedGameClient<
      $Result.GetResult<
        Prisma.$FeaturedGamePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many FeaturedGames.
     * @param {FeaturedGameCreateManyArgs} args - Arguments to create many FeaturedGames.
     * @example
     * // Create many FeaturedGames
     * const featuredGame = await prisma.featuredGame.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FeaturedGameCreateManyArgs>(
      args?: SelectSubset<T, FeaturedGameCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many FeaturedGames and returns the data saved in the database.
     * @param {FeaturedGameCreateManyAndReturnArgs} args - Arguments to create many FeaturedGames.
     * @example
     * // Create many FeaturedGames
     * const featuredGame = await prisma.featuredGame.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many FeaturedGames and only return the `id`
     * const featuredGameWithIdOnly = await prisma.featuredGame.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FeaturedGameCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FeaturedGameCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FeaturedGamePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a FeaturedGame.
     * @param {FeaturedGameDeleteArgs} args - Arguments to delete one FeaturedGame.
     * @example
     * // Delete one FeaturedGame
     * const FeaturedGame = await prisma.featuredGame.delete({
     *   where: {
     *     // ... filter to delete one FeaturedGame
     *   }
     * })
     *
     */
    delete<T extends FeaturedGameDeleteArgs>(
      args: SelectSubset<T, FeaturedGameDeleteArgs<ExtArgs>>
    ): Prisma__FeaturedGameClient<
      $Result.GetResult<
        Prisma.$FeaturedGamePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one FeaturedGame.
     * @param {FeaturedGameUpdateArgs} args - Arguments to update one FeaturedGame.
     * @example
     * // Update one FeaturedGame
     * const featuredGame = await prisma.featuredGame.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FeaturedGameUpdateArgs>(
      args: SelectSubset<T, FeaturedGameUpdateArgs<ExtArgs>>
    ): Prisma__FeaturedGameClient<
      $Result.GetResult<
        Prisma.$FeaturedGamePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more FeaturedGames.
     * @param {FeaturedGameDeleteManyArgs} args - Arguments to filter FeaturedGames to delete.
     * @example
     * // Delete a few FeaturedGames
     * const { count } = await prisma.featuredGame.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FeaturedGameDeleteManyArgs>(
      args?: SelectSubset<T, FeaturedGameDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FeaturedGames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedGameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeaturedGames
     * const featuredGame = await prisma.featuredGame.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FeaturedGameUpdateManyArgs>(
      args: SelectSubset<T, FeaturedGameUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FeaturedGames and returns the data updated in the database.
     * @param {FeaturedGameUpdateManyAndReturnArgs} args - Arguments to update many FeaturedGames.
     * @example
     * // Update many FeaturedGames
     * const featuredGame = await prisma.featuredGame.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more FeaturedGames and only return the `id`
     * const featuredGameWithIdOnly = await prisma.featuredGame.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends FeaturedGameUpdateManyAndReturnArgs>(
      args: SelectSubset<T, FeaturedGameUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FeaturedGamePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one FeaturedGame.
     * @param {FeaturedGameUpsertArgs} args - Arguments to update or create a FeaturedGame.
     * @example
     * // Update or create a FeaturedGame
     * const featuredGame = await prisma.featuredGame.upsert({
     *   create: {
     *     // ... data to create a FeaturedGame
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeaturedGame we want to update
     *   }
     * })
     */
    upsert<T extends FeaturedGameUpsertArgs>(
      args: SelectSubset<T, FeaturedGameUpsertArgs<ExtArgs>>
    ): Prisma__FeaturedGameClient<
      $Result.GetResult<
        Prisma.$FeaturedGamePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of FeaturedGames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedGameCountArgs} args - Arguments to filter FeaturedGames to count.
     * @example
     * // Count the number of FeaturedGames
     * const count = await prisma.featuredGame.count({
     *   where: {
     *     // ... the filter for the FeaturedGames we want to count
     *   }
     * })
     **/
    count<T extends FeaturedGameCountArgs>(
      args?: Subset<T, FeaturedGameCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], FeaturedGameCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a FeaturedGame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedGameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FeaturedGameAggregateArgs>(
      args: Subset<T, FeaturedGameAggregateArgs>
    ): Prisma.PrismaPromise<GetFeaturedGameAggregateType<T>>;

    /**
     * Group by FeaturedGame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedGameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FeaturedGameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeaturedGameGroupByArgs["orderBy"] }
        : { orderBy?: FeaturedGameGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FeaturedGameGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetFeaturedGameGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the FeaturedGame model
     */
    readonly fields: FeaturedGameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeaturedGame.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeaturedGameClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    game<T extends GameDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, GameDefaultArgs<ExtArgs>>
    ): Prisma__GameClient<
      | $Result.GetResult<
          Prisma.$GamePayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the FeaturedGame model
   */
  interface FeaturedGameFieldRefs {
    readonly id: FieldRef<"FeaturedGame", "String">;
    readonly gameId: FieldRef<"FeaturedGame", "String">;
    readonly startDate: FieldRef<"FeaturedGame", "DateTime">;
    readonly endDate: FieldRef<"FeaturedGame", "DateTime">;
    readonly priority: FieldRef<"FeaturedGame", "Int">;
    readonly createdAt: FieldRef<"FeaturedGame", "DateTime">;
  }

  // Custom InputTypes
  /**
   * FeaturedGame findUnique
   */
  export type FeaturedGameFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeaturedGame
     */
    select?: FeaturedGameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FeaturedGame
     */
    omit?: FeaturedGameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedGameInclude<ExtArgs> | null;
    /**
     * Filter, which FeaturedGame to fetch.
     */
    where: FeaturedGameWhereUniqueInput;
  };

  /**
   * FeaturedGame findUniqueOrThrow
   */
  export type FeaturedGameFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeaturedGame
     */
    select?: FeaturedGameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FeaturedGame
     */
    omit?: FeaturedGameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedGameInclude<ExtArgs> | null;
    /**
     * Filter, which FeaturedGame to fetch.
     */
    where: FeaturedGameWhereUniqueInput;
  };

  /**
   * FeaturedGame findFirst
   */
  export type FeaturedGameFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeaturedGame
     */
    select?: FeaturedGameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FeaturedGame
     */
    omit?: FeaturedGameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedGameInclude<ExtArgs> | null;
    /**
     * Filter, which FeaturedGame to fetch.
     */
    where?: FeaturedGameWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FeaturedGames to fetch.
     */
    orderBy?:
      | FeaturedGameOrderByWithRelationInput
      | FeaturedGameOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FeaturedGames.
     */
    cursor?: FeaturedGameWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FeaturedGames from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FeaturedGames.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FeaturedGames.
     */
    distinct?: FeaturedGameScalarFieldEnum | FeaturedGameScalarFieldEnum[];
  };

  /**
   * FeaturedGame findFirstOrThrow
   */
  export type FeaturedGameFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeaturedGame
     */
    select?: FeaturedGameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FeaturedGame
     */
    omit?: FeaturedGameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedGameInclude<ExtArgs> | null;
    /**
     * Filter, which FeaturedGame to fetch.
     */
    where?: FeaturedGameWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FeaturedGames to fetch.
     */
    orderBy?:
      | FeaturedGameOrderByWithRelationInput
      | FeaturedGameOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FeaturedGames.
     */
    cursor?: FeaturedGameWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FeaturedGames from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FeaturedGames.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FeaturedGames.
     */
    distinct?: FeaturedGameScalarFieldEnum | FeaturedGameScalarFieldEnum[];
  };

  /**
   * FeaturedGame findMany
   */
  export type FeaturedGameFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeaturedGame
     */
    select?: FeaturedGameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FeaturedGame
     */
    omit?: FeaturedGameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedGameInclude<ExtArgs> | null;
    /**
     * Filter, which FeaturedGames to fetch.
     */
    where?: FeaturedGameWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FeaturedGames to fetch.
     */
    orderBy?:
      | FeaturedGameOrderByWithRelationInput
      | FeaturedGameOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FeaturedGames.
     */
    cursor?: FeaturedGameWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FeaturedGames from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FeaturedGames.
     */
    skip?: number;
    distinct?: FeaturedGameScalarFieldEnum | FeaturedGameScalarFieldEnum[];
  };

  /**
   * FeaturedGame create
   */
  export type FeaturedGameCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeaturedGame
     */
    select?: FeaturedGameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FeaturedGame
     */
    omit?: FeaturedGameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedGameInclude<ExtArgs> | null;
    /**
     * The data needed to create a FeaturedGame.
     */
    data: XOR<FeaturedGameCreateInput, FeaturedGameUncheckedCreateInput>;
  };

  /**
   * FeaturedGame createMany
   */
  export type FeaturedGameCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many FeaturedGames.
     */
    data: FeaturedGameCreateManyInput | FeaturedGameCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * FeaturedGame createManyAndReturn
   */
  export type FeaturedGameCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeaturedGame
     */
    select?: FeaturedGameSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the FeaturedGame
     */
    omit?: FeaturedGameOmit<ExtArgs> | null;
    /**
     * The data used to create many FeaturedGames.
     */
    data: FeaturedGameCreateManyInput | FeaturedGameCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedGameIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * FeaturedGame update
   */
  export type FeaturedGameUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeaturedGame
     */
    select?: FeaturedGameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FeaturedGame
     */
    omit?: FeaturedGameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedGameInclude<ExtArgs> | null;
    /**
     * The data needed to update a FeaturedGame.
     */
    data: XOR<FeaturedGameUpdateInput, FeaturedGameUncheckedUpdateInput>;
    /**
     * Choose, which FeaturedGame to update.
     */
    where: FeaturedGameWhereUniqueInput;
  };

  /**
   * FeaturedGame updateMany
   */
  export type FeaturedGameUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update FeaturedGames.
     */
    data: XOR<
      FeaturedGameUpdateManyMutationInput,
      FeaturedGameUncheckedUpdateManyInput
    >;
    /**
     * Filter which FeaturedGames to update
     */
    where?: FeaturedGameWhereInput;
    /**
     * Limit how many FeaturedGames to update.
     */
    limit?: number;
  };

  /**
   * FeaturedGame updateManyAndReturn
   */
  export type FeaturedGameUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeaturedGame
     */
    select?: FeaturedGameSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the FeaturedGame
     */
    omit?: FeaturedGameOmit<ExtArgs> | null;
    /**
     * The data used to update FeaturedGames.
     */
    data: XOR<
      FeaturedGameUpdateManyMutationInput,
      FeaturedGameUncheckedUpdateManyInput
    >;
    /**
     * Filter which FeaturedGames to update
     */
    where?: FeaturedGameWhereInput;
    /**
     * Limit how many FeaturedGames to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedGameIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * FeaturedGame upsert
   */
  export type FeaturedGameUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeaturedGame
     */
    select?: FeaturedGameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FeaturedGame
     */
    omit?: FeaturedGameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedGameInclude<ExtArgs> | null;
    /**
     * The filter to search for the FeaturedGame to update in case it exists.
     */
    where: FeaturedGameWhereUniqueInput;
    /**
     * In case the FeaturedGame found by the `where` argument doesn't exist, create a new FeaturedGame with this data.
     */
    create: XOR<FeaturedGameCreateInput, FeaturedGameUncheckedCreateInput>;
    /**
     * In case the FeaturedGame was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeaturedGameUpdateInput, FeaturedGameUncheckedUpdateInput>;
  };

  /**
   * FeaturedGame delete
   */
  export type FeaturedGameDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeaturedGame
     */
    select?: FeaturedGameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FeaturedGame
     */
    omit?: FeaturedGameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedGameInclude<ExtArgs> | null;
    /**
     * Filter which FeaturedGame to delete.
     */
    where: FeaturedGameWhereUniqueInput;
  };

  /**
   * FeaturedGame deleteMany
   */
  export type FeaturedGameDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FeaturedGames to delete
     */
    where?: FeaturedGameWhereInput;
    /**
     * Limit how many FeaturedGames to delete.
     */
    limit?: number;
  };

  /**
   * FeaturedGame without action
   */
  export type FeaturedGameDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FeaturedGame
     */
    select?: FeaturedGameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FeaturedGame
     */
    omit?: FeaturedGameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedGameInclude<ExtArgs> | null;
  };

  /**
   * Model RecommendedGame
   */

  export type AggregateRecommendedGame = {
    _count: RecommendedGameCountAggregateOutputType | null;
    _avg: RecommendedGameAvgAggregateOutputType | null;
    _sum: RecommendedGameSumAggregateOutputType | null;
    _min: RecommendedGameMinAggregateOutputType | null;
    _max: RecommendedGameMaxAggregateOutputType | null;
  };

  export type RecommendedGameAvgAggregateOutputType = {
    priority: number | null;
  };

  export type RecommendedGameSumAggregateOutputType = {
    priority: number | null;
  };

  export type RecommendedGameMinAggregateOutputType = {
    id: string | null;
    gameId: string | null;
    recommendationType: $Enums.RecommendationType | null;
    relatedGameId: string | null;
    startDate: Date | null;
    endDate: Date | null;
    priority: number | null;
    createdAt: Date | null;
  };

  export type RecommendedGameMaxAggregateOutputType = {
    id: string | null;
    gameId: string | null;
    recommendationType: $Enums.RecommendationType | null;
    relatedGameId: string | null;
    startDate: Date | null;
    endDate: Date | null;
    priority: number | null;
    createdAt: Date | null;
  };

  export type RecommendedGameCountAggregateOutputType = {
    id: number;
    gameId: number;
    recommendationType: number;
    relatedGameId: number;
    startDate: number;
    endDate: number;
    priority: number;
    createdAt: number;
    _all: number;
  };

  export type RecommendedGameAvgAggregateInputType = {
    priority?: true;
  };

  export type RecommendedGameSumAggregateInputType = {
    priority?: true;
  };

  export type RecommendedGameMinAggregateInputType = {
    id?: true;
    gameId?: true;
    recommendationType?: true;
    relatedGameId?: true;
    startDate?: true;
    endDate?: true;
    priority?: true;
    createdAt?: true;
  };

  export type RecommendedGameMaxAggregateInputType = {
    id?: true;
    gameId?: true;
    recommendationType?: true;
    relatedGameId?: true;
    startDate?: true;
    endDate?: true;
    priority?: true;
    createdAt?: true;
  };

  export type RecommendedGameCountAggregateInputType = {
    id?: true;
    gameId?: true;
    recommendationType?: true;
    relatedGameId?: true;
    startDate?: true;
    endDate?: true;
    priority?: true;
    createdAt?: true;
    _all?: true;
  };

  export type RecommendedGameAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which RecommendedGame to aggregate.
     */
    where?: RecommendedGameWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RecommendedGames to fetch.
     */
    orderBy?:
      | RecommendedGameOrderByWithRelationInput
      | RecommendedGameOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: RecommendedGameWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RecommendedGames from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RecommendedGames.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned RecommendedGames
     **/
    _count?: true | RecommendedGameCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: RecommendedGameAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: RecommendedGameSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RecommendedGameMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RecommendedGameMaxAggregateInputType;
  };

  export type GetRecommendedGameAggregateType<
    T extends RecommendedGameAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateRecommendedGame]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecommendedGame[P]>
      : GetScalarType<T[P], AggregateRecommendedGame[P]>;
  };

  export type RecommendedGameGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RecommendedGameWhereInput;
    orderBy?:
      | RecommendedGameOrderByWithAggregationInput
      | RecommendedGameOrderByWithAggregationInput[];
    by: RecommendedGameScalarFieldEnum[] | RecommendedGameScalarFieldEnum;
    having?: RecommendedGameScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RecommendedGameCountAggregateInputType | true;
    _avg?: RecommendedGameAvgAggregateInputType;
    _sum?: RecommendedGameSumAggregateInputType;
    _min?: RecommendedGameMinAggregateInputType;
    _max?: RecommendedGameMaxAggregateInputType;
  };

  export type RecommendedGameGroupByOutputType = {
    id: string;
    gameId: string;
    recommendationType: $Enums.RecommendationType;
    relatedGameId: string | null;
    startDate: Date;
    endDate: Date | null;
    priority: number;
    createdAt: Date;
    _count: RecommendedGameCountAggregateOutputType | null;
    _avg: RecommendedGameAvgAggregateOutputType | null;
    _sum: RecommendedGameSumAggregateOutputType | null;
    _min: RecommendedGameMinAggregateOutputType | null;
    _max: RecommendedGameMaxAggregateOutputType | null;
  };

  type GetRecommendedGameGroupByPayload<T extends RecommendedGameGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<RecommendedGameGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof RecommendedGameGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecommendedGameGroupByOutputType[P]>
            : GetScalarType<T[P], RecommendedGameGroupByOutputType[P]>;
        }
      >
    >;

  export type RecommendedGameSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      gameId?: boolean;
      recommendationType?: boolean;
      relatedGameId?: boolean;
      startDate?: boolean;
      endDate?: boolean;
      priority?: boolean;
      createdAt?: boolean;
      game?: boolean | GameDefaultArgs<ExtArgs>;
      relatedGame?: boolean | RecommendedGame$relatedGameArgs<ExtArgs>;
    },
    ExtArgs["result"]["recommendedGame"]
  >;

  export type RecommendedGameSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      gameId?: boolean;
      recommendationType?: boolean;
      relatedGameId?: boolean;
      startDate?: boolean;
      endDate?: boolean;
      priority?: boolean;
      createdAt?: boolean;
      game?: boolean | GameDefaultArgs<ExtArgs>;
      relatedGame?: boolean | RecommendedGame$relatedGameArgs<ExtArgs>;
    },
    ExtArgs["result"]["recommendedGame"]
  >;

  export type RecommendedGameSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      gameId?: boolean;
      recommendationType?: boolean;
      relatedGameId?: boolean;
      startDate?: boolean;
      endDate?: boolean;
      priority?: boolean;
      createdAt?: boolean;
      game?: boolean | GameDefaultArgs<ExtArgs>;
      relatedGame?: boolean | RecommendedGame$relatedGameArgs<ExtArgs>;
    },
    ExtArgs["result"]["recommendedGame"]
  >;

  export type RecommendedGameSelectScalar = {
    id?: boolean;
    gameId?: boolean;
    recommendationType?: boolean;
    relatedGameId?: boolean;
    startDate?: boolean;
    endDate?: boolean;
    priority?: boolean;
    createdAt?: boolean;
  };

  export type RecommendedGameOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "gameId"
    | "recommendationType"
    | "relatedGameId"
    | "startDate"
    | "endDate"
    | "priority"
    | "createdAt",
    ExtArgs["result"]["recommendedGame"]
  >;
  export type RecommendedGameInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    game?: boolean | GameDefaultArgs<ExtArgs>;
    relatedGame?: boolean | RecommendedGame$relatedGameArgs<ExtArgs>;
  };
  export type RecommendedGameIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    game?: boolean | GameDefaultArgs<ExtArgs>;
    relatedGame?: boolean | RecommendedGame$relatedGameArgs<ExtArgs>;
  };
  export type RecommendedGameIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    game?: boolean | GameDefaultArgs<ExtArgs>;
    relatedGame?: boolean | RecommendedGame$relatedGameArgs<ExtArgs>;
  };

  export type $RecommendedGamePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "RecommendedGame";
    objects: {
      game: Prisma.$GamePayload<ExtArgs>;
      relatedGame: Prisma.$GamePayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        gameId: string;
        recommendationType: $Enums.RecommendationType;
        relatedGameId: string | null;
        startDate: Date;
        endDate: Date | null;
        priority: number;
        createdAt: Date;
      },
      ExtArgs["result"]["recommendedGame"]
    >;
    composites: {};
  };

  type RecommendedGameGetPayload<
    S extends boolean | null | undefined | RecommendedGameDefaultArgs,
  > = $Result.GetResult<Prisma.$RecommendedGamePayload, S>;

  type RecommendedGameCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    RecommendedGameFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: RecommendedGameCountAggregateInputType | true;
  };

  export interface RecommendedGameDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["RecommendedGame"];
      meta: { name: "RecommendedGame" };
    };
    /**
     * Find zero or one RecommendedGame that matches the filter.
     * @param {RecommendedGameFindUniqueArgs} args - Arguments to find a RecommendedGame
     * @example
     * // Get one RecommendedGame
     * const recommendedGame = await prisma.recommendedGame.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecommendedGameFindUniqueArgs>(
      args: SelectSubset<T, RecommendedGameFindUniqueArgs<ExtArgs>>
    ): Prisma__RecommendedGameClient<
      $Result.GetResult<
        Prisma.$RecommendedGamePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one RecommendedGame that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecommendedGameFindUniqueOrThrowArgs} args - Arguments to find a RecommendedGame
     * @example
     * // Get one RecommendedGame
     * const recommendedGame = await prisma.recommendedGame.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecommendedGameFindUniqueOrThrowArgs>(
      args: SelectSubset<T, RecommendedGameFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RecommendedGameClient<
      $Result.GetResult<
        Prisma.$RecommendedGamePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first RecommendedGame that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendedGameFindFirstArgs} args - Arguments to find a RecommendedGame
     * @example
     * // Get one RecommendedGame
     * const recommendedGame = await prisma.recommendedGame.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecommendedGameFindFirstArgs>(
      args?: SelectSubset<T, RecommendedGameFindFirstArgs<ExtArgs>>
    ): Prisma__RecommendedGameClient<
      $Result.GetResult<
        Prisma.$RecommendedGamePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first RecommendedGame that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendedGameFindFirstOrThrowArgs} args - Arguments to find a RecommendedGame
     * @example
     * // Get one RecommendedGame
     * const recommendedGame = await prisma.recommendedGame.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecommendedGameFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RecommendedGameFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RecommendedGameClient<
      $Result.GetResult<
        Prisma.$RecommendedGamePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more RecommendedGames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendedGameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecommendedGames
     * const recommendedGames = await prisma.recommendedGame.findMany()
     *
     * // Get first 10 RecommendedGames
     * const recommendedGames = await prisma.recommendedGame.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const recommendedGameWithIdOnly = await prisma.recommendedGame.findMany({ select: { id: true } })
     *
     */
    findMany<T extends RecommendedGameFindManyArgs>(
      args?: SelectSubset<T, RecommendedGameFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$RecommendedGamePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a RecommendedGame.
     * @param {RecommendedGameCreateArgs} args - Arguments to create a RecommendedGame.
     * @example
     * // Create one RecommendedGame
     * const RecommendedGame = await prisma.recommendedGame.create({
     *   data: {
     *     // ... data to create a RecommendedGame
     *   }
     * })
     *
     */
    create<T extends RecommendedGameCreateArgs>(
      args: SelectSubset<T, RecommendedGameCreateArgs<ExtArgs>>
    ): Prisma__RecommendedGameClient<
      $Result.GetResult<
        Prisma.$RecommendedGamePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many RecommendedGames.
     * @param {RecommendedGameCreateManyArgs} args - Arguments to create many RecommendedGames.
     * @example
     * // Create many RecommendedGames
     * const recommendedGame = await prisma.recommendedGame.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends RecommendedGameCreateManyArgs>(
      args?: SelectSubset<T, RecommendedGameCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many RecommendedGames and returns the data saved in the database.
     * @param {RecommendedGameCreateManyAndReturnArgs} args - Arguments to create many RecommendedGames.
     * @example
     * // Create many RecommendedGames
     * const recommendedGame = await prisma.recommendedGame.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many RecommendedGames and only return the `id`
     * const recommendedGameWithIdOnly = await prisma.recommendedGame.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends RecommendedGameCreateManyAndReturnArgs>(
      args?: SelectSubset<T, RecommendedGameCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$RecommendedGamePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a RecommendedGame.
     * @param {RecommendedGameDeleteArgs} args - Arguments to delete one RecommendedGame.
     * @example
     * // Delete one RecommendedGame
     * const RecommendedGame = await prisma.recommendedGame.delete({
     *   where: {
     *     // ... filter to delete one RecommendedGame
     *   }
     * })
     *
     */
    delete<T extends RecommendedGameDeleteArgs>(
      args: SelectSubset<T, RecommendedGameDeleteArgs<ExtArgs>>
    ): Prisma__RecommendedGameClient<
      $Result.GetResult<
        Prisma.$RecommendedGamePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one RecommendedGame.
     * @param {RecommendedGameUpdateArgs} args - Arguments to update one RecommendedGame.
     * @example
     * // Update one RecommendedGame
     * const recommendedGame = await prisma.recommendedGame.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends RecommendedGameUpdateArgs>(
      args: SelectSubset<T, RecommendedGameUpdateArgs<ExtArgs>>
    ): Prisma__RecommendedGameClient<
      $Result.GetResult<
        Prisma.$RecommendedGamePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more RecommendedGames.
     * @param {RecommendedGameDeleteManyArgs} args - Arguments to filter RecommendedGames to delete.
     * @example
     * // Delete a few RecommendedGames
     * const { count } = await prisma.recommendedGame.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends RecommendedGameDeleteManyArgs>(
      args?: SelectSubset<T, RecommendedGameDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more RecommendedGames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendedGameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecommendedGames
     * const recommendedGame = await prisma.recommendedGame.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends RecommendedGameUpdateManyArgs>(
      args: SelectSubset<T, RecommendedGameUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more RecommendedGames and returns the data updated in the database.
     * @param {RecommendedGameUpdateManyAndReturnArgs} args - Arguments to update many RecommendedGames.
     * @example
     * // Update many RecommendedGames
     * const recommendedGame = await prisma.recommendedGame.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more RecommendedGames and only return the `id`
     * const recommendedGameWithIdOnly = await prisma.recommendedGame.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends RecommendedGameUpdateManyAndReturnArgs>(
      args: SelectSubset<T, RecommendedGameUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$RecommendedGamePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one RecommendedGame.
     * @param {RecommendedGameUpsertArgs} args - Arguments to update or create a RecommendedGame.
     * @example
     * // Update or create a RecommendedGame
     * const recommendedGame = await prisma.recommendedGame.upsert({
     *   create: {
     *     // ... data to create a RecommendedGame
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecommendedGame we want to update
     *   }
     * })
     */
    upsert<T extends RecommendedGameUpsertArgs>(
      args: SelectSubset<T, RecommendedGameUpsertArgs<ExtArgs>>
    ): Prisma__RecommendedGameClient<
      $Result.GetResult<
        Prisma.$RecommendedGamePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of RecommendedGames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendedGameCountArgs} args - Arguments to filter RecommendedGames to count.
     * @example
     * // Count the number of RecommendedGames
     * const count = await prisma.recommendedGame.count({
     *   where: {
     *     // ... the filter for the RecommendedGames we want to count
     *   }
     * })
     **/
    count<T extends RecommendedGameCountArgs>(
      args?: Subset<T, RecommendedGameCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], RecommendedGameCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a RecommendedGame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendedGameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RecommendedGameAggregateArgs>(
      args: Subset<T, RecommendedGameAggregateArgs>
    ): Prisma.PrismaPromise<GetRecommendedGameAggregateType<T>>;

    /**
     * Group by RecommendedGame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendedGameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RecommendedGameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecommendedGameGroupByArgs["orderBy"] }
        : { orderBy?: RecommendedGameGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, RecommendedGameGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetRecommendedGameGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the RecommendedGame model
     */
    readonly fields: RecommendedGameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecommendedGame.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecommendedGameClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    game<T extends GameDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, GameDefaultArgs<ExtArgs>>
    ): Prisma__GameClient<
      | $Result.GetResult<
          Prisma.$GamePayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    relatedGame<T extends RecommendedGame$relatedGameArgs<ExtArgs> = {}>(
      args?: Subset<T, RecommendedGame$relatedGameArgs<ExtArgs>>
    ): Prisma__GameClient<
      $Result.GetResult<
        Prisma.$GamePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the RecommendedGame model
   */
  interface RecommendedGameFieldRefs {
    readonly id: FieldRef<"RecommendedGame", "String">;
    readonly gameId: FieldRef<"RecommendedGame", "String">;
    readonly recommendationType: FieldRef<
      "RecommendedGame",
      "RecommendationType"
    >;
    readonly relatedGameId: FieldRef<"RecommendedGame", "String">;
    readonly startDate: FieldRef<"RecommendedGame", "DateTime">;
    readonly endDate: FieldRef<"RecommendedGame", "DateTime">;
    readonly priority: FieldRef<"RecommendedGame", "Int">;
    readonly createdAt: FieldRef<"RecommendedGame", "DateTime">;
  }

  // Custom InputTypes
  /**
   * RecommendedGame findUnique
   */
  export type RecommendedGameFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RecommendedGame
     */
    select?: RecommendedGameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RecommendedGame
     */
    omit?: RecommendedGameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedGameInclude<ExtArgs> | null;
    /**
     * Filter, which RecommendedGame to fetch.
     */
    where: RecommendedGameWhereUniqueInput;
  };

  /**
   * RecommendedGame findUniqueOrThrow
   */
  export type RecommendedGameFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RecommendedGame
     */
    select?: RecommendedGameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RecommendedGame
     */
    omit?: RecommendedGameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedGameInclude<ExtArgs> | null;
    /**
     * Filter, which RecommendedGame to fetch.
     */
    where: RecommendedGameWhereUniqueInput;
  };

  /**
   * RecommendedGame findFirst
   */
  export type RecommendedGameFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RecommendedGame
     */
    select?: RecommendedGameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RecommendedGame
     */
    omit?: RecommendedGameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedGameInclude<ExtArgs> | null;
    /**
     * Filter, which RecommendedGame to fetch.
     */
    where?: RecommendedGameWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RecommendedGames to fetch.
     */
    orderBy?:
      | RecommendedGameOrderByWithRelationInput
      | RecommendedGameOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RecommendedGames.
     */
    cursor?: RecommendedGameWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RecommendedGames from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RecommendedGames.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RecommendedGames.
     */
    distinct?:
      | RecommendedGameScalarFieldEnum
      | RecommendedGameScalarFieldEnum[];
  };

  /**
   * RecommendedGame findFirstOrThrow
   */
  export type RecommendedGameFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RecommendedGame
     */
    select?: RecommendedGameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RecommendedGame
     */
    omit?: RecommendedGameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedGameInclude<ExtArgs> | null;
    /**
     * Filter, which RecommendedGame to fetch.
     */
    where?: RecommendedGameWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RecommendedGames to fetch.
     */
    orderBy?:
      | RecommendedGameOrderByWithRelationInput
      | RecommendedGameOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RecommendedGames.
     */
    cursor?: RecommendedGameWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RecommendedGames from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RecommendedGames.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RecommendedGames.
     */
    distinct?:
      | RecommendedGameScalarFieldEnum
      | RecommendedGameScalarFieldEnum[];
  };

  /**
   * RecommendedGame findMany
   */
  export type RecommendedGameFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RecommendedGame
     */
    select?: RecommendedGameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RecommendedGame
     */
    omit?: RecommendedGameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedGameInclude<ExtArgs> | null;
    /**
     * Filter, which RecommendedGames to fetch.
     */
    where?: RecommendedGameWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RecommendedGames to fetch.
     */
    orderBy?:
      | RecommendedGameOrderByWithRelationInput
      | RecommendedGameOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing RecommendedGames.
     */
    cursor?: RecommendedGameWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RecommendedGames from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RecommendedGames.
     */
    skip?: number;
    distinct?:
      | RecommendedGameScalarFieldEnum
      | RecommendedGameScalarFieldEnum[];
  };

  /**
   * RecommendedGame create
   */
  export type RecommendedGameCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RecommendedGame
     */
    select?: RecommendedGameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RecommendedGame
     */
    omit?: RecommendedGameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedGameInclude<ExtArgs> | null;
    /**
     * The data needed to create a RecommendedGame.
     */
    data: XOR<RecommendedGameCreateInput, RecommendedGameUncheckedCreateInput>;
  };

  /**
   * RecommendedGame createMany
   */
  export type RecommendedGameCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many RecommendedGames.
     */
    data: RecommendedGameCreateManyInput | RecommendedGameCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * RecommendedGame createManyAndReturn
   */
  export type RecommendedGameCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RecommendedGame
     */
    select?: RecommendedGameSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the RecommendedGame
     */
    omit?: RecommendedGameOmit<ExtArgs> | null;
    /**
     * The data used to create many RecommendedGames.
     */
    data: RecommendedGameCreateManyInput | RecommendedGameCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedGameIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * RecommendedGame update
   */
  export type RecommendedGameUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RecommendedGame
     */
    select?: RecommendedGameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RecommendedGame
     */
    omit?: RecommendedGameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedGameInclude<ExtArgs> | null;
    /**
     * The data needed to update a RecommendedGame.
     */
    data: XOR<RecommendedGameUpdateInput, RecommendedGameUncheckedUpdateInput>;
    /**
     * Choose, which RecommendedGame to update.
     */
    where: RecommendedGameWhereUniqueInput;
  };

  /**
   * RecommendedGame updateMany
   */
  export type RecommendedGameUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update RecommendedGames.
     */
    data: XOR<
      RecommendedGameUpdateManyMutationInput,
      RecommendedGameUncheckedUpdateManyInput
    >;
    /**
     * Filter which RecommendedGames to update
     */
    where?: RecommendedGameWhereInput;
    /**
     * Limit how many RecommendedGames to update.
     */
    limit?: number;
  };

  /**
   * RecommendedGame updateManyAndReturn
   */
  export type RecommendedGameUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RecommendedGame
     */
    select?: RecommendedGameSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the RecommendedGame
     */
    omit?: RecommendedGameOmit<ExtArgs> | null;
    /**
     * The data used to update RecommendedGames.
     */
    data: XOR<
      RecommendedGameUpdateManyMutationInput,
      RecommendedGameUncheckedUpdateManyInput
    >;
    /**
     * Filter which RecommendedGames to update
     */
    where?: RecommendedGameWhereInput;
    /**
     * Limit how many RecommendedGames to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedGameIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * RecommendedGame upsert
   */
  export type RecommendedGameUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RecommendedGame
     */
    select?: RecommendedGameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RecommendedGame
     */
    omit?: RecommendedGameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedGameInclude<ExtArgs> | null;
    /**
     * The filter to search for the RecommendedGame to update in case it exists.
     */
    where: RecommendedGameWhereUniqueInput;
    /**
     * In case the RecommendedGame found by the `where` argument doesn't exist, create a new RecommendedGame with this data.
     */
    create: XOR<
      RecommendedGameCreateInput,
      RecommendedGameUncheckedCreateInput
    >;
    /**
     * In case the RecommendedGame was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      RecommendedGameUpdateInput,
      RecommendedGameUncheckedUpdateInput
    >;
  };

  /**
   * RecommendedGame delete
   */
  export type RecommendedGameDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RecommendedGame
     */
    select?: RecommendedGameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RecommendedGame
     */
    omit?: RecommendedGameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedGameInclude<ExtArgs> | null;
    /**
     * Filter which RecommendedGame to delete.
     */
    where: RecommendedGameWhereUniqueInput;
  };

  /**
   * RecommendedGame deleteMany
   */
  export type RecommendedGameDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which RecommendedGames to delete
     */
    where?: RecommendedGameWhereInput;
    /**
     * Limit how many RecommendedGames to delete.
     */
    limit?: number;
  };

  /**
   * RecommendedGame.relatedGame
   */
  export type RecommendedGame$relatedGameArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null;
    where?: GameWhereInput;
  };

  /**
   * RecommendedGame without action
   */
  export type RecommendedGameDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RecommendedGame
     */
    select?: RecommendedGameSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RecommendedGame
     */
    omit?: RecommendedGameOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecommendedGameInclude<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: "ReadUncommitted";
    ReadCommitted: "ReadCommitted";
    RepeatableRead: "RepeatableRead";
    Serializable: "Serializable";
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const UserScalarFieldEnum: {
    id: "id";
    name: "name";
    email: "email";
    emailVerified: "emailVerified";
    image: "image";
    password: "password";
    address: "address";
    phone: "phone";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type UserScalarFieldEnum =
    (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

  export const AccountScalarFieldEnum: {
    id: "id";
    userId: "userId";
    type: "type";
    provider: "provider";
    providerAccountId: "providerAccountId";
    refresh_token: "refresh_token";
    access_token: "access_token";
    expires_at: "expires_at";
    token_type: "token_type";
    scope: "scope";
    id_token: "id_token";
    session_state: "session_state";
  };

  export type AccountScalarFieldEnum =
    (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum];

  export const SessionScalarFieldEnum: {
    id: "id";
    sessionToken: "sessionToken";
    userId: "userId";
    expires: "expires";
  };

  export type SessionScalarFieldEnum =
    (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum];

  export const VerificationTokenScalarFieldEnum: {
    identifier: "identifier";
    token: "token";
    expires: "expires";
  };

  export type VerificationTokenScalarFieldEnum =
    (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum];

  export const GameScalarFieldEnum: {
    id: "id";
    title: "title";
    description: "description";
    price: "price";
    releaseDate: "releaseDate";
    developer: "developer";
    publisher: "publisher";
    coverImageUrl: "coverImageUrl";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    rating: "rating";
    discountedPrice: "discountedPrice";
    status: "status";
  };

  export type GameScalarFieldEnum =
    (typeof GameScalarFieldEnum)[keyof typeof GameScalarFieldEnum];

  export const GenreScalarFieldEnum: {
    id: "id";
    name: "name";
    parentId: "parentId";
  };

  export type GenreScalarFieldEnum =
    (typeof GenreScalarFieldEnum)[keyof typeof GenreScalarFieldEnum];

  export const GameGenreScalarFieldEnum: {
    gameId: "gameId";
    genreId: "genreId";
  };

  export type GameGenreScalarFieldEnum =
    (typeof GameGenreScalarFieldEnum)[keyof typeof GameGenreScalarFieldEnum];

  export const ScreenshotScalarFieldEnum: {
    id: "id";
    gameId: "gameId";
    imageUrl: "imageUrl";
    caption: "caption";
  };

  export type ScreenshotScalarFieldEnum =
    (typeof ScreenshotScalarFieldEnum)[keyof typeof ScreenshotScalarFieldEnum];

  export const ReviewScalarFieldEnum: {
    id: "id";
    rating: "rating";
    comment: "comment";
    createdAt: "createdAt";
    userId: "userId";
    gameId: "gameId";
  };

  export type ReviewScalarFieldEnum =
    (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum];

  export const CartScalarFieldEnum: {
    id: "id";
    userId: "userId";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type CartScalarFieldEnum =
    (typeof CartScalarFieldEnum)[keyof typeof CartScalarFieldEnum];

  export const CartItemScalarFieldEnum: {
    id: "id";
    cartId: "cartId";
    gameId: "gameId";
    quantity: "quantity";
    addedAt: "addedAt";
  };

  export type CartItemScalarFieldEnum =
    (typeof CartItemScalarFieldEnum)[keyof typeof CartItemScalarFieldEnum];

  export const OrderScalarFieldEnum: {
    id: "id";
    userId: "userId";
    totalAmount: "totalAmount";
    status: "status";
    createdAt: "createdAt";
  };

  export type OrderScalarFieldEnum =
    (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum];

  export const OrderItemScalarFieldEnum: {
    id: "id";
    orderId: "orderId";
    gameId: "gameId";
    price: "price";
    quantity: "quantity";
  };

  export type OrderItemScalarFieldEnum =
    (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum];

  export const FeaturedGameScalarFieldEnum: {
    id: "id";
    gameId: "gameId";
    startDate: "startDate";
    endDate: "endDate";
    priority: "priority";
    createdAt: "createdAt";
  };

  export type FeaturedGameScalarFieldEnum =
    (typeof FeaturedGameScalarFieldEnum)[keyof typeof FeaturedGameScalarFieldEnum];

  export const RecommendedGameScalarFieldEnum: {
    id: "id";
    gameId: "gameId";
    recommendationType: "recommendationType";
    relatedGameId: "relatedGameId";
    startDate: "startDate";
    endDate: "endDate";
    priority: "priority";
    createdAt: "createdAt";
  };

  export type RecommendedGameScalarFieldEnum =
    (typeof RecommendedGameScalarFieldEnum)[keyof typeof RecommendedGameScalarFieldEnum];

  export const SortOrder: {
    asc: "asc";
    desc: "desc";
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const QueryMode: {
    default: "default";
    insensitive: "insensitive";
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const NullsOrder: {
    first: "first";
    last: "last";
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "String"
  >;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "String[]"
  >;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DateTime"
  >;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DateTime[]"
  >;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Int"
  >;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Int[]"
  >;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Float"
  >;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Float[]"
  >;

  /**
   * Reference to a field of type 'GameStatus'
   */
  export type EnumGameStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "GameStatus"
  >;

  /**
   * Reference to a field of type 'GameStatus[]'
   */
  export type ListEnumGameStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "GameStatus[]"
  >;

  /**
   * Reference to a field of type 'RecommendationType'
   */
  export type EnumRecommendationTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "RecommendationType">;

  /**
   * Reference to a field of type 'RecommendationType[]'
   */
  export type ListEnumRecommendationTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "RecommendationType[]">;

  /**
   * Deep Input Types
   */

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    id?: StringFilter<"User"> | string;
    name?: StringNullableFilter<"User"> | string | null;
    email?: StringNullableFilter<"User"> | string | null;
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null;
    image?: StringNullableFilter<"User"> | string | null;
    password?: StringNullableFilter<"User"> | string | null;
    address?: StringNullableFilter<"User"> | string | null;
    phone?: StringNullableFilter<"User"> | string | null;
    createdAt?: DateTimeFilter<"User"> | Date | string;
    updatedAt?: DateTimeFilter<"User"> | Date | string;
    accounts?: AccountListRelationFilter;
    sessions?: SessionListRelationFilter;
    cart?: XOR<CartNullableScalarRelationFilter, CartWhereInput> | null;
    orders?: OrderListRelationFilter;
    reviews?: ReviewListRelationFilter;
  };

  export type UserOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrderInput | SortOrder;
    email?: SortOrderInput | SortOrder;
    emailVerified?: SortOrderInput | SortOrder;
    image?: SortOrderInput | SortOrder;
    password?: SortOrderInput | SortOrder;
    address?: SortOrderInput | SortOrder;
    phone?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    accounts?: AccountOrderByRelationAggregateInput;
    sessions?: SessionOrderByRelationAggregateInput;
    cart?: CartOrderByWithRelationInput;
    orders?: OrderOrderByRelationAggregateInput;
    reviews?: ReviewOrderByRelationAggregateInput;
  };

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      email?: string;
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      name?: StringNullableFilter<"User"> | string | null;
      emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null;
      image?: StringNullableFilter<"User"> | string | null;
      password?: StringNullableFilter<"User"> | string | null;
      address?: StringNullableFilter<"User"> | string | null;
      phone?: StringNullableFilter<"User"> | string | null;
      createdAt?: DateTimeFilter<"User"> | Date | string;
      updatedAt?: DateTimeFilter<"User"> | Date | string;
      accounts?: AccountListRelationFilter;
      sessions?: SessionListRelationFilter;
      cart?: XOR<CartNullableScalarRelationFilter, CartWhereInput> | null;
      orders?: OrderListRelationFilter;
      reviews?: ReviewListRelationFilter;
    },
    "id" | "email"
  >;

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrderInput | SortOrder;
    email?: SortOrderInput | SortOrder;
    emailVerified?: SortOrderInput | SortOrder;
    image?: SortOrderInput | SortOrder;
    password?: SortOrderInput | SortOrder;
    address?: SortOrderInput | SortOrder;
    phone?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"User"> | string;
    name?: StringNullableWithAggregatesFilter<"User"> | string | null;
    email?: StringNullableWithAggregatesFilter<"User"> | string | null;
    emailVerified?:
      | DateTimeNullableWithAggregatesFilter<"User">
      | Date
      | string
      | null;
    image?: StringNullableWithAggregatesFilter<"User"> | string | null;
    password?: StringNullableWithAggregatesFilter<"User"> | string | null;
    address?: StringNullableWithAggregatesFilter<"User"> | string | null;
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string;
  };

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[];
    OR?: AccountWhereInput[];
    NOT?: AccountWhereInput | AccountWhereInput[];
    id?: StringFilter<"Account"> | string;
    userId?: StringFilter<"Account"> | string;
    type?: StringFilter<"Account"> | string;
    provider?: StringFilter<"Account"> | string;
    providerAccountId?: StringFilter<"Account"> | string;
    refresh_token?: StringNullableFilter<"Account"> | string | null;
    access_token?: StringNullableFilter<"Account"> | string | null;
    expires_at?: IntNullableFilter<"Account"> | number | null;
    token_type?: StringNullableFilter<"Account"> | string | null;
    scope?: StringNullableFilter<"Account"> | string | null;
    id_token?: StringNullableFilter<"Account"> | string | null;
    session_state?: StringNullableFilter<"Account"> | string | null;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrderInput | SortOrder;
    access_token?: SortOrderInput | SortOrder;
    expires_at?: SortOrderInput | SortOrder;
    token_type?: SortOrderInput | SortOrder;
    scope?: SortOrderInput | SortOrder;
    id_token?: SortOrderInput | SortOrder;
    session_state?: SortOrderInput | SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type AccountWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput;
      AND?: AccountWhereInput | AccountWhereInput[];
      OR?: AccountWhereInput[];
      NOT?: AccountWhereInput | AccountWhereInput[];
      userId?: StringFilter<"Account"> | string;
      type?: StringFilter<"Account"> | string;
      provider?: StringFilter<"Account"> | string;
      providerAccountId?: StringFilter<"Account"> | string;
      refresh_token?: StringNullableFilter<"Account"> | string | null;
      access_token?: StringNullableFilter<"Account"> | string | null;
      expires_at?: IntNullableFilter<"Account"> | number | null;
      token_type?: StringNullableFilter<"Account"> | string | null;
      scope?: StringNullableFilter<"Account"> | string | null;
      id_token?: StringNullableFilter<"Account"> | string | null;
      session_state?: StringNullableFilter<"Account"> | string | null;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "provider_providerAccountId"
  >;

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrderInput | SortOrder;
    access_token?: SortOrderInput | SortOrder;
    expires_at?: SortOrderInput | SortOrder;
    token_type?: SortOrderInput | SortOrder;
    scope?: SortOrderInput | SortOrder;
    id_token?: SortOrderInput | SortOrder;
    session_state?: SortOrderInput | SortOrder;
    _count?: AccountCountOrderByAggregateInput;
    _avg?: AccountAvgOrderByAggregateInput;
    _max?: AccountMaxOrderByAggregateInput;
    _min?: AccountMinOrderByAggregateInput;
    _sum?: AccountSumOrderByAggregateInput;
  };

  export type AccountScalarWhereWithAggregatesInput = {
    AND?:
      | AccountScalarWhereWithAggregatesInput
      | AccountScalarWhereWithAggregatesInput[];
    OR?: AccountScalarWhereWithAggregatesInput[];
    NOT?:
      | AccountScalarWhereWithAggregatesInput
      | AccountScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Account"> | string;
    userId?: StringWithAggregatesFilter<"Account"> | string;
    type?: StringWithAggregatesFilter<"Account"> | string;
    provider?: StringWithAggregatesFilter<"Account"> | string;
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string;
    refresh_token?:
      | StringNullableWithAggregatesFilter<"Account">
      | string
      | null;
    access_token?:
      | StringNullableWithAggregatesFilter<"Account">
      | string
      | null;
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null;
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null;
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null;
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null;
    session_state?:
      | StringNullableWithAggregatesFilter<"Account">
      | string
      | null;
  };

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[];
    OR?: SessionWhereInput[];
    NOT?: SessionWhereInput | SessionWhereInput[];
    id?: StringFilter<"Session"> | string;
    sessionToken?: StringFilter<"Session"> | string;
    userId?: StringFilter<"Session"> | string;
    expires?: DateTimeFilter<"Session"> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type SessionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      sessionToken?: string;
      AND?: SessionWhereInput | SessionWhereInput[];
      OR?: SessionWhereInput[];
      NOT?: SessionWhereInput | SessionWhereInput[];
      userId?: StringFilter<"Session"> | string;
      expires?: DateTimeFilter<"Session"> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "sessionToken"
  >;

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    _count?: SessionCountOrderByAggregateInput;
    _max?: SessionMaxOrderByAggregateInput;
    _min?: SessionMinOrderByAggregateInput;
  };

  export type SessionScalarWhereWithAggregatesInput = {
    AND?:
      | SessionScalarWhereWithAggregatesInput
      | SessionScalarWhereWithAggregatesInput[];
    OR?: SessionScalarWhereWithAggregatesInput[];
    NOT?:
      | SessionScalarWhereWithAggregatesInput
      | SessionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Session"> | string;
    sessionToken?: StringWithAggregatesFilter<"Session"> | string;
    userId?: StringWithAggregatesFilter<"Session"> | string;
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string;
  };

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
    OR?: VerificationTokenWhereInput[];
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
    identifier?: StringFilter<"VerificationToken"> | string;
    token?: StringFilter<"VerificationToken"> | string;
    expires?: DateTimeFilter<"VerificationToken"> | Date | string;
  };

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<
    {
      identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput;
      AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
      OR?: VerificationTokenWhereInput[];
      NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
      identifier?: StringFilter<"VerificationToken"> | string;
      token?: StringFilter<"VerificationToken"> | string;
      expires?: DateTimeFilter<"VerificationToken"> | Date | string;
    },
    "identifier_token"
  >;

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
    _count?: VerificationTokenCountOrderByAggregateInput;
    _max?: VerificationTokenMaxOrderByAggregateInput;
    _min?: VerificationTokenMinOrderByAggregateInput;
  };

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?:
      | VerificationTokenScalarWhereWithAggregatesInput
      | VerificationTokenScalarWhereWithAggregatesInput[];
    OR?: VerificationTokenScalarWhereWithAggregatesInput[];
    NOT?:
      | VerificationTokenScalarWhereWithAggregatesInput
      | VerificationTokenScalarWhereWithAggregatesInput[];
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string;
    token?: StringWithAggregatesFilter<"VerificationToken"> | string;
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string;
  };

  export type GameWhereInput = {
    AND?: GameWhereInput | GameWhereInput[];
    OR?: GameWhereInput[];
    NOT?: GameWhereInput | GameWhereInput[];
    id?: StringFilter<"Game"> | string;
    title?: StringFilter<"Game"> | string;
    description?: StringFilter<"Game"> | string;
    price?: FloatFilter<"Game"> | number;
    releaseDate?: DateTimeFilter<"Game"> | Date | string;
    developer?: StringFilter<"Game"> | string;
    publisher?: StringFilter<"Game"> | string;
    coverImageUrl?: StringFilter<"Game"> | string;
    createdAt?: DateTimeFilter<"Game"> | Date | string;
    updatedAt?: DateTimeFilter<"Game"> | Date | string;
    rating?: FloatFilter<"Game"> | number;
    discountedPrice?: FloatNullableFilter<"Game"> | number | null;
    status?: EnumGameStatusFilter<"Game"> | $Enums.GameStatus;
    cartItems?: CartItemListRelationFilter;
    genres?: GameGenreListRelationFilter;
    orderItems?: OrderItemListRelationFilter;
    reviews?: ReviewListRelationFilter;
    screenshots?: ScreenshotListRelationFilter;
    featuredGames?: FeaturedGameListRelationFilter;
    recommendedMain?: RecommendedGameListRelationFilter;
    recommendedRel?: RecommendedGameListRelationFilter;
  };

  export type GameOrderByWithRelationInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    price?: SortOrder;
    releaseDate?: SortOrder;
    developer?: SortOrder;
    publisher?: SortOrder;
    coverImageUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    rating?: SortOrder;
    discountedPrice?: SortOrderInput | SortOrder;
    status?: SortOrder;
    cartItems?: CartItemOrderByRelationAggregateInput;
    genres?: GameGenreOrderByRelationAggregateInput;
    orderItems?: OrderItemOrderByRelationAggregateInput;
    reviews?: ReviewOrderByRelationAggregateInput;
    screenshots?: ScreenshotOrderByRelationAggregateInput;
    featuredGames?: FeaturedGameOrderByRelationAggregateInput;
    recommendedMain?: RecommendedGameOrderByRelationAggregateInput;
    recommendedRel?: RecommendedGameOrderByRelationAggregateInput;
  };

  export type GameWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      title?: string;
      AND?: GameWhereInput | GameWhereInput[];
      OR?: GameWhereInput[];
      NOT?: GameWhereInput | GameWhereInput[];
      description?: StringFilter<"Game"> | string;
      price?: FloatFilter<"Game"> | number;
      releaseDate?: DateTimeFilter<"Game"> | Date | string;
      developer?: StringFilter<"Game"> | string;
      publisher?: StringFilter<"Game"> | string;
      coverImageUrl?: StringFilter<"Game"> | string;
      createdAt?: DateTimeFilter<"Game"> | Date | string;
      updatedAt?: DateTimeFilter<"Game"> | Date | string;
      rating?: FloatFilter<"Game"> | number;
      discountedPrice?: FloatNullableFilter<"Game"> | number | null;
      status?: EnumGameStatusFilter<"Game"> | $Enums.GameStatus;
      cartItems?: CartItemListRelationFilter;
      genres?: GameGenreListRelationFilter;
      orderItems?: OrderItemListRelationFilter;
      reviews?: ReviewListRelationFilter;
      screenshots?: ScreenshotListRelationFilter;
      featuredGames?: FeaturedGameListRelationFilter;
      recommendedMain?: RecommendedGameListRelationFilter;
      recommendedRel?: RecommendedGameListRelationFilter;
    },
    "id" | "title"
  >;

  export type GameOrderByWithAggregationInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    price?: SortOrder;
    releaseDate?: SortOrder;
    developer?: SortOrder;
    publisher?: SortOrder;
    coverImageUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    rating?: SortOrder;
    discountedPrice?: SortOrderInput | SortOrder;
    status?: SortOrder;
    _count?: GameCountOrderByAggregateInput;
    _avg?: GameAvgOrderByAggregateInput;
    _max?: GameMaxOrderByAggregateInput;
    _min?: GameMinOrderByAggregateInput;
    _sum?: GameSumOrderByAggregateInput;
  };

  export type GameScalarWhereWithAggregatesInput = {
    AND?:
      | GameScalarWhereWithAggregatesInput
      | GameScalarWhereWithAggregatesInput[];
    OR?: GameScalarWhereWithAggregatesInput[];
    NOT?:
      | GameScalarWhereWithAggregatesInput
      | GameScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Game"> | string;
    title?: StringWithAggregatesFilter<"Game"> | string;
    description?: StringWithAggregatesFilter<"Game"> | string;
    price?: FloatWithAggregatesFilter<"Game"> | number;
    releaseDate?: DateTimeWithAggregatesFilter<"Game"> | Date | string;
    developer?: StringWithAggregatesFilter<"Game"> | string;
    publisher?: StringWithAggregatesFilter<"Game"> | string;
    coverImageUrl?: StringWithAggregatesFilter<"Game"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"Game"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Game"> | Date | string;
    rating?: FloatWithAggregatesFilter<"Game"> | number;
    discountedPrice?: FloatNullableWithAggregatesFilter<"Game"> | number | null;
    status?: EnumGameStatusWithAggregatesFilter<"Game"> | $Enums.GameStatus;
  };

  export type GenreWhereInput = {
    AND?: GenreWhereInput | GenreWhereInput[];
    OR?: GenreWhereInput[];
    NOT?: GenreWhereInput | GenreWhereInput[];
    id?: StringFilter<"Genre"> | string;
    name?: StringFilter<"Genre"> | string;
    parentId?: StringNullableFilter<"Genre"> | string | null;
    games?: GameGenreListRelationFilter;
    parent?: XOR<GenreNullableScalarRelationFilter, GenreWhereInput> | null;
    subGenres?: GenreListRelationFilter;
  };

  export type GenreOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    parentId?: SortOrderInput | SortOrder;
    games?: GameGenreOrderByRelationAggregateInput;
    parent?: GenreOrderByWithRelationInput;
    subGenres?: GenreOrderByRelationAggregateInput;
  };

  export type GenreWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      name?: string;
      AND?: GenreWhereInput | GenreWhereInput[];
      OR?: GenreWhereInput[];
      NOT?: GenreWhereInput | GenreWhereInput[];
      parentId?: StringNullableFilter<"Genre"> | string | null;
      games?: GameGenreListRelationFilter;
      parent?: XOR<GenreNullableScalarRelationFilter, GenreWhereInput> | null;
      subGenres?: GenreListRelationFilter;
    },
    "id" | "name"
  >;

  export type GenreOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    parentId?: SortOrderInput | SortOrder;
    _count?: GenreCountOrderByAggregateInput;
    _max?: GenreMaxOrderByAggregateInput;
    _min?: GenreMinOrderByAggregateInput;
  };

  export type GenreScalarWhereWithAggregatesInput = {
    AND?:
      | GenreScalarWhereWithAggregatesInput
      | GenreScalarWhereWithAggregatesInput[];
    OR?: GenreScalarWhereWithAggregatesInput[];
    NOT?:
      | GenreScalarWhereWithAggregatesInput
      | GenreScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Genre"> | string;
    name?: StringWithAggregatesFilter<"Genre"> | string;
    parentId?: StringNullableWithAggregatesFilter<"Genre"> | string | null;
  };

  export type GameGenreWhereInput = {
    AND?: GameGenreWhereInput | GameGenreWhereInput[];
    OR?: GameGenreWhereInput[];
    NOT?: GameGenreWhereInput | GameGenreWhereInput[];
    gameId?: StringFilter<"GameGenre"> | string;
    genreId?: StringFilter<"GameGenre"> | string;
    game?: XOR<GameScalarRelationFilter, GameWhereInput>;
    genre?: XOR<GenreScalarRelationFilter, GenreWhereInput>;
  };

  export type GameGenreOrderByWithRelationInput = {
    gameId?: SortOrder;
    genreId?: SortOrder;
    game?: GameOrderByWithRelationInput;
    genre?: GenreOrderByWithRelationInput;
  };

  export type GameGenreWhereUniqueInput = Prisma.AtLeast<
    {
      gameId_genreId?: GameGenreGameIdGenreIdCompoundUniqueInput;
      AND?: GameGenreWhereInput | GameGenreWhereInput[];
      OR?: GameGenreWhereInput[];
      NOT?: GameGenreWhereInput | GameGenreWhereInput[];
      gameId?: StringFilter<"GameGenre"> | string;
      genreId?: StringFilter<"GameGenre"> | string;
      game?: XOR<GameScalarRelationFilter, GameWhereInput>;
      genre?: XOR<GenreScalarRelationFilter, GenreWhereInput>;
    },
    "gameId_genreId"
  >;

  export type GameGenreOrderByWithAggregationInput = {
    gameId?: SortOrder;
    genreId?: SortOrder;
    _count?: GameGenreCountOrderByAggregateInput;
    _max?: GameGenreMaxOrderByAggregateInput;
    _min?: GameGenreMinOrderByAggregateInput;
  };

  export type GameGenreScalarWhereWithAggregatesInput = {
    AND?:
      | GameGenreScalarWhereWithAggregatesInput
      | GameGenreScalarWhereWithAggregatesInput[];
    OR?: GameGenreScalarWhereWithAggregatesInput[];
    NOT?:
      | GameGenreScalarWhereWithAggregatesInput
      | GameGenreScalarWhereWithAggregatesInput[];
    gameId?: StringWithAggregatesFilter<"GameGenre"> | string;
    genreId?: StringWithAggregatesFilter<"GameGenre"> | string;
  };

  export type ScreenshotWhereInput = {
    AND?: ScreenshotWhereInput | ScreenshotWhereInput[];
    OR?: ScreenshotWhereInput[];
    NOT?: ScreenshotWhereInput | ScreenshotWhereInput[];
    id?: StringFilter<"Screenshot"> | string;
    gameId?: StringFilter<"Screenshot"> | string;
    imageUrl?: StringFilter<"Screenshot"> | string;
    caption?: StringNullableFilter<"Screenshot"> | string | null;
    game?: XOR<GameScalarRelationFilter, GameWhereInput>;
  };

  export type ScreenshotOrderByWithRelationInput = {
    id?: SortOrder;
    gameId?: SortOrder;
    imageUrl?: SortOrder;
    caption?: SortOrderInput | SortOrder;
    game?: GameOrderByWithRelationInput;
  };

  export type ScreenshotWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ScreenshotWhereInput | ScreenshotWhereInput[];
      OR?: ScreenshotWhereInput[];
      NOT?: ScreenshotWhereInput | ScreenshotWhereInput[];
      gameId?: StringFilter<"Screenshot"> | string;
      imageUrl?: StringFilter<"Screenshot"> | string;
      caption?: StringNullableFilter<"Screenshot"> | string | null;
      game?: XOR<GameScalarRelationFilter, GameWhereInput>;
    },
    "id"
  >;

  export type ScreenshotOrderByWithAggregationInput = {
    id?: SortOrder;
    gameId?: SortOrder;
    imageUrl?: SortOrder;
    caption?: SortOrderInput | SortOrder;
    _count?: ScreenshotCountOrderByAggregateInput;
    _max?: ScreenshotMaxOrderByAggregateInput;
    _min?: ScreenshotMinOrderByAggregateInput;
  };

  export type ScreenshotScalarWhereWithAggregatesInput = {
    AND?:
      | ScreenshotScalarWhereWithAggregatesInput
      | ScreenshotScalarWhereWithAggregatesInput[];
    OR?: ScreenshotScalarWhereWithAggregatesInput[];
    NOT?:
      | ScreenshotScalarWhereWithAggregatesInput
      | ScreenshotScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Screenshot"> | string;
    gameId?: StringWithAggregatesFilter<"Screenshot"> | string;
    imageUrl?: StringWithAggregatesFilter<"Screenshot"> | string;
    caption?: StringNullableWithAggregatesFilter<"Screenshot"> | string | null;
  };

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[];
    OR?: ReviewWhereInput[];
    NOT?: ReviewWhereInput | ReviewWhereInput[];
    id?: StringFilter<"Review"> | string;
    rating?: FloatFilter<"Review"> | number;
    comment?: StringNullableFilter<"Review"> | string | null;
    createdAt?: DateTimeFilter<"Review"> | Date | string;
    userId?: StringFilter<"Review"> | string;
    gameId?: StringFilter<"Review"> | string;
    game?: XOR<GameScalarRelationFilter, GameWhereInput>;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder;
    rating?: SortOrder;
    comment?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    userId?: SortOrder;
    gameId?: SortOrder;
    game?: GameOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
  };

  export type ReviewWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId_gameId?: ReviewUserIdGameIdCompoundUniqueInput;
      AND?: ReviewWhereInput | ReviewWhereInput[];
      OR?: ReviewWhereInput[];
      NOT?: ReviewWhereInput | ReviewWhereInput[];
      rating?: FloatFilter<"Review"> | number;
      comment?: StringNullableFilter<"Review"> | string | null;
      createdAt?: DateTimeFilter<"Review"> | Date | string;
      userId?: StringFilter<"Review"> | string;
      gameId?: StringFilter<"Review"> | string;
      game?: XOR<GameScalarRelationFilter, GameWhereInput>;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "userId_gameId"
  >;

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder;
    rating?: SortOrder;
    comment?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    userId?: SortOrder;
    gameId?: SortOrder;
    _count?: ReviewCountOrderByAggregateInput;
    _avg?: ReviewAvgOrderByAggregateInput;
    _max?: ReviewMaxOrderByAggregateInput;
    _min?: ReviewMinOrderByAggregateInput;
    _sum?: ReviewSumOrderByAggregateInput;
  };

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?:
      | ReviewScalarWhereWithAggregatesInput
      | ReviewScalarWhereWithAggregatesInput[];
    OR?: ReviewScalarWhereWithAggregatesInput[];
    NOT?:
      | ReviewScalarWhereWithAggregatesInput
      | ReviewScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Review"> | string;
    rating?: FloatWithAggregatesFilter<"Review"> | number;
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string;
    userId?: StringWithAggregatesFilter<"Review"> | string;
    gameId?: StringWithAggregatesFilter<"Review"> | string;
  };

  export type CartWhereInput = {
    AND?: CartWhereInput | CartWhereInput[];
    OR?: CartWhereInput[];
    NOT?: CartWhereInput | CartWhereInput[];
    id?: StringFilter<"Cart"> | string;
    userId?: StringFilter<"Cart"> | string;
    createdAt?: DateTimeFilter<"Cart"> | Date | string;
    updatedAt?: DateTimeFilter<"Cart"> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    items?: CartItemListRelationFilter;
  };

  export type CartOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    items?: CartItemOrderByRelationAggregateInput;
  };

  export type CartWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId?: string;
      AND?: CartWhereInput | CartWhereInput[];
      OR?: CartWhereInput[];
      NOT?: CartWhereInput | CartWhereInput[];
      createdAt?: DateTimeFilter<"Cart"> | Date | string;
      updatedAt?: DateTimeFilter<"Cart"> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      items?: CartItemListRelationFilter;
    },
    "id" | "userId"
  >;

  export type CartOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: CartCountOrderByAggregateInput;
    _max?: CartMaxOrderByAggregateInput;
    _min?: CartMinOrderByAggregateInput;
  };

  export type CartScalarWhereWithAggregatesInput = {
    AND?:
      | CartScalarWhereWithAggregatesInput
      | CartScalarWhereWithAggregatesInput[];
    OR?: CartScalarWhereWithAggregatesInput[];
    NOT?:
      | CartScalarWhereWithAggregatesInput
      | CartScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Cart"> | string;
    userId?: StringWithAggregatesFilter<"Cart"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string;
  };

  export type CartItemWhereInput = {
    AND?: CartItemWhereInput | CartItemWhereInput[];
    OR?: CartItemWhereInput[];
    NOT?: CartItemWhereInput | CartItemWhereInput[];
    id?: StringFilter<"CartItem"> | string;
    cartId?: StringFilter<"CartItem"> | string;
    gameId?: StringFilter<"CartItem"> | string;
    quantity?: IntFilter<"CartItem"> | number;
    addedAt?: DateTimeFilter<"CartItem"> | Date | string;
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>;
    game?: XOR<GameScalarRelationFilter, GameWhereInput>;
  };

  export type CartItemOrderByWithRelationInput = {
    id?: SortOrder;
    cartId?: SortOrder;
    gameId?: SortOrder;
    quantity?: SortOrder;
    addedAt?: SortOrder;
    cart?: CartOrderByWithRelationInput;
    game?: GameOrderByWithRelationInput;
  };

  export type CartItemWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      cartId_gameId?: CartItemCartIdGameIdCompoundUniqueInput;
      AND?: CartItemWhereInput | CartItemWhereInput[];
      OR?: CartItemWhereInput[];
      NOT?: CartItemWhereInput | CartItemWhereInput[];
      cartId?: StringFilter<"CartItem"> | string;
      gameId?: StringFilter<"CartItem"> | string;
      quantity?: IntFilter<"CartItem"> | number;
      addedAt?: DateTimeFilter<"CartItem"> | Date | string;
      cart?: XOR<CartScalarRelationFilter, CartWhereInput>;
      game?: XOR<GameScalarRelationFilter, GameWhereInput>;
    },
    "id" | "cartId_gameId"
  >;

  export type CartItemOrderByWithAggregationInput = {
    id?: SortOrder;
    cartId?: SortOrder;
    gameId?: SortOrder;
    quantity?: SortOrder;
    addedAt?: SortOrder;
    _count?: CartItemCountOrderByAggregateInput;
    _avg?: CartItemAvgOrderByAggregateInput;
    _max?: CartItemMaxOrderByAggregateInput;
    _min?: CartItemMinOrderByAggregateInput;
    _sum?: CartItemSumOrderByAggregateInput;
  };

  export type CartItemScalarWhereWithAggregatesInput = {
    AND?:
      | CartItemScalarWhereWithAggregatesInput
      | CartItemScalarWhereWithAggregatesInput[];
    OR?: CartItemScalarWhereWithAggregatesInput[];
    NOT?:
      | CartItemScalarWhereWithAggregatesInput
      | CartItemScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"CartItem"> | string;
    cartId?: StringWithAggregatesFilter<"CartItem"> | string;
    gameId?: StringWithAggregatesFilter<"CartItem"> | string;
    quantity?: IntWithAggregatesFilter<"CartItem"> | number;
    addedAt?: DateTimeWithAggregatesFilter<"CartItem"> | Date | string;
  };

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[];
    OR?: OrderWhereInput[];
    NOT?: OrderWhereInput | OrderWhereInput[];
    id?: StringFilter<"Order"> | string;
    userId?: StringFilter<"Order"> | string;
    totalAmount?: FloatFilter<"Order"> | number;
    status?: StringFilter<"Order"> | string;
    createdAt?: DateTimeFilter<"Order"> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    items?: OrderItemListRelationFilter;
  };

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    totalAmount?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    items?: OrderItemOrderByRelationAggregateInput;
  };

  export type OrderWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: OrderWhereInput | OrderWhereInput[];
      OR?: OrderWhereInput[];
      NOT?: OrderWhereInput | OrderWhereInput[];
      userId?: StringFilter<"Order"> | string;
      totalAmount?: FloatFilter<"Order"> | number;
      status?: StringFilter<"Order"> | string;
      createdAt?: DateTimeFilter<"Order"> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      items?: OrderItemListRelationFilter;
    },
    "id"
  >;

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    totalAmount?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    _count?: OrderCountOrderByAggregateInput;
    _avg?: OrderAvgOrderByAggregateInput;
    _max?: OrderMaxOrderByAggregateInput;
    _min?: OrderMinOrderByAggregateInput;
    _sum?: OrderSumOrderByAggregateInput;
  };

  export type OrderScalarWhereWithAggregatesInput = {
    AND?:
      | OrderScalarWhereWithAggregatesInput
      | OrderScalarWhereWithAggregatesInput[];
    OR?: OrderScalarWhereWithAggregatesInput[];
    NOT?:
      | OrderScalarWhereWithAggregatesInput
      | OrderScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Order"> | string;
    userId?: StringWithAggregatesFilter<"Order"> | string;
    totalAmount?: FloatWithAggregatesFilter<"Order"> | number;
    status?: StringWithAggregatesFilter<"Order"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string;
  };

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[];
    OR?: OrderItemWhereInput[];
    NOT?: OrderItemWhereInput | OrderItemWhereInput[];
    id?: StringFilter<"OrderItem"> | string;
    orderId?: StringFilter<"OrderItem"> | string;
    gameId?: StringFilter<"OrderItem"> | string;
    price?: FloatFilter<"OrderItem"> | number;
    quantity?: IntFilter<"OrderItem"> | number;
    game?: XOR<GameScalarRelationFilter, GameWhereInput>;
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>;
  };

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    gameId?: SortOrder;
    price?: SortOrder;
    quantity?: SortOrder;
    game?: GameOrderByWithRelationInput;
    order?: OrderOrderByWithRelationInput;
  };

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: OrderItemWhereInput | OrderItemWhereInput[];
      OR?: OrderItemWhereInput[];
      NOT?: OrderItemWhereInput | OrderItemWhereInput[];
      orderId?: StringFilter<"OrderItem"> | string;
      gameId?: StringFilter<"OrderItem"> | string;
      price?: FloatFilter<"OrderItem"> | number;
      quantity?: IntFilter<"OrderItem"> | number;
      game?: XOR<GameScalarRelationFilter, GameWhereInput>;
      order?: XOR<OrderScalarRelationFilter, OrderWhereInput>;
    },
    "id"
  >;

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    gameId?: SortOrder;
    price?: SortOrder;
    quantity?: SortOrder;
    _count?: OrderItemCountOrderByAggregateInput;
    _avg?: OrderItemAvgOrderByAggregateInput;
    _max?: OrderItemMaxOrderByAggregateInput;
    _min?: OrderItemMinOrderByAggregateInput;
    _sum?: OrderItemSumOrderByAggregateInput;
  };

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?:
      | OrderItemScalarWhereWithAggregatesInput
      | OrderItemScalarWhereWithAggregatesInput[];
    OR?: OrderItemScalarWhereWithAggregatesInput[];
    NOT?:
      | OrderItemScalarWhereWithAggregatesInput
      | OrderItemScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"OrderItem"> | string;
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string;
    gameId?: StringWithAggregatesFilter<"OrderItem"> | string;
    price?: FloatWithAggregatesFilter<"OrderItem"> | number;
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number;
  };

  export type FeaturedGameWhereInput = {
    AND?: FeaturedGameWhereInput | FeaturedGameWhereInput[];
    OR?: FeaturedGameWhereInput[];
    NOT?: FeaturedGameWhereInput | FeaturedGameWhereInput[];
    id?: StringFilter<"FeaturedGame"> | string;
    gameId?: StringFilter<"FeaturedGame"> | string;
    startDate?: DateTimeFilter<"FeaturedGame"> | Date | string;
    endDate?: DateTimeFilter<"FeaturedGame"> | Date | string;
    priority?: IntFilter<"FeaturedGame"> | number;
    createdAt?: DateTimeFilter<"FeaturedGame"> | Date | string;
    game?: XOR<GameScalarRelationFilter, GameWhereInput>;
  };

  export type FeaturedGameOrderByWithRelationInput = {
    id?: SortOrder;
    gameId?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    priority?: SortOrder;
    createdAt?: SortOrder;
    game?: GameOrderByWithRelationInput;
  };

  export type FeaturedGameWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: FeaturedGameWhereInput | FeaturedGameWhereInput[];
      OR?: FeaturedGameWhereInput[];
      NOT?: FeaturedGameWhereInput | FeaturedGameWhereInput[];
      gameId?: StringFilter<"FeaturedGame"> | string;
      startDate?: DateTimeFilter<"FeaturedGame"> | Date | string;
      endDate?: DateTimeFilter<"FeaturedGame"> | Date | string;
      priority?: IntFilter<"FeaturedGame"> | number;
      createdAt?: DateTimeFilter<"FeaturedGame"> | Date | string;
      game?: XOR<GameScalarRelationFilter, GameWhereInput>;
    },
    "id"
  >;

  export type FeaturedGameOrderByWithAggregationInput = {
    id?: SortOrder;
    gameId?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    priority?: SortOrder;
    createdAt?: SortOrder;
    _count?: FeaturedGameCountOrderByAggregateInput;
    _avg?: FeaturedGameAvgOrderByAggregateInput;
    _max?: FeaturedGameMaxOrderByAggregateInput;
    _min?: FeaturedGameMinOrderByAggregateInput;
    _sum?: FeaturedGameSumOrderByAggregateInput;
  };

  export type FeaturedGameScalarWhereWithAggregatesInput = {
    AND?:
      | FeaturedGameScalarWhereWithAggregatesInput
      | FeaturedGameScalarWhereWithAggregatesInput[];
    OR?: FeaturedGameScalarWhereWithAggregatesInput[];
    NOT?:
      | FeaturedGameScalarWhereWithAggregatesInput
      | FeaturedGameScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"FeaturedGame"> | string;
    gameId?: StringWithAggregatesFilter<"FeaturedGame"> | string;
    startDate?: DateTimeWithAggregatesFilter<"FeaturedGame"> | Date | string;
    endDate?: DateTimeWithAggregatesFilter<"FeaturedGame"> | Date | string;
    priority?: IntWithAggregatesFilter<"FeaturedGame"> | number;
    createdAt?: DateTimeWithAggregatesFilter<"FeaturedGame"> | Date | string;
  };

  export type RecommendedGameWhereInput = {
    AND?: RecommendedGameWhereInput | RecommendedGameWhereInput[];
    OR?: RecommendedGameWhereInput[];
    NOT?: RecommendedGameWhereInput | RecommendedGameWhereInput[];
    id?: StringFilter<"RecommendedGame"> | string;
    gameId?: StringFilter<"RecommendedGame"> | string;
    recommendationType?:
      | EnumRecommendationTypeFilter<"RecommendedGame">
      | $Enums.RecommendationType;
    relatedGameId?: StringNullableFilter<"RecommendedGame"> | string | null;
    startDate?: DateTimeFilter<"RecommendedGame"> | Date | string;
    endDate?: DateTimeNullableFilter<"RecommendedGame"> | Date | string | null;
    priority?: IntFilter<"RecommendedGame"> | number;
    createdAt?: DateTimeFilter<"RecommendedGame"> | Date | string;
    game?: XOR<GameScalarRelationFilter, GameWhereInput>;
    relatedGame?: XOR<GameNullableScalarRelationFilter, GameWhereInput> | null;
  };

  export type RecommendedGameOrderByWithRelationInput = {
    id?: SortOrder;
    gameId?: SortOrder;
    recommendationType?: SortOrder;
    relatedGameId?: SortOrderInput | SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrderInput | SortOrder;
    priority?: SortOrder;
    createdAt?: SortOrder;
    game?: GameOrderByWithRelationInput;
    relatedGame?: GameOrderByWithRelationInput;
  };

  export type RecommendedGameWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: RecommendedGameWhereInput | RecommendedGameWhereInput[];
      OR?: RecommendedGameWhereInput[];
      NOT?: RecommendedGameWhereInput | RecommendedGameWhereInput[];
      gameId?: StringFilter<"RecommendedGame"> | string;
      recommendationType?:
        | EnumRecommendationTypeFilter<"RecommendedGame">
        | $Enums.RecommendationType;
      relatedGameId?: StringNullableFilter<"RecommendedGame"> | string | null;
      startDate?: DateTimeFilter<"RecommendedGame"> | Date | string;
      endDate?:
        | DateTimeNullableFilter<"RecommendedGame">
        | Date
        | string
        | null;
      priority?: IntFilter<"RecommendedGame"> | number;
      createdAt?: DateTimeFilter<"RecommendedGame"> | Date | string;
      game?: XOR<GameScalarRelationFilter, GameWhereInput>;
      relatedGame?: XOR<
        GameNullableScalarRelationFilter,
        GameWhereInput
      > | null;
    },
    "id"
  >;

  export type RecommendedGameOrderByWithAggregationInput = {
    id?: SortOrder;
    gameId?: SortOrder;
    recommendationType?: SortOrder;
    relatedGameId?: SortOrderInput | SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrderInput | SortOrder;
    priority?: SortOrder;
    createdAt?: SortOrder;
    _count?: RecommendedGameCountOrderByAggregateInput;
    _avg?: RecommendedGameAvgOrderByAggregateInput;
    _max?: RecommendedGameMaxOrderByAggregateInput;
    _min?: RecommendedGameMinOrderByAggregateInput;
    _sum?: RecommendedGameSumOrderByAggregateInput;
  };

  export type RecommendedGameScalarWhereWithAggregatesInput = {
    AND?:
      | RecommendedGameScalarWhereWithAggregatesInput
      | RecommendedGameScalarWhereWithAggregatesInput[];
    OR?: RecommendedGameScalarWhereWithAggregatesInput[];
    NOT?:
      | RecommendedGameScalarWhereWithAggregatesInput
      | RecommendedGameScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"RecommendedGame"> | string;
    gameId?: StringWithAggregatesFilter<"RecommendedGame"> | string;
    recommendationType?:
      | EnumRecommendationTypeWithAggregatesFilter<"RecommendedGame">
      | $Enums.RecommendationType;
    relatedGameId?:
      | StringNullableWithAggregatesFilter<"RecommendedGame">
      | string
      | null;
    startDate?: DateTimeWithAggregatesFilter<"RecommendedGame"> | Date | string;
    endDate?:
      | DateTimeNullableWithAggregatesFilter<"RecommendedGame">
      | Date
      | string
      | null;
    priority?: IntWithAggregatesFilter<"RecommendedGame"> | number;
    createdAt?: DateTimeWithAggregatesFilter<"RecommendedGame"> | Date | string;
  };

  export type UserCreateInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    address?: string | null;
    phone?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    cart?: CartCreateNestedOneWithoutUserInput;
    orders?: OrderCreateNestedManyWithoutUserInput;
    reviews?: ReviewCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    address?: string | null;
    phone?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    cart?: CartUncheckedCreateNestedOneWithoutUserInput;
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    cart?: CartUpdateOneWithoutUserNestedInput;
    orders?: OrderUpdateManyWithoutUserNestedInput;
    reviews?: ReviewUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    cart?: CartUncheckedUpdateOneWithoutUserNestedInput;
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateManyInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    address?: string | null;
    phone?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AccountCreateInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
    user: UserCreateNestedOneWithoutAccountsInput;
  };

  export type AccountUncheckedCreateInput = {
    id?: string;
    userId: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput;
  };

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountCreateManyInput = {
    id?: string;
    userId: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SessionCreateInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
    user: UserCreateNestedOneWithoutSessionsInput;
  };

  export type SessionUncheckedCreateInput = {
    id?: string;
    sessionToken: string;
    userId: string;
    expires: Date | string;
  };

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput;
  };

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionCreateManyInput = {
    id?: string;
    sessionToken: string;
    userId: string;
    expires: Date | string;
  };

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenCreateInput = {
    identifier: string;
    token: string;
    expires: Date | string;
  };

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string;
    token: string;
    expires: Date | string;
  };

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenCreateManyInput = {
    identifier: string;
    token: string;
    expires: Date | string;
  };

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type GameCreateInput = {
    id?: string;
    title: string;
    description: string;
    price: number;
    releaseDate: Date | string;
    developer: string;
    publisher: string;
    coverImageUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    rating?: number;
    discountedPrice?: number | null;
    status?: $Enums.GameStatus;
    cartItems?: CartItemCreateNestedManyWithoutGameInput;
    genres?: GameGenreCreateNestedManyWithoutGameInput;
    orderItems?: OrderItemCreateNestedManyWithoutGameInput;
    reviews?: ReviewCreateNestedManyWithoutGameInput;
    screenshots?: ScreenshotCreateNestedManyWithoutGameInput;
    featuredGames?: FeaturedGameCreateNestedManyWithoutGameInput;
    recommendedMain?: RecommendedGameCreateNestedManyWithoutGameInput;
    recommendedRel?: RecommendedGameCreateNestedManyWithoutRelatedGameInput;
  };

  export type GameUncheckedCreateInput = {
    id?: string;
    title: string;
    description: string;
    price: number;
    releaseDate: Date | string;
    developer: string;
    publisher: string;
    coverImageUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    rating?: number;
    discountedPrice?: number | null;
    status?: $Enums.GameStatus;
    cartItems?: CartItemUncheckedCreateNestedManyWithoutGameInput;
    genres?: GameGenreUncheckedCreateNestedManyWithoutGameInput;
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutGameInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutGameInput;
    screenshots?: ScreenshotUncheckedCreateNestedManyWithoutGameInput;
    featuredGames?: FeaturedGameUncheckedCreateNestedManyWithoutGameInput;
    recommendedMain?: RecommendedGameUncheckedCreateNestedManyWithoutGameInput;
    recommendedRel?: RecommendedGameUncheckedCreateNestedManyWithoutRelatedGameInput;
  };

  export type GameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    developer?: StringFieldUpdateOperationsInput | string;
    publisher?: StringFieldUpdateOperationsInput | string;
    coverImageUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus;
    cartItems?: CartItemUpdateManyWithoutGameNestedInput;
    genres?: GameGenreUpdateManyWithoutGameNestedInput;
    orderItems?: OrderItemUpdateManyWithoutGameNestedInput;
    reviews?: ReviewUpdateManyWithoutGameNestedInput;
    screenshots?: ScreenshotUpdateManyWithoutGameNestedInput;
    featuredGames?: FeaturedGameUpdateManyWithoutGameNestedInput;
    recommendedMain?: RecommendedGameUpdateManyWithoutGameNestedInput;
    recommendedRel?: RecommendedGameUpdateManyWithoutRelatedGameNestedInput;
  };

  export type GameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    developer?: StringFieldUpdateOperationsInput | string;
    publisher?: StringFieldUpdateOperationsInput | string;
    coverImageUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus;
    cartItems?: CartItemUncheckedUpdateManyWithoutGameNestedInput;
    genres?: GameGenreUncheckedUpdateManyWithoutGameNestedInput;
    orderItems?: OrderItemUncheckedUpdateManyWithoutGameNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutGameNestedInput;
    screenshots?: ScreenshotUncheckedUpdateManyWithoutGameNestedInput;
    featuredGames?: FeaturedGameUncheckedUpdateManyWithoutGameNestedInput;
    recommendedMain?: RecommendedGameUncheckedUpdateManyWithoutGameNestedInput;
    recommendedRel?: RecommendedGameUncheckedUpdateManyWithoutRelatedGameNestedInput;
  };

  export type GameCreateManyInput = {
    id?: string;
    title: string;
    description: string;
    price: number;
    releaseDate: Date | string;
    developer: string;
    publisher: string;
    coverImageUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    rating?: number;
    discountedPrice?: number | null;
    status?: $Enums.GameStatus;
  };

  export type GameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    developer?: StringFieldUpdateOperationsInput | string;
    publisher?: StringFieldUpdateOperationsInput | string;
    coverImageUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus;
  };

  export type GameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    developer?: StringFieldUpdateOperationsInput | string;
    publisher?: StringFieldUpdateOperationsInput | string;
    coverImageUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus;
  };

  export type GenreCreateInput = {
    id?: string;
    name: string;
    games?: GameGenreCreateNestedManyWithoutGenreInput;
    parent?: GenreCreateNestedOneWithoutSubGenresInput;
    subGenres?: GenreCreateNestedManyWithoutParentInput;
  };

  export type GenreUncheckedCreateInput = {
    id?: string;
    name: string;
    parentId?: string | null;
    games?: GameGenreUncheckedCreateNestedManyWithoutGenreInput;
    subGenres?: GenreUncheckedCreateNestedManyWithoutParentInput;
  };

  export type GenreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    games?: GameGenreUpdateManyWithoutGenreNestedInput;
    parent?: GenreUpdateOneWithoutSubGenresNestedInput;
    subGenres?: GenreUpdateManyWithoutParentNestedInput;
  };

  export type GenreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    games?: GameGenreUncheckedUpdateManyWithoutGenreNestedInput;
    subGenres?: GenreUncheckedUpdateManyWithoutParentNestedInput;
  };

  export type GenreCreateManyInput = {
    id?: string;
    name: string;
    parentId?: string | null;
  };

  export type GenreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
  };

  export type GenreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type GameGenreCreateInput = {
    game: GameCreateNestedOneWithoutGenresInput;
    genre: GenreCreateNestedOneWithoutGamesInput;
  };

  export type GameGenreUncheckedCreateInput = {
    gameId: string;
    genreId: string;
  };

  export type GameGenreUpdateInput = {
    game?: GameUpdateOneRequiredWithoutGenresNestedInput;
    genre?: GenreUpdateOneRequiredWithoutGamesNestedInput;
  };

  export type GameGenreUncheckedUpdateInput = {
    gameId?: StringFieldUpdateOperationsInput | string;
    genreId?: StringFieldUpdateOperationsInput | string;
  };

  export type GameGenreCreateManyInput = {
    gameId: string;
    genreId: string;
  };

  export type GameGenreUpdateManyMutationInput = {};

  export type GameGenreUncheckedUpdateManyInput = {
    gameId?: StringFieldUpdateOperationsInput | string;
    genreId?: StringFieldUpdateOperationsInput | string;
  };

  export type ScreenshotCreateInput = {
    id?: string;
    imageUrl: string;
    caption?: string | null;
    game: GameCreateNestedOneWithoutScreenshotsInput;
  };

  export type ScreenshotUncheckedCreateInput = {
    id?: string;
    gameId: string;
    imageUrl: string;
    caption?: string | null;
  };

  export type ScreenshotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    imageUrl?: StringFieldUpdateOperationsInput | string;
    caption?: NullableStringFieldUpdateOperationsInput | string | null;
    game?: GameUpdateOneRequiredWithoutScreenshotsNestedInput;
  };

  export type ScreenshotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    gameId?: StringFieldUpdateOperationsInput | string;
    imageUrl?: StringFieldUpdateOperationsInput | string;
    caption?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ScreenshotCreateManyInput = {
    id?: string;
    gameId: string;
    imageUrl: string;
    caption?: string | null;
  };

  export type ScreenshotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    imageUrl?: StringFieldUpdateOperationsInput | string;
    caption?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ScreenshotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    gameId?: StringFieldUpdateOperationsInput | string;
    imageUrl?: StringFieldUpdateOperationsInput | string;
    caption?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ReviewCreateInput = {
    id?: string;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    game: GameCreateNestedOneWithoutReviewsInput;
    user: UserCreateNestedOneWithoutReviewsInput;
  };

  export type ReviewUncheckedCreateInput = {
    id?: string;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    userId: string;
    gameId: string;
  };

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    game?: GameUpdateOneRequiredWithoutReviewsNestedInput;
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput;
  };

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
    gameId?: StringFieldUpdateOperationsInput | string;
  };

  export type ReviewCreateManyInput = {
    id?: string;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    userId: string;
    gameId: string;
  };

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
    gameId?: StringFieldUpdateOperationsInput | string;
  };

  export type CartCreateInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutCartInput;
    items?: CartItemCreateNestedManyWithoutCartInput;
  };

  export type CartUncheckedCreateInput = {
    id?: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput;
  };

  export type CartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutCartNestedInput;
    items?: CartItemUpdateManyWithoutCartNestedInput;
  };

  export type CartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput;
  };

  export type CartCreateManyInput = {
    id?: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CartItemCreateInput = {
    id?: string;
    quantity?: number;
    addedAt?: Date | string;
    cart: CartCreateNestedOneWithoutItemsInput;
    game: GameCreateNestedOneWithoutCartItemsInput;
  };

  export type CartItemUncheckedCreateInput = {
    id?: string;
    cartId: string;
    gameId: string;
    quantity?: number;
    addedAt?: Date | string;
  };

  export type CartItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    cart?: CartUpdateOneRequiredWithoutItemsNestedInput;
    game?: GameUpdateOneRequiredWithoutCartItemsNestedInput;
  };

  export type CartItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    cartId?: StringFieldUpdateOperationsInput | string;
    gameId?: StringFieldUpdateOperationsInput | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CartItemCreateManyInput = {
    id?: string;
    cartId: string;
    gameId: string;
    quantity?: number;
    addedAt?: Date | string;
  };

  export type CartItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CartItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    cartId?: StringFieldUpdateOperationsInput | string;
    gameId?: StringFieldUpdateOperationsInput | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderCreateInput = {
    id?: string;
    totalAmount: number;
    status?: string;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutOrdersInput;
    items?: OrderItemCreateNestedManyWithoutOrderInput;
  };

  export type OrderUncheckedCreateInput = {
    id?: string;
    userId: string;
    totalAmount: number;
    status?: string;
    createdAt?: Date | string;
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput;
  };

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    totalAmount?: FloatFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput;
    items?: OrderItemUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    totalAmount?: FloatFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput;
  };

  export type OrderCreateManyInput = {
    id?: string;
    userId: string;
    totalAmount: number;
    status?: string;
    createdAt?: Date | string;
  };

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    totalAmount?: FloatFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    totalAmount?: FloatFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderItemCreateInput = {
    id?: string;
    price: number;
    quantity: number;
    game: GameCreateNestedOneWithoutOrderItemsInput;
    order: OrderCreateNestedOneWithoutItemsInput;
  };

  export type OrderItemUncheckedCreateInput = {
    id?: string;
    orderId: string;
    gameId: string;
    price: number;
    quantity: number;
  };

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    quantity?: IntFieldUpdateOperationsInput | number;
    game?: GameUpdateOneRequiredWithoutOrderItemsNestedInput;
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput;
  };

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orderId?: StringFieldUpdateOperationsInput | string;
    gameId?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    quantity?: IntFieldUpdateOperationsInput | number;
  };

  export type OrderItemCreateManyInput = {
    id?: string;
    orderId: string;
    gameId: string;
    price: number;
    quantity: number;
  };

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    quantity?: IntFieldUpdateOperationsInput | number;
  };

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orderId?: StringFieldUpdateOperationsInput | string;
    gameId?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    quantity?: IntFieldUpdateOperationsInput | number;
  };

  export type FeaturedGameCreateInput = {
    id?: string;
    startDate: Date | string;
    endDate: Date | string;
    priority?: number;
    createdAt?: Date | string;
    game: GameCreateNestedOneWithoutFeaturedGamesInput;
  };

  export type FeaturedGameUncheckedCreateInput = {
    id?: string;
    gameId: string;
    startDate: Date | string;
    endDate: Date | string;
    priority?: number;
    createdAt?: Date | string;
  };

  export type FeaturedGameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    priority?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    game?: GameUpdateOneRequiredWithoutFeaturedGamesNestedInput;
  };

  export type FeaturedGameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    gameId?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    priority?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FeaturedGameCreateManyInput = {
    id?: string;
    gameId: string;
    startDate: Date | string;
    endDate: Date | string;
    priority?: number;
    createdAt?: Date | string;
  };

  export type FeaturedGameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    priority?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FeaturedGameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    gameId?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    priority?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RecommendedGameCreateInput = {
    id?: string;
    recommendationType: $Enums.RecommendationType;
    startDate: Date | string;
    endDate?: Date | string | null;
    priority?: number;
    createdAt?: Date | string;
    game: GameCreateNestedOneWithoutRecommendedMainInput;
    relatedGame?: GameCreateNestedOneWithoutRecommendedRelInput;
  };

  export type RecommendedGameUncheckedCreateInput = {
    id?: string;
    gameId: string;
    recommendationType: $Enums.RecommendationType;
    relatedGameId?: string | null;
    startDate: Date | string;
    endDate?: Date | string | null;
    priority?: number;
    createdAt?: Date | string;
  };

  export type RecommendedGameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    recommendationType?:
      | EnumRecommendationTypeFieldUpdateOperationsInput
      | $Enums.RecommendationType;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    priority?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    game?: GameUpdateOneRequiredWithoutRecommendedMainNestedInput;
    relatedGame?: GameUpdateOneWithoutRecommendedRelNestedInput;
  };

  export type RecommendedGameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    gameId?: StringFieldUpdateOperationsInput | string;
    recommendationType?:
      | EnumRecommendationTypeFieldUpdateOperationsInput
      | $Enums.RecommendationType;
    relatedGameId?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    priority?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RecommendedGameCreateManyInput = {
    id?: string;
    gameId: string;
    recommendationType: $Enums.RecommendationType;
    relatedGameId?: string | null;
    startDate: Date | string;
    endDate?: Date | string | null;
    priority?: number;
    createdAt?: Date | string;
  };

  export type RecommendedGameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    recommendationType?:
      | EnumRecommendationTypeFieldUpdateOperationsInput
      | $Enums.RecommendationType;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    priority?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RecommendedGameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    gameId?: StringFieldUpdateOperationsInput | string;
    recommendationType?:
      | EnumRecommendationTypeFieldUpdateOperationsInput
      | $Enums.RecommendationType;
    relatedGameId?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    priority?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type AccountListRelationFilter = {
    every?: AccountWhereInput;
    some?: AccountWhereInput;
    none?: AccountWhereInput;
  };

  export type SessionListRelationFilter = {
    every?: SessionWhereInput;
    some?: SessionWhereInput;
    none?: SessionWhereInput;
  };

  export type CartNullableScalarRelationFilter = {
    is?: CartWhereInput | null;
    isNot?: CartWhereInput | null;
  };

  export type OrderListRelationFilter = {
    every?: OrderWhereInput;
    some?: OrderWhereInput;
    none?: OrderWhereInput;
  };

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput;
    some?: ReviewWhereInput;
    none?: ReviewWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    image?: SortOrder;
    password?: SortOrder;
    address?: SortOrder;
    phone?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    image?: SortOrder;
    password?: SortOrder;
    address?: SortOrder;
    phone?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    image?: SortOrder;
    password?: SortOrder;
    address?: SortOrder;
    phone?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?:
      | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
      | Date
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type UserScalarRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string;
    providerAccountId: string;
  };

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
  };

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder;
  };

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
  };

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
  };

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
  };

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
  };

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
  };

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string;
    token: string;
  };

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type EnumGameStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumGameStatusFilter<$PrismaModel> | $Enums.GameStatus;
  };

  export type CartItemListRelationFilter = {
    every?: CartItemWhereInput;
    some?: CartItemWhereInput;
    none?: CartItemWhereInput;
  };

  export type GameGenreListRelationFilter = {
    every?: GameGenreWhereInput;
    some?: GameGenreWhereInput;
    none?: GameGenreWhereInput;
  };

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput;
    some?: OrderItemWhereInput;
    none?: OrderItemWhereInput;
  };

  export type ScreenshotListRelationFilter = {
    every?: ScreenshotWhereInput;
    some?: ScreenshotWhereInput;
    none?: ScreenshotWhereInput;
  };

  export type FeaturedGameListRelationFilter = {
    every?: FeaturedGameWhereInput;
    some?: FeaturedGameWhereInput;
    none?: FeaturedGameWhereInput;
  };

  export type RecommendedGameListRelationFilter = {
    every?: RecommendedGameWhereInput;
    some?: RecommendedGameWhereInput;
    none?: RecommendedGameWhereInput;
  };

  export type CartItemOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type GameGenreOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ScreenshotOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type FeaturedGameOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type RecommendedGameOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type GameCountOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    price?: SortOrder;
    releaseDate?: SortOrder;
    developer?: SortOrder;
    publisher?: SortOrder;
    coverImageUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    rating?: SortOrder;
    discountedPrice?: SortOrder;
    status?: SortOrder;
  };

  export type GameAvgOrderByAggregateInput = {
    price?: SortOrder;
    rating?: SortOrder;
    discountedPrice?: SortOrder;
  };

  export type GameMaxOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    price?: SortOrder;
    releaseDate?: SortOrder;
    developer?: SortOrder;
    publisher?: SortOrder;
    coverImageUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    rating?: SortOrder;
    discountedPrice?: SortOrder;
    status?: SortOrder;
  };

  export type GameMinOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    price?: SortOrder;
    releaseDate?: SortOrder;
    developer?: SortOrder;
    publisher?: SortOrder;
    coverImageUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    rating?: SortOrder;
    discountedPrice?: SortOrder;
    status?: SortOrder;
  };

  export type GameSumOrderByAggregateInput = {
    price?: SortOrder;
    rating?: SortOrder;
    discountedPrice?: SortOrder;
  };

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type EnumGameStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumGameStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.GameStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumGameStatusFilter<$PrismaModel>;
    _max?: NestedEnumGameStatusFilter<$PrismaModel>;
  };

  export type GenreNullableScalarRelationFilter = {
    is?: GenreWhereInput | null;
    isNot?: GenreWhereInput | null;
  };

  export type GenreListRelationFilter = {
    every?: GenreWhereInput;
    some?: GenreWhereInput;
    none?: GenreWhereInput;
  };

  export type GenreOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type GenreCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    parentId?: SortOrder;
  };

  export type GenreMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    parentId?: SortOrder;
  };

  export type GenreMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    parentId?: SortOrder;
  };

  export type GameScalarRelationFilter = {
    is?: GameWhereInput;
    isNot?: GameWhereInput;
  };

  export type GenreScalarRelationFilter = {
    is?: GenreWhereInput;
    isNot?: GenreWhereInput;
  };

  export type GameGenreGameIdGenreIdCompoundUniqueInput = {
    gameId: string;
    genreId: string;
  };

  export type GameGenreCountOrderByAggregateInput = {
    gameId?: SortOrder;
    genreId?: SortOrder;
  };

  export type GameGenreMaxOrderByAggregateInput = {
    gameId?: SortOrder;
    genreId?: SortOrder;
  };

  export type GameGenreMinOrderByAggregateInput = {
    gameId?: SortOrder;
    genreId?: SortOrder;
  };

  export type ScreenshotCountOrderByAggregateInput = {
    id?: SortOrder;
    gameId?: SortOrder;
    imageUrl?: SortOrder;
    caption?: SortOrder;
  };

  export type ScreenshotMaxOrderByAggregateInput = {
    id?: SortOrder;
    gameId?: SortOrder;
    imageUrl?: SortOrder;
    caption?: SortOrder;
  };

  export type ScreenshotMinOrderByAggregateInput = {
    id?: SortOrder;
    gameId?: SortOrder;
    imageUrl?: SortOrder;
    caption?: SortOrder;
  };

  export type ReviewUserIdGameIdCompoundUniqueInput = {
    userId: string;
    gameId: string;
  };

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder;
    rating?: SortOrder;
    comment?: SortOrder;
    createdAt?: SortOrder;
    userId?: SortOrder;
    gameId?: SortOrder;
  };

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder;
  };

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder;
    rating?: SortOrder;
    comment?: SortOrder;
    createdAt?: SortOrder;
    userId?: SortOrder;
    gameId?: SortOrder;
  };

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder;
    rating?: SortOrder;
    comment?: SortOrder;
    createdAt?: SortOrder;
    userId?: SortOrder;
    gameId?: SortOrder;
  };

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder;
  };

  export type CartCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type CartMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type CartMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type CartScalarRelationFilter = {
    is?: CartWhereInput;
    isNot?: CartWhereInput;
  };

  export type CartItemCartIdGameIdCompoundUniqueInput = {
    cartId: string;
    gameId: string;
  };

  export type CartItemCountOrderByAggregateInput = {
    id?: SortOrder;
    cartId?: SortOrder;
    gameId?: SortOrder;
    quantity?: SortOrder;
    addedAt?: SortOrder;
  };

  export type CartItemAvgOrderByAggregateInput = {
    quantity?: SortOrder;
  };

  export type CartItemMaxOrderByAggregateInput = {
    id?: SortOrder;
    cartId?: SortOrder;
    gameId?: SortOrder;
    quantity?: SortOrder;
    addedAt?: SortOrder;
  };

  export type CartItemMinOrderByAggregateInput = {
    id?: SortOrder;
    cartId?: SortOrder;
    gameId?: SortOrder;
    quantity?: SortOrder;
    addedAt?: SortOrder;
  };

  export type CartItemSumOrderByAggregateInput = {
    quantity?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    totalAmount?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
  };

  export type OrderAvgOrderByAggregateInput = {
    totalAmount?: SortOrder;
  };

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    totalAmount?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
  };

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    totalAmount?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
  };

  export type OrderSumOrderByAggregateInput = {
    totalAmount?: SortOrder;
  };

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput;
    isNot?: OrderWhereInput;
  };

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    gameId?: SortOrder;
    price?: SortOrder;
    quantity?: SortOrder;
  };

  export type OrderItemAvgOrderByAggregateInput = {
    price?: SortOrder;
    quantity?: SortOrder;
  };

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    gameId?: SortOrder;
    price?: SortOrder;
    quantity?: SortOrder;
  };

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    gameId?: SortOrder;
    price?: SortOrder;
    quantity?: SortOrder;
  };

  export type OrderItemSumOrderByAggregateInput = {
    price?: SortOrder;
    quantity?: SortOrder;
  };

  export type FeaturedGameCountOrderByAggregateInput = {
    id?: SortOrder;
    gameId?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    priority?: SortOrder;
    createdAt?: SortOrder;
  };

  export type FeaturedGameAvgOrderByAggregateInput = {
    priority?: SortOrder;
  };

  export type FeaturedGameMaxOrderByAggregateInput = {
    id?: SortOrder;
    gameId?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    priority?: SortOrder;
    createdAt?: SortOrder;
  };

  export type FeaturedGameMinOrderByAggregateInput = {
    id?: SortOrder;
    gameId?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    priority?: SortOrder;
    createdAt?: SortOrder;
  };

  export type FeaturedGameSumOrderByAggregateInput = {
    priority?: SortOrder;
  };

  export type EnumRecommendationTypeFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.RecommendationType
      | EnumRecommendationTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.RecommendationType[]
      | ListEnumRecommendationTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.RecommendationType[]
      | ListEnumRecommendationTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumRecommendationTypeFilter<$PrismaModel>
      | $Enums.RecommendationType;
  };

  export type GameNullableScalarRelationFilter = {
    is?: GameWhereInput | null;
    isNot?: GameWhereInput | null;
  };

  export type RecommendedGameCountOrderByAggregateInput = {
    id?: SortOrder;
    gameId?: SortOrder;
    recommendationType?: SortOrder;
    relatedGameId?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    priority?: SortOrder;
    createdAt?: SortOrder;
  };

  export type RecommendedGameAvgOrderByAggregateInput = {
    priority?: SortOrder;
  };

  export type RecommendedGameMaxOrderByAggregateInput = {
    id?: SortOrder;
    gameId?: SortOrder;
    recommendationType?: SortOrder;
    relatedGameId?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    priority?: SortOrder;
    createdAt?: SortOrder;
  };

  export type RecommendedGameMinOrderByAggregateInput = {
    id?: SortOrder;
    gameId?: SortOrder;
    recommendationType?: SortOrder;
    relatedGameId?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    priority?: SortOrder;
    createdAt?: SortOrder;
  };

  export type RecommendedGameSumOrderByAggregateInput = {
    priority?: SortOrder;
  };

  export type EnumRecommendationTypeWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | $Enums.RecommendationType
        | EnumRecommendationTypeFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.RecommendationType[]
        | ListEnumRecommendationTypeFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.RecommendationType[]
        | ListEnumRecommendationTypeFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumRecommendationTypeWithAggregatesFilter<$PrismaModel>
        | $Enums.RecommendationType;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumRecommendationTypeFilter<$PrismaModel>;
      _max?: NestedEnumRecommendationTypeFilter<$PrismaModel>;
    };

  export type AccountCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          AccountCreateWithoutUserInput,
          AccountUncheckedCreateWithoutUserInput
        >
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
  };

  export type SessionCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
  };

  export type CartCreateNestedOneWithoutUserInput = {
    create?: XOR<
      CartCreateWithoutUserInput,
      CartUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: CartCreateOrConnectWithoutUserInput;
    connect?: CartWhereUniqueInput;
  };

  export type OrderCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
      | OrderCreateWithoutUserInput[]
      | OrderUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutUserInput
      | OrderCreateOrConnectWithoutUserInput[];
    createMany?: OrderCreateManyUserInputEnvelope;
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
  };

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
      | ReviewCreateWithoutUserInput[]
      | ReviewUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutUserInput
      | ReviewCreateOrConnectWithoutUserInput[];
    createMany?: ReviewCreateManyUserInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
  };

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          AccountCreateWithoutUserInput,
          AccountUncheckedCreateWithoutUserInput
        >
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
  };

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
  };

  export type CartUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<
      CartCreateWithoutUserInput,
      CartUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: CartCreateOrConnectWithoutUserInput;
    connect?: CartWhereUniqueInput;
  };

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
      | OrderCreateWithoutUserInput[]
      | OrderUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutUserInput
      | OrderCreateOrConnectWithoutUserInput[];
    createMany?: OrderCreateManyUserInputEnvelope;
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
  };

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
      | ReviewCreateWithoutUserInput[]
      | ReviewUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutUserInput
      | ReviewCreateOrConnectWithoutUserInput[];
    createMany?: ReviewCreateManyUserInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          AccountCreateWithoutUserInput,
          AccountUncheckedCreateWithoutUserInput
        >
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    upsert?:
      | AccountUpsertWithWhereUniqueWithoutUserInput
      | AccountUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    update?:
      | AccountUpdateWithWhereUniqueWithoutUserInput
      | AccountUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AccountUpdateManyWithWhereWithoutUserInput
      | AccountUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[];
  };

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    upsert?:
      | SessionUpsertWithWhereUniqueWithoutUserInput
      | SessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    update?:
      | SessionUpdateWithWhereUniqueWithoutUserInput
      | SessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | SessionUpdateManyWithWhereWithoutUserInput
      | SessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[];
  };

  export type CartUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      CartCreateWithoutUserInput,
      CartUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: CartCreateOrConnectWithoutUserInput;
    upsert?: CartUpsertWithoutUserInput;
    disconnect?: CartWhereInput | boolean;
    delete?: CartWhereInput | boolean;
    connect?: CartWhereUniqueInput;
    update?: XOR<
      XOR<CartUpdateToOneWithWhereWithoutUserInput, CartUpdateWithoutUserInput>,
      CartUncheckedUpdateWithoutUserInput
    >;
  };

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
      | OrderCreateWithoutUserInput[]
      | OrderUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutUserInput
      | OrderCreateOrConnectWithoutUserInput[];
    upsert?:
      | OrderUpsertWithWhereUniqueWithoutUserInput
      | OrderUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: OrderCreateManyUserInputEnvelope;
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    update?:
      | OrderUpdateWithWhereUniqueWithoutUserInput
      | OrderUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | OrderUpdateManyWithWhereWithoutUserInput
      | OrderUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[];
  };

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
      | ReviewCreateWithoutUserInput[]
      | ReviewUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutUserInput
      | ReviewCreateOrConnectWithoutUserInput[];
    upsert?:
      | ReviewUpsertWithWhereUniqueWithoutUserInput
      | ReviewUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ReviewCreateManyUserInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?:
      | ReviewUpdateWithWhereUniqueWithoutUserInput
      | ReviewUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ReviewUpdateManyWithWhereWithoutUserInput
      | ReviewUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
  };

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          AccountCreateWithoutUserInput,
          AccountUncheckedCreateWithoutUserInput
        >
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    upsert?:
      | AccountUpsertWithWhereUniqueWithoutUserInput
      | AccountUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    update?:
      | AccountUpdateWithWhereUniqueWithoutUserInput
      | AccountUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AccountUpdateManyWithWhereWithoutUserInput
      | AccountUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[];
  };

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          SessionCreateWithoutUserInput,
          SessionUncheckedCreateWithoutUserInput
        >
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    upsert?:
      | SessionUpsertWithWhereUniqueWithoutUserInput
      | SessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    update?:
      | SessionUpdateWithWhereUniqueWithoutUserInput
      | SessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | SessionUpdateManyWithWhereWithoutUserInput
      | SessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[];
  };

  export type CartUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      CartCreateWithoutUserInput,
      CartUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: CartCreateOrConnectWithoutUserInput;
    upsert?: CartUpsertWithoutUserInput;
    disconnect?: CartWhereInput | boolean;
    delete?: CartWhereInput | boolean;
    connect?: CartWhereUniqueInput;
    update?: XOR<
      XOR<CartUpdateToOneWithWhereWithoutUserInput, CartUpdateWithoutUserInput>,
      CartUncheckedUpdateWithoutUserInput
    >;
  };

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
      | OrderCreateWithoutUserInput[]
      | OrderUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutUserInput
      | OrderCreateOrConnectWithoutUserInput[];
    upsert?:
      | OrderUpsertWithWhereUniqueWithoutUserInput
      | OrderUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: OrderCreateManyUserInputEnvelope;
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    update?:
      | OrderUpdateWithWhereUniqueWithoutUserInput
      | OrderUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | OrderUpdateManyWithWhereWithoutUserInput
      | OrderUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[];
  };

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
      | ReviewCreateWithoutUserInput[]
      | ReviewUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutUserInput
      | ReviewCreateOrConnectWithoutUserInput[];
    upsert?:
      | ReviewUpsertWithWhereUniqueWithoutUserInput
      | ReviewUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ReviewCreateManyUserInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?:
      | ReviewUpdateWithWhereUniqueWithoutUserInput
      | ReviewUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ReviewUpdateManyWithWhereWithoutUserInput
      | ReviewUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<
      UserCreateWithoutAccountsInput,
      UserUncheckedCreateWithoutAccountsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput;
    connect?: UserWhereUniqueInput;
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<
      UserCreateWithoutAccountsInput,
      UserUncheckedCreateWithoutAccountsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput;
    upsert?: UserUpsertWithoutAccountsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutAccountsInput,
        UserUpdateWithoutAccountsInput
      >,
      UserUncheckedUpdateWithoutAccountsInput
    >;
  };

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<
      UserCreateWithoutSessionsInput,
      UserUncheckedCreateWithoutSessionsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<
      UserCreateWithoutSessionsInput,
      UserUncheckedCreateWithoutSessionsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput;
    upsert?: UserUpsertWithoutSessionsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutSessionsInput,
        UserUpdateWithoutSessionsInput
      >,
      UserUncheckedUpdateWithoutSessionsInput
    >;
  };

  export type CartItemCreateNestedManyWithoutGameInput = {
    create?:
      | XOR<
          CartItemCreateWithoutGameInput,
          CartItemUncheckedCreateWithoutGameInput
        >
      | CartItemCreateWithoutGameInput[]
      | CartItemUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | CartItemCreateOrConnectWithoutGameInput
      | CartItemCreateOrConnectWithoutGameInput[];
    createMany?: CartItemCreateManyGameInputEnvelope;
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[];
  };

  export type GameGenreCreateNestedManyWithoutGameInput = {
    create?:
      | XOR<
          GameGenreCreateWithoutGameInput,
          GameGenreUncheckedCreateWithoutGameInput
        >
      | GameGenreCreateWithoutGameInput[]
      | GameGenreUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | GameGenreCreateOrConnectWithoutGameInput
      | GameGenreCreateOrConnectWithoutGameInput[];
    createMany?: GameGenreCreateManyGameInputEnvelope;
    connect?: GameGenreWhereUniqueInput | GameGenreWhereUniqueInput[];
  };

  export type OrderItemCreateNestedManyWithoutGameInput = {
    create?:
      | XOR<
          OrderItemCreateWithoutGameInput,
          OrderItemUncheckedCreateWithoutGameInput
        >
      | OrderItemCreateWithoutGameInput[]
      | OrderItemUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | OrderItemCreateOrConnectWithoutGameInput
      | OrderItemCreateOrConnectWithoutGameInput[];
    createMany?: OrderItemCreateManyGameInputEnvelope;
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
  };

  export type ReviewCreateNestedManyWithoutGameInput = {
    create?:
      | XOR<ReviewCreateWithoutGameInput, ReviewUncheckedCreateWithoutGameInput>
      | ReviewCreateWithoutGameInput[]
      | ReviewUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutGameInput
      | ReviewCreateOrConnectWithoutGameInput[];
    createMany?: ReviewCreateManyGameInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
  };

  export type ScreenshotCreateNestedManyWithoutGameInput = {
    create?:
      | XOR<
          ScreenshotCreateWithoutGameInput,
          ScreenshotUncheckedCreateWithoutGameInput
        >
      | ScreenshotCreateWithoutGameInput[]
      | ScreenshotUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | ScreenshotCreateOrConnectWithoutGameInput
      | ScreenshotCreateOrConnectWithoutGameInput[];
    createMany?: ScreenshotCreateManyGameInputEnvelope;
    connect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[];
  };

  export type FeaturedGameCreateNestedManyWithoutGameInput = {
    create?:
      | XOR<
          FeaturedGameCreateWithoutGameInput,
          FeaturedGameUncheckedCreateWithoutGameInput
        >
      | FeaturedGameCreateWithoutGameInput[]
      | FeaturedGameUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | FeaturedGameCreateOrConnectWithoutGameInput
      | FeaturedGameCreateOrConnectWithoutGameInput[];
    createMany?: FeaturedGameCreateManyGameInputEnvelope;
    connect?: FeaturedGameWhereUniqueInput | FeaturedGameWhereUniqueInput[];
  };

  export type RecommendedGameCreateNestedManyWithoutGameInput = {
    create?:
      | XOR<
          RecommendedGameCreateWithoutGameInput,
          RecommendedGameUncheckedCreateWithoutGameInput
        >
      | RecommendedGameCreateWithoutGameInput[]
      | RecommendedGameUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | RecommendedGameCreateOrConnectWithoutGameInput
      | RecommendedGameCreateOrConnectWithoutGameInput[];
    createMany?: RecommendedGameCreateManyGameInputEnvelope;
    connect?:
      | RecommendedGameWhereUniqueInput
      | RecommendedGameWhereUniqueInput[];
  };

  export type RecommendedGameCreateNestedManyWithoutRelatedGameInput = {
    create?:
      | XOR<
          RecommendedGameCreateWithoutRelatedGameInput,
          RecommendedGameUncheckedCreateWithoutRelatedGameInput
        >
      | RecommendedGameCreateWithoutRelatedGameInput[]
      | RecommendedGameUncheckedCreateWithoutRelatedGameInput[];
    connectOrCreate?:
      | RecommendedGameCreateOrConnectWithoutRelatedGameInput
      | RecommendedGameCreateOrConnectWithoutRelatedGameInput[];
    createMany?: RecommendedGameCreateManyRelatedGameInputEnvelope;
    connect?:
      | RecommendedGameWhereUniqueInput
      | RecommendedGameWhereUniqueInput[];
  };

  export type CartItemUncheckedCreateNestedManyWithoutGameInput = {
    create?:
      | XOR<
          CartItemCreateWithoutGameInput,
          CartItemUncheckedCreateWithoutGameInput
        >
      | CartItemCreateWithoutGameInput[]
      | CartItemUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | CartItemCreateOrConnectWithoutGameInput
      | CartItemCreateOrConnectWithoutGameInput[];
    createMany?: CartItemCreateManyGameInputEnvelope;
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[];
  };

  export type GameGenreUncheckedCreateNestedManyWithoutGameInput = {
    create?:
      | XOR<
          GameGenreCreateWithoutGameInput,
          GameGenreUncheckedCreateWithoutGameInput
        >
      | GameGenreCreateWithoutGameInput[]
      | GameGenreUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | GameGenreCreateOrConnectWithoutGameInput
      | GameGenreCreateOrConnectWithoutGameInput[];
    createMany?: GameGenreCreateManyGameInputEnvelope;
    connect?: GameGenreWhereUniqueInput | GameGenreWhereUniqueInput[];
  };

  export type OrderItemUncheckedCreateNestedManyWithoutGameInput = {
    create?:
      | XOR<
          OrderItemCreateWithoutGameInput,
          OrderItemUncheckedCreateWithoutGameInput
        >
      | OrderItemCreateWithoutGameInput[]
      | OrderItemUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | OrderItemCreateOrConnectWithoutGameInput
      | OrderItemCreateOrConnectWithoutGameInput[];
    createMany?: OrderItemCreateManyGameInputEnvelope;
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
  };

  export type ReviewUncheckedCreateNestedManyWithoutGameInput = {
    create?:
      | XOR<ReviewCreateWithoutGameInput, ReviewUncheckedCreateWithoutGameInput>
      | ReviewCreateWithoutGameInput[]
      | ReviewUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutGameInput
      | ReviewCreateOrConnectWithoutGameInput[];
    createMany?: ReviewCreateManyGameInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
  };

  export type ScreenshotUncheckedCreateNestedManyWithoutGameInput = {
    create?:
      | XOR<
          ScreenshotCreateWithoutGameInput,
          ScreenshotUncheckedCreateWithoutGameInput
        >
      | ScreenshotCreateWithoutGameInput[]
      | ScreenshotUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | ScreenshotCreateOrConnectWithoutGameInput
      | ScreenshotCreateOrConnectWithoutGameInput[];
    createMany?: ScreenshotCreateManyGameInputEnvelope;
    connect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[];
  };

  export type FeaturedGameUncheckedCreateNestedManyWithoutGameInput = {
    create?:
      | XOR<
          FeaturedGameCreateWithoutGameInput,
          FeaturedGameUncheckedCreateWithoutGameInput
        >
      | FeaturedGameCreateWithoutGameInput[]
      | FeaturedGameUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | FeaturedGameCreateOrConnectWithoutGameInput
      | FeaturedGameCreateOrConnectWithoutGameInput[];
    createMany?: FeaturedGameCreateManyGameInputEnvelope;
    connect?: FeaturedGameWhereUniqueInput | FeaturedGameWhereUniqueInput[];
  };

  export type RecommendedGameUncheckedCreateNestedManyWithoutGameInput = {
    create?:
      | XOR<
          RecommendedGameCreateWithoutGameInput,
          RecommendedGameUncheckedCreateWithoutGameInput
        >
      | RecommendedGameCreateWithoutGameInput[]
      | RecommendedGameUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | RecommendedGameCreateOrConnectWithoutGameInput
      | RecommendedGameCreateOrConnectWithoutGameInput[];
    createMany?: RecommendedGameCreateManyGameInputEnvelope;
    connect?:
      | RecommendedGameWhereUniqueInput
      | RecommendedGameWhereUniqueInput[];
  };

  export type RecommendedGameUncheckedCreateNestedManyWithoutRelatedGameInput =
    {
      create?:
        | XOR<
            RecommendedGameCreateWithoutRelatedGameInput,
            RecommendedGameUncheckedCreateWithoutRelatedGameInput
          >
        | RecommendedGameCreateWithoutRelatedGameInput[]
        | RecommendedGameUncheckedCreateWithoutRelatedGameInput[];
      connectOrCreate?:
        | RecommendedGameCreateOrConnectWithoutRelatedGameInput
        | RecommendedGameCreateOrConnectWithoutRelatedGameInput[];
      createMany?: RecommendedGameCreateManyRelatedGameInputEnvelope;
      connect?:
        | RecommendedGameWhereUniqueInput
        | RecommendedGameWhereUniqueInput[];
    };

  export type FloatFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type EnumGameStatusFieldUpdateOperationsInput = {
    set?: $Enums.GameStatus;
  };

  export type CartItemUpdateManyWithoutGameNestedInput = {
    create?:
      | XOR<
          CartItemCreateWithoutGameInput,
          CartItemUncheckedCreateWithoutGameInput
        >
      | CartItemCreateWithoutGameInput[]
      | CartItemUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | CartItemCreateOrConnectWithoutGameInput
      | CartItemCreateOrConnectWithoutGameInput[];
    upsert?:
      | CartItemUpsertWithWhereUniqueWithoutGameInput
      | CartItemUpsertWithWhereUniqueWithoutGameInput[];
    createMany?: CartItemCreateManyGameInputEnvelope;
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[];
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[];
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[];
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[];
    update?:
      | CartItemUpdateWithWhereUniqueWithoutGameInput
      | CartItemUpdateWithWhereUniqueWithoutGameInput[];
    updateMany?:
      | CartItemUpdateManyWithWhereWithoutGameInput
      | CartItemUpdateManyWithWhereWithoutGameInput[];
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[];
  };

  export type GameGenreUpdateManyWithoutGameNestedInput = {
    create?:
      | XOR<
          GameGenreCreateWithoutGameInput,
          GameGenreUncheckedCreateWithoutGameInput
        >
      | GameGenreCreateWithoutGameInput[]
      | GameGenreUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | GameGenreCreateOrConnectWithoutGameInput
      | GameGenreCreateOrConnectWithoutGameInput[];
    upsert?:
      | GameGenreUpsertWithWhereUniqueWithoutGameInput
      | GameGenreUpsertWithWhereUniqueWithoutGameInput[];
    createMany?: GameGenreCreateManyGameInputEnvelope;
    set?: GameGenreWhereUniqueInput | GameGenreWhereUniqueInput[];
    disconnect?: GameGenreWhereUniqueInput | GameGenreWhereUniqueInput[];
    delete?: GameGenreWhereUniqueInput | GameGenreWhereUniqueInput[];
    connect?: GameGenreWhereUniqueInput | GameGenreWhereUniqueInput[];
    update?:
      | GameGenreUpdateWithWhereUniqueWithoutGameInput
      | GameGenreUpdateWithWhereUniqueWithoutGameInput[];
    updateMany?:
      | GameGenreUpdateManyWithWhereWithoutGameInput
      | GameGenreUpdateManyWithWhereWithoutGameInput[];
    deleteMany?: GameGenreScalarWhereInput | GameGenreScalarWhereInput[];
  };

  export type OrderItemUpdateManyWithoutGameNestedInput = {
    create?:
      | XOR<
          OrderItemCreateWithoutGameInput,
          OrderItemUncheckedCreateWithoutGameInput
        >
      | OrderItemCreateWithoutGameInput[]
      | OrderItemUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | OrderItemCreateOrConnectWithoutGameInput
      | OrderItemCreateOrConnectWithoutGameInput[];
    upsert?:
      | OrderItemUpsertWithWhereUniqueWithoutGameInput
      | OrderItemUpsertWithWhereUniqueWithoutGameInput[];
    createMany?: OrderItemCreateManyGameInputEnvelope;
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    update?:
      | OrderItemUpdateWithWhereUniqueWithoutGameInput
      | OrderItemUpdateWithWhereUniqueWithoutGameInput[];
    updateMany?:
      | OrderItemUpdateManyWithWhereWithoutGameInput
      | OrderItemUpdateManyWithWhereWithoutGameInput[];
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[];
  };

  export type ReviewUpdateManyWithoutGameNestedInput = {
    create?:
      | XOR<ReviewCreateWithoutGameInput, ReviewUncheckedCreateWithoutGameInput>
      | ReviewCreateWithoutGameInput[]
      | ReviewUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutGameInput
      | ReviewCreateOrConnectWithoutGameInput[];
    upsert?:
      | ReviewUpsertWithWhereUniqueWithoutGameInput
      | ReviewUpsertWithWhereUniqueWithoutGameInput[];
    createMany?: ReviewCreateManyGameInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?:
      | ReviewUpdateWithWhereUniqueWithoutGameInput
      | ReviewUpdateWithWhereUniqueWithoutGameInput[];
    updateMany?:
      | ReviewUpdateManyWithWhereWithoutGameInput
      | ReviewUpdateManyWithWhereWithoutGameInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
  };

  export type ScreenshotUpdateManyWithoutGameNestedInput = {
    create?:
      | XOR<
          ScreenshotCreateWithoutGameInput,
          ScreenshotUncheckedCreateWithoutGameInput
        >
      | ScreenshotCreateWithoutGameInput[]
      | ScreenshotUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | ScreenshotCreateOrConnectWithoutGameInput
      | ScreenshotCreateOrConnectWithoutGameInput[];
    upsert?:
      | ScreenshotUpsertWithWhereUniqueWithoutGameInput
      | ScreenshotUpsertWithWhereUniqueWithoutGameInput[];
    createMany?: ScreenshotCreateManyGameInputEnvelope;
    set?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[];
    disconnect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[];
    delete?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[];
    connect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[];
    update?:
      | ScreenshotUpdateWithWhereUniqueWithoutGameInput
      | ScreenshotUpdateWithWhereUniqueWithoutGameInput[];
    updateMany?:
      | ScreenshotUpdateManyWithWhereWithoutGameInput
      | ScreenshotUpdateManyWithWhereWithoutGameInput[];
    deleteMany?: ScreenshotScalarWhereInput | ScreenshotScalarWhereInput[];
  };

  export type FeaturedGameUpdateManyWithoutGameNestedInput = {
    create?:
      | XOR<
          FeaturedGameCreateWithoutGameInput,
          FeaturedGameUncheckedCreateWithoutGameInput
        >
      | FeaturedGameCreateWithoutGameInput[]
      | FeaturedGameUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | FeaturedGameCreateOrConnectWithoutGameInput
      | FeaturedGameCreateOrConnectWithoutGameInput[];
    upsert?:
      | FeaturedGameUpsertWithWhereUniqueWithoutGameInput
      | FeaturedGameUpsertWithWhereUniqueWithoutGameInput[];
    createMany?: FeaturedGameCreateManyGameInputEnvelope;
    set?: FeaturedGameWhereUniqueInput | FeaturedGameWhereUniqueInput[];
    disconnect?: FeaturedGameWhereUniqueInput | FeaturedGameWhereUniqueInput[];
    delete?: FeaturedGameWhereUniqueInput | FeaturedGameWhereUniqueInput[];
    connect?: FeaturedGameWhereUniqueInput | FeaturedGameWhereUniqueInput[];
    update?:
      | FeaturedGameUpdateWithWhereUniqueWithoutGameInput
      | FeaturedGameUpdateWithWhereUniqueWithoutGameInput[];
    updateMany?:
      | FeaturedGameUpdateManyWithWhereWithoutGameInput
      | FeaturedGameUpdateManyWithWhereWithoutGameInput[];
    deleteMany?: FeaturedGameScalarWhereInput | FeaturedGameScalarWhereInput[];
  };

  export type RecommendedGameUpdateManyWithoutGameNestedInput = {
    create?:
      | XOR<
          RecommendedGameCreateWithoutGameInput,
          RecommendedGameUncheckedCreateWithoutGameInput
        >
      | RecommendedGameCreateWithoutGameInput[]
      | RecommendedGameUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | RecommendedGameCreateOrConnectWithoutGameInput
      | RecommendedGameCreateOrConnectWithoutGameInput[];
    upsert?:
      | RecommendedGameUpsertWithWhereUniqueWithoutGameInput
      | RecommendedGameUpsertWithWhereUniqueWithoutGameInput[];
    createMany?: RecommendedGameCreateManyGameInputEnvelope;
    set?: RecommendedGameWhereUniqueInput | RecommendedGameWhereUniqueInput[];
    disconnect?:
      | RecommendedGameWhereUniqueInput
      | RecommendedGameWhereUniqueInput[];
    delete?:
      | RecommendedGameWhereUniqueInput
      | RecommendedGameWhereUniqueInput[];
    connect?:
      | RecommendedGameWhereUniqueInput
      | RecommendedGameWhereUniqueInput[];
    update?:
      | RecommendedGameUpdateWithWhereUniqueWithoutGameInput
      | RecommendedGameUpdateWithWhereUniqueWithoutGameInput[];
    updateMany?:
      | RecommendedGameUpdateManyWithWhereWithoutGameInput
      | RecommendedGameUpdateManyWithWhereWithoutGameInput[];
    deleteMany?:
      | RecommendedGameScalarWhereInput
      | RecommendedGameScalarWhereInput[];
  };

  export type RecommendedGameUpdateManyWithoutRelatedGameNestedInput = {
    create?:
      | XOR<
          RecommendedGameCreateWithoutRelatedGameInput,
          RecommendedGameUncheckedCreateWithoutRelatedGameInput
        >
      | RecommendedGameCreateWithoutRelatedGameInput[]
      | RecommendedGameUncheckedCreateWithoutRelatedGameInput[];
    connectOrCreate?:
      | RecommendedGameCreateOrConnectWithoutRelatedGameInput
      | RecommendedGameCreateOrConnectWithoutRelatedGameInput[];
    upsert?:
      | RecommendedGameUpsertWithWhereUniqueWithoutRelatedGameInput
      | RecommendedGameUpsertWithWhereUniqueWithoutRelatedGameInput[];
    createMany?: RecommendedGameCreateManyRelatedGameInputEnvelope;
    set?: RecommendedGameWhereUniqueInput | RecommendedGameWhereUniqueInput[];
    disconnect?:
      | RecommendedGameWhereUniqueInput
      | RecommendedGameWhereUniqueInput[];
    delete?:
      | RecommendedGameWhereUniqueInput
      | RecommendedGameWhereUniqueInput[];
    connect?:
      | RecommendedGameWhereUniqueInput
      | RecommendedGameWhereUniqueInput[];
    update?:
      | RecommendedGameUpdateWithWhereUniqueWithoutRelatedGameInput
      | RecommendedGameUpdateWithWhereUniqueWithoutRelatedGameInput[];
    updateMany?:
      | RecommendedGameUpdateManyWithWhereWithoutRelatedGameInput
      | RecommendedGameUpdateManyWithWhereWithoutRelatedGameInput[];
    deleteMany?:
      | RecommendedGameScalarWhereInput
      | RecommendedGameScalarWhereInput[];
  };

  export type CartItemUncheckedUpdateManyWithoutGameNestedInput = {
    create?:
      | XOR<
          CartItemCreateWithoutGameInput,
          CartItemUncheckedCreateWithoutGameInput
        >
      | CartItemCreateWithoutGameInput[]
      | CartItemUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | CartItemCreateOrConnectWithoutGameInput
      | CartItemCreateOrConnectWithoutGameInput[];
    upsert?:
      | CartItemUpsertWithWhereUniqueWithoutGameInput
      | CartItemUpsertWithWhereUniqueWithoutGameInput[];
    createMany?: CartItemCreateManyGameInputEnvelope;
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[];
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[];
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[];
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[];
    update?:
      | CartItemUpdateWithWhereUniqueWithoutGameInput
      | CartItemUpdateWithWhereUniqueWithoutGameInput[];
    updateMany?:
      | CartItemUpdateManyWithWhereWithoutGameInput
      | CartItemUpdateManyWithWhereWithoutGameInput[];
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[];
  };

  export type GameGenreUncheckedUpdateManyWithoutGameNestedInput = {
    create?:
      | XOR<
          GameGenreCreateWithoutGameInput,
          GameGenreUncheckedCreateWithoutGameInput
        >
      | GameGenreCreateWithoutGameInput[]
      | GameGenreUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | GameGenreCreateOrConnectWithoutGameInput
      | GameGenreCreateOrConnectWithoutGameInput[];
    upsert?:
      | GameGenreUpsertWithWhereUniqueWithoutGameInput
      | GameGenreUpsertWithWhereUniqueWithoutGameInput[];
    createMany?: GameGenreCreateManyGameInputEnvelope;
    set?: GameGenreWhereUniqueInput | GameGenreWhereUniqueInput[];
    disconnect?: GameGenreWhereUniqueInput | GameGenreWhereUniqueInput[];
    delete?: GameGenreWhereUniqueInput | GameGenreWhereUniqueInput[];
    connect?: GameGenreWhereUniqueInput | GameGenreWhereUniqueInput[];
    update?:
      | GameGenreUpdateWithWhereUniqueWithoutGameInput
      | GameGenreUpdateWithWhereUniqueWithoutGameInput[];
    updateMany?:
      | GameGenreUpdateManyWithWhereWithoutGameInput
      | GameGenreUpdateManyWithWhereWithoutGameInput[];
    deleteMany?: GameGenreScalarWhereInput | GameGenreScalarWhereInput[];
  };

  export type OrderItemUncheckedUpdateManyWithoutGameNestedInput = {
    create?:
      | XOR<
          OrderItemCreateWithoutGameInput,
          OrderItemUncheckedCreateWithoutGameInput
        >
      | OrderItemCreateWithoutGameInput[]
      | OrderItemUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | OrderItemCreateOrConnectWithoutGameInput
      | OrderItemCreateOrConnectWithoutGameInput[];
    upsert?:
      | OrderItemUpsertWithWhereUniqueWithoutGameInput
      | OrderItemUpsertWithWhereUniqueWithoutGameInput[];
    createMany?: OrderItemCreateManyGameInputEnvelope;
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    update?:
      | OrderItemUpdateWithWhereUniqueWithoutGameInput
      | OrderItemUpdateWithWhereUniqueWithoutGameInput[];
    updateMany?:
      | OrderItemUpdateManyWithWhereWithoutGameInput
      | OrderItemUpdateManyWithWhereWithoutGameInput[];
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[];
  };

  export type ReviewUncheckedUpdateManyWithoutGameNestedInput = {
    create?:
      | XOR<ReviewCreateWithoutGameInput, ReviewUncheckedCreateWithoutGameInput>
      | ReviewCreateWithoutGameInput[]
      | ReviewUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutGameInput
      | ReviewCreateOrConnectWithoutGameInput[];
    upsert?:
      | ReviewUpsertWithWhereUniqueWithoutGameInput
      | ReviewUpsertWithWhereUniqueWithoutGameInput[];
    createMany?: ReviewCreateManyGameInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?:
      | ReviewUpdateWithWhereUniqueWithoutGameInput
      | ReviewUpdateWithWhereUniqueWithoutGameInput[];
    updateMany?:
      | ReviewUpdateManyWithWhereWithoutGameInput
      | ReviewUpdateManyWithWhereWithoutGameInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
  };

  export type ScreenshotUncheckedUpdateManyWithoutGameNestedInput = {
    create?:
      | XOR<
          ScreenshotCreateWithoutGameInput,
          ScreenshotUncheckedCreateWithoutGameInput
        >
      | ScreenshotCreateWithoutGameInput[]
      | ScreenshotUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | ScreenshotCreateOrConnectWithoutGameInput
      | ScreenshotCreateOrConnectWithoutGameInput[];
    upsert?:
      | ScreenshotUpsertWithWhereUniqueWithoutGameInput
      | ScreenshotUpsertWithWhereUniqueWithoutGameInput[];
    createMany?: ScreenshotCreateManyGameInputEnvelope;
    set?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[];
    disconnect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[];
    delete?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[];
    connect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[];
    update?:
      | ScreenshotUpdateWithWhereUniqueWithoutGameInput
      | ScreenshotUpdateWithWhereUniqueWithoutGameInput[];
    updateMany?:
      | ScreenshotUpdateManyWithWhereWithoutGameInput
      | ScreenshotUpdateManyWithWhereWithoutGameInput[];
    deleteMany?: ScreenshotScalarWhereInput | ScreenshotScalarWhereInput[];
  };

  export type FeaturedGameUncheckedUpdateManyWithoutGameNestedInput = {
    create?:
      | XOR<
          FeaturedGameCreateWithoutGameInput,
          FeaturedGameUncheckedCreateWithoutGameInput
        >
      | FeaturedGameCreateWithoutGameInput[]
      | FeaturedGameUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | FeaturedGameCreateOrConnectWithoutGameInput
      | FeaturedGameCreateOrConnectWithoutGameInput[];
    upsert?:
      | FeaturedGameUpsertWithWhereUniqueWithoutGameInput
      | FeaturedGameUpsertWithWhereUniqueWithoutGameInput[];
    createMany?: FeaturedGameCreateManyGameInputEnvelope;
    set?: FeaturedGameWhereUniqueInput | FeaturedGameWhereUniqueInput[];
    disconnect?: FeaturedGameWhereUniqueInput | FeaturedGameWhereUniqueInput[];
    delete?: FeaturedGameWhereUniqueInput | FeaturedGameWhereUniqueInput[];
    connect?: FeaturedGameWhereUniqueInput | FeaturedGameWhereUniqueInput[];
    update?:
      | FeaturedGameUpdateWithWhereUniqueWithoutGameInput
      | FeaturedGameUpdateWithWhereUniqueWithoutGameInput[];
    updateMany?:
      | FeaturedGameUpdateManyWithWhereWithoutGameInput
      | FeaturedGameUpdateManyWithWhereWithoutGameInput[];
    deleteMany?: FeaturedGameScalarWhereInput | FeaturedGameScalarWhereInput[];
  };

  export type RecommendedGameUncheckedUpdateManyWithoutGameNestedInput = {
    create?:
      | XOR<
          RecommendedGameCreateWithoutGameInput,
          RecommendedGameUncheckedCreateWithoutGameInput
        >
      | RecommendedGameCreateWithoutGameInput[]
      | RecommendedGameUncheckedCreateWithoutGameInput[];
    connectOrCreate?:
      | RecommendedGameCreateOrConnectWithoutGameInput
      | RecommendedGameCreateOrConnectWithoutGameInput[];
    upsert?:
      | RecommendedGameUpsertWithWhereUniqueWithoutGameInput
      | RecommendedGameUpsertWithWhereUniqueWithoutGameInput[];
    createMany?: RecommendedGameCreateManyGameInputEnvelope;
    set?: RecommendedGameWhereUniqueInput | RecommendedGameWhereUniqueInput[];
    disconnect?:
      | RecommendedGameWhereUniqueInput
      | RecommendedGameWhereUniqueInput[];
    delete?:
      | RecommendedGameWhereUniqueInput
      | RecommendedGameWhereUniqueInput[];
    connect?:
      | RecommendedGameWhereUniqueInput
      | RecommendedGameWhereUniqueInput[];
    update?:
      | RecommendedGameUpdateWithWhereUniqueWithoutGameInput
      | RecommendedGameUpdateWithWhereUniqueWithoutGameInput[];
    updateMany?:
      | RecommendedGameUpdateManyWithWhereWithoutGameInput
      | RecommendedGameUpdateManyWithWhereWithoutGameInput[];
    deleteMany?:
      | RecommendedGameScalarWhereInput
      | RecommendedGameScalarWhereInput[];
  };

  export type RecommendedGameUncheckedUpdateManyWithoutRelatedGameNestedInput =
    {
      create?:
        | XOR<
            RecommendedGameCreateWithoutRelatedGameInput,
            RecommendedGameUncheckedCreateWithoutRelatedGameInput
          >
        | RecommendedGameCreateWithoutRelatedGameInput[]
        | RecommendedGameUncheckedCreateWithoutRelatedGameInput[];
      connectOrCreate?:
        | RecommendedGameCreateOrConnectWithoutRelatedGameInput
        | RecommendedGameCreateOrConnectWithoutRelatedGameInput[];
      upsert?:
        | RecommendedGameUpsertWithWhereUniqueWithoutRelatedGameInput
        | RecommendedGameUpsertWithWhereUniqueWithoutRelatedGameInput[];
      createMany?: RecommendedGameCreateManyRelatedGameInputEnvelope;
      set?: RecommendedGameWhereUniqueInput | RecommendedGameWhereUniqueInput[];
      disconnect?:
        | RecommendedGameWhereUniqueInput
        | RecommendedGameWhereUniqueInput[];
      delete?:
        | RecommendedGameWhereUniqueInput
        | RecommendedGameWhereUniqueInput[];
      connect?:
        | RecommendedGameWhereUniqueInput
        | RecommendedGameWhereUniqueInput[];
      update?:
        | RecommendedGameUpdateWithWhereUniqueWithoutRelatedGameInput
        | RecommendedGameUpdateWithWhereUniqueWithoutRelatedGameInput[];
      updateMany?:
        | RecommendedGameUpdateManyWithWhereWithoutRelatedGameInput
        | RecommendedGameUpdateManyWithWhereWithoutRelatedGameInput[];
      deleteMany?:
        | RecommendedGameScalarWhereInput
        | RecommendedGameScalarWhereInput[];
    };

  export type GameGenreCreateNestedManyWithoutGenreInput = {
    create?:
      | XOR<
          GameGenreCreateWithoutGenreInput,
          GameGenreUncheckedCreateWithoutGenreInput
        >
      | GameGenreCreateWithoutGenreInput[]
      | GameGenreUncheckedCreateWithoutGenreInput[];
    connectOrCreate?:
      | GameGenreCreateOrConnectWithoutGenreInput
      | GameGenreCreateOrConnectWithoutGenreInput[];
    createMany?: GameGenreCreateManyGenreInputEnvelope;
    connect?: GameGenreWhereUniqueInput | GameGenreWhereUniqueInput[];
  };

  export type GenreCreateNestedOneWithoutSubGenresInput = {
    create?: XOR<
      GenreCreateWithoutSubGenresInput,
      GenreUncheckedCreateWithoutSubGenresInput
    >;
    connectOrCreate?: GenreCreateOrConnectWithoutSubGenresInput;
    connect?: GenreWhereUniqueInput;
  };

  export type GenreCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<
          GenreCreateWithoutParentInput,
          GenreUncheckedCreateWithoutParentInput
        >
      | GenreCreateWithoutParentInput[]
      | GenreUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | GenreCreateOrConnectWithoutParentInput
      | GenreCreateOrConnectWithoutParentInput[];
    createMany?: GenreCreateManyParentInputEnvelope;
    connect?: GenreWhereUniqueInput | GenreWhereUniqueInput[];
  };

  export type GameGenreUncheckedCreateNestedManyWithoutGenreInput = {
    create?:
      | XOR<
          GameGenreCreateWithoutGenreInput,
          GameGenreUncheckedCreateWithoutGenreInput
        >
      | GameGenreCreateWithoutGenreInput[]
      | GameGenreUncheckedCreateWithoutGenreInput[];
    connectOrCreate?:
      | GameGenreCreateOrConnectWithoutGenreInput
      | GameGenreCreateOrConnectWithoutGenreInput[];
    createMany?: GameGenreCreateManyGenreInputEnvelope;
    connect?: GameGenreWhereUniqueInput | GameGenreWhereUniqueInput[];
  };

  export type GenreUncheckedCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<
          GenreCreateWithoutParentInput,
          GenreUncheckedCreateWithoutParentInput
        >
      | GenreCreateWithoutParentInput[]
      | GenreUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | GenreCreateOrConnectWithoutParentInput
      | GenreCreateOrConnectWithoutParentInput[];
    createMany?: GenreCreateManyParentInputEnvelope;
    connect?: GenreWhereUniqueInput | GenreWhereUniqueInput[];
  };

  export type GameGenreUpdateManyWithoutGenreNestedInput = {
    create?:
      | XOR<
          GameGenreCreateWithoutGenreInput,
          GameGenreUncheckedCreateWithoutGenreInput
        >
      | GameGenreCreateWithoutGenreInput[]
      | GameGenreUncheckedCreateWithoutGenreInput[];
    connectOrCreate?:
      | GameGenreCreateOrConnectWithoutGenreInput
      | GameGenreCreateOrConnectWithoutGenreInput[];
    upsert?:
      | GameGenreUpsertWithWhereUniqueWithoutGenreInput
      | GameGenreUpsertWithWhereUniqueWithoutGenreInput[];
    createMany?: GameGenreCreateManyGenreInputEnvelope;
    set?: GameGenreWhereUniqueInput | GameGenreWhereUniqueInput[];
    disconnect?: GameGenreWhereUniqueInput | GameGenreWhereUniqueInput[];
    delete?: GameGenreWhereUniqueInput | GameGenreWhereUniqueInput[];
    connect?: GameGenreWhereUniqueInput | GameGenreWhereUniqueInput[];
    update?:
      | GameGenreUpdateWithWhereUniqueWithoutGenreInput
      | GameGenreUpdateWithWhereUniqueWithoutGenreInput[];
    updateMany?:
      | GameGenreUpdateManyWithWhereWithoutGenreInput
      | GameGenreUpdateManyWithWhereWithoutGenreInput[];
    deleteMany?: GameGenreScalarWhereInput | GameGenreScalarWhereInput[];
  };

  export type GenreUpdateOneWithoutSubGenresNestedInput = {
    create?: XOR<
      GenreCreateWithoutSubGenresInput,
      GenreUncheckedCreateWithoutSubGenresInput
    >;
    connectOrCreate?: GenreCreateOrConnectWithoutSubGenresInput;
    upsert?: GenreUpsertWithoutSubGenresInput;
    disconnect?: GenreWhereInput | boolean;
    delete?: GenreWhereInput | boolean;
    connect?: GenreWhereUniqueInput;
    update?: XOR<
      XOR<
        GenreUpdateToOneWithWhereWithoutSubGenresInput,
        GenreUpdateWithoutSubGenresInput
      >,
      GenreUncheckedUpdateWithoutSubGenresInput
    >;
  };

  export type GenreUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<
          GenreCreateWithoutParentInput,
          GenreUncheckedCreateWithoutParentInput
        >
      | GenreCreateWithoutParentInput[]
      | GenreUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | GenreCreateOrConnectWithoutParentInput
      | GenreCreateOrConnectWithoutParentInput[];
    upsert?:
      | GenreUpsertWithWhereUniqueWithoutParentInput
      | GenreUpsertWithWhereUniqueWithoutParentInput[];
    createMany?: GenreCreateManyParentInputEnvelope;
    set?: GenreWhereUniqueInput | GenreWhereUniqueInput[];
    disconnect?: GenreWhereUniqueInput | GenreWhereUniqueInput[];
    delete?: GenreWhereUniqueInput | GenreWhereUniqueInput[];
    connect?: GenreWhereUniqueInput | GenreWhereUniqueInput[];
    update?:
      | GenreUpdateWithWhereUniqueWithoutParentInput
      | GenreUpdateWithWhereUniqueWithoutParentInput[];
    updateMany?:
      | GenreUpdateManyWithWhereWithoutParentInput
      | GenreUpdateManyWithWhereWithoutParentInput[];
    deleteMany?: GenreScalarWhereInput | GenreScalarWhereInput[];
  };

  export type GameGenreUncheckedUpdateManyWithoutGenreNestedInput = {
    create?:
      | XOR<
          GameGenreCreateWithoutGenreInput,
          GameGenreUncheckedCreateWithoutGenreInput
        >
      | GameGenreCreateWithoutGenreInput[]
      | GameGenreUncheckedCreateWithoutGenreInput[];
    connectOrCreate?:
      | GameGenreCreateOrConnectWithoutGenreInput
      | GameGenreCreateOrConnectWithoutGenreInput[];
    upsert?:
      | GameGenreUpsertWithWhereUniqueWithoutGenreInput
      | GameGenreUpsertWithWhereUniqueWithoutGenreInput[];
    createMany?: GameGenreCreateManyGenreInputEnvelope;
    set?: GameGenreWhereUniqueInput | GameGenreWhereUniqueInput[];
    disconnect?: GameGenreWhereUniqueInput | GameGenreWhereUniqueInput[];
    delete?: GameGenreWhereUniqueInput | GameGenreWhereUniqueInput[];
    connect?: GameGenreWhereUniqueInput | GameGenreWhereUniqueInput[];
    update?:
      | GameGenreUpdateWithWhereUniqueWithoutGenreInput
      | GameGenreUpdateWithWhereUniqueWithoutGenreInput[];
    updateMany?:
      | GameGenreUpdateManyWithWhereWithoutGenreInput
      | GameGenreUpdateManyWithWhereWithoutGenreInput[];
    deleteMany?: GameGenreScalarWhereInput | GameGenreScalarWhereInput[];
  };

  export type GenreUncheckedUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<
          GenreCreateWithoutParentInput,
          GenreUncheckedCreateWithoutParentInput
        >
      | GenreCreateWithoutParentInput[]
      | GenreUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | GenreCreateOrConnectWithoutParentInput
      | GenreCreateOrConnectWithoutParentInput[];
    upsert?:
      | GenreUpsertWithWhereUniqueWithoutParentInput
      | GenreUpsertWithWhereUniqueWithoutParentInput[];
    createMany?: GenreCreateManyParentInputEnvelope;
    set?: GenreWhereUniqueInput | GenreWhereUniqueInput[];
    disconnect?: GenreWhereUniqueInput | GenreWhereUniqueInput[];
    delete?: GenreWhereUniqueInput | GenreWhereUniqueInput[];
    connect?: GenreWhereUniqueInput | GenreWhereUniqueInput[];
    update?:
      | GenreUpdateWithWhereUniqueWithoutParentInput
      | GenreUpdateWithWhereUniqueWithoutParentInput[];
    updateMany?:
      | GenreUpdateManyWithWhereWithoutParentInput
      | GenreUpdateManyWithWhereWithoutParentInput[];
    deleteMany?: GenreScalarWhereInput | GenreScalarWhereInput[];
  };

  export type GameCreateNestedOneWithoutGenresInput = {
    create?: XOR<
      GameCreateWithoutGenresInput,
      GameUncheckedCreateWithoutGenresInput
    >;
    connectOrCreate?: GameCreateOrConnectWithoutGenresInput;
    connect?: GameWhereUniqueInput;
  };

  export type GenreCreateNestedOneWithoutGamesInput = {
    create?: XOR<
      GenreCreateWithoutGamesInput,
      GenreUncheckedCreateWithoutGamesInput
    >;
    connectOrCreate?: GenreCreateOrConnectWithoutGamesInput;
    connect?: GenreWhereUniqueInput;
  };

  export type GameUpdateOneRequiredWithoutGenresNestedInput = {
    create?: XOR<
      GameCreateWithoutGenresInput,
      GameUncheckedCreateWithoutGenresInput
    >;
    connectOrCreate?: GameCreateOrConnectWithoutGenresInput;
    upsert?: GameUpsertWithoutGenresInput;
    connect?: GameWhereUniqueInput;
    update?: XOR<
      XOR<
        GameUpdateToOneWithWhereWithoutGenresInput,
        GameUpdateWithoutGenresInput
      >,
      GameUncheckedUpdateWithoutGenresInput
    >;
  };

  export type GenreUpdateOneRequiredWithoutGamesNestedInput = {
    create?: XOR<
      GenreCreateWithoutGamesInput,
      GenreUncheckedCreateWithoutGamesInput
    >;
    connectOrCreate?: GenreCreateOrConnectWithoutGamesInput;
    upsert?: GenreUpsertWithoutGamesInput;
    connect?: GenreWhereUniqueInput;
    update?: XOR<
      XOR<
        GenreUpdateToOneWithWhereWithoutGamesInput,
        GenreUpdateWithoutGamesInput
      >,
      GenreUncheckedUpdateWithoutGamesInput
    >;
  };

  export type GameCreateNestedOneWithoutScreenshotsInput = {
    create?: XOR<
      GameCreateWithoutScreenshotsInput,
      GameUncheckedCreateWithoutScreenshotsInput
    >;
    connectOrCreate?: GameCreateOrConnectWithoutScreenshotsInput;
    connect?: GameWhereUniqueInput;
  };

  export type GameUpdateOneRequiredWithoutScreenshotsNestedInput = {
    create?: XOR<
      GameCreateWithoutScreenshotsInput,
      GameUncheckedCreateWithoutScreenshotsInput
    >;
    connectOrCreate?: GameCreateOrConnectWithoutScreenshotsInput;
    upsert?: GameUpsertWithoutScreenshotsInput;
    connect?: GameWhereUniqueInput;
    update?: XOR<
      XOR<
        GameUpdateToOneWithWhereWithoutScreenshotsInput,
        GameUpdateWithoutScreenshotsInput
      >,
      GameUncheckedUpdateWithoutScreenshotsInput
    >;
  };

  export type GameCreateNestedOneWithoutReviewsInput = {
    create?: XOR<
      GameCreateWithoutReviewsInput,
      GameUncheckedCreateWithoutReviewsInput
    >;
    connectOrCreate?: GameCreateOrConnectWithoutReviewsInput;
    connect?: GameWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<
      UserCreateWithoutReviewsInput,
      UserUncheckedCreateWithoutReviewsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput;
    connect?: UserWhereUniqueInput;
  };

  export type GameUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<
      GameCreateWithoutReviewsInput,
      GameUncheckedCreateWithoutReviewsInput
    >;
    connectOrCreate?: GameCreateOrConnectWithoutReviewsInput;
    upsert?: GameUpsertWithoutReviewsInput;
    connect?: GameWhereUniqueInput;
    update?: XOR<
      XOR<
        GameUpdateToOneWithWhereWithoutReviewsInput,
        GameUpdateWithoutReviewsInput
      >,
      GameUncheckedUpdateWithoutReviewsInput
    >;
  };

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<
      UserCreateWithoutReviewsInput,
      UserUncheckedCreateWithoutReviewsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput;
    upsert?: UserUpsertWithoutReviewsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutReviewsInput,
        UserUpdateWithoutReviewsInput
      >,
      UserUncheckedUpdateWithoutReviewsInput
    >;
  };

  export type UserCreateNestedOneWithoutCartInput = {
    create?: XOR<
      UserCreateWithoutCartInput,
      UserUncheckedCreateWithoutCartInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCartInput;
    connect?: UserWhereUniqueInput;
  };

  export type CartItemCreateNestedManyWithoutCartInput = {
    create?:
      | XOR<
          CartItemCreateWithoutCartInput,
          CartItemUncheckedCreateWithoutCartInput
        >
      | CartItemCreateWithoutCartInput[]
      | CartItemUncheckedCreateWithoutCartInput[];
    connectOrCreate?:
      | CartItemCreateOrConnectWithoutCartInput
      | CartItemCreateOrConnectWithoutCartInput[];
    createMany?: CartItemCreateManyCartInputEnvelope;
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[];
  };

  export type CartItemUncheckedCreateNestedManyWithoutCartInput = {
    create?:
      | XOR<
          CartItemCreateWithoutCartInput,
          CartItemUncheckedCreateWithoutCartInput
        >
      | CartItemCreateWithoutCartInput[]
      | CartItemUncheckedCreateWithoutCartInput[];
    connectOrCreate?:
      | CartItemCreateOrConnectWithoutCartInput
      | CartItemCreateOrConnectWithoutCartInput[];
    createMany?: CartItemCreateManyCartInputEnvelope;
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[];
  };

  export type UserUpdateOneRequiredWithoutCartNestedInput = {
    create?: XOR<
      UserCreateWithoutCartInput,
      UserUncheckedCreateWithoutCartInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCartInput;
    upsert?: UserUpsertWithoutCartInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutCartInput, UserUpdateWithoutCartInput>,
      UserUncheckedUpdateWithoutCartInput
    >;
  };

  export type CartItemUpdateManyWithoutCartNestedInput = {
    create?:
      | XOR<
          CartItemCreateWithoutCartInput,
          CartItemUncheckedCreateWithoutCartInput
        >
      | CartItemCreateWithoutCartInput[]
      | CartItemUncheckedCreateWithoutCartInput[];
    connectOrCreate?:
      | CartItemCreateOrConnectWithoutCartInput
      | CartItemCreateOrConnectWithoutCartInput[];
    upsert?:
      | CartItemUpsertWithWhereUniqueWithoutCartInput
      | CartItemUpsertWithWhereUniqueWithoutCartInput[];
    createMany?: CartItemCreateManyCartInputEnvelope;
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[];
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[];
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[];
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[];
    update?:
      | CartItemUpdateWithWhereUniqueWithoutCartInput
      | CartItemUpdateWithWhereUniqueWithoutCartInput[];
    updateMany?:
      | CartItemUpdateManyWithWhereWithoutCartInput
      | CartItemUpdateManyWithWhereWithoutCartInput[];
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[];
  };

  export type CartItemUncheckedUpdateManyWithoutCartNestedInput = {
    create?:
      | XOR<
          CartItemCreateWithoutCartInput,
          CartItemUncheckedCreateWithoutCartInput
        >
      | CartItemCreateWithoutCartInput[]
      | CartItemUncheckedCreateWithoutCartInput[];
    connectOrCreate?:
      | CartItemCreateOrConnectWithoutCartInput
      | CartItemCreateOrConnectWithoutCartInput[];
    upsert?:
      | CartItemUpsertWithWhereUniqueWithoutCartInput
      | CartItemUpsertWithWhereUniqueWithoutCartInput[];
    createMany?: CartItemCreateManyCartInputEnvelope;
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[];
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[];
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[];
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[];
    update?:
      | CartItemUpdateWithWhereUniqueWithoutCartInput
      | CartItemUpdateWithWhereUniqueWithoutCartInput[];
    updateMany?:
      | CartItemUpdateManyWithWhereWithoutCartInput
      | CartItemUpdateManyWithWhereWithoutCartInput[];
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[];
  };

  export type CartCreateNestedOneWithoutItemsInput = {
    create?: XOR<
      CartCreateWithoutItemsInput,
      CartUncheckedCreateWithoutItemsInput
    >;
    connectOrCreate?: CartCreateOrConnectWithoutItemsInput;
    connect?: CartWhereUniqueInput;
  };

  export type GameCreateNestedOneWithoutCartItemsInput = {
    create?: XOR<
      GameCreateWithoutCartItemsInput,
      GameUncheckedCreateWithoutCartItemsInput
    >;
    connectOrCreate?: GameCreateOrConnectWithoutCartItemsInput;
    connect?: GameWhereUniqueInput;
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type CartUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<
      CartCreateWithoutItemsInput,
      CartUncheckedCreateWithoutItemsInput
    >;
    connectOrCreate?: CartCreateOrConnectWithoutItemsInput;
    upsert?: CartUpsertWithoutItemsInput;
    connect?: CartWhereUniqueInput;
    update?: XOR<
      XOR<
        CartUpdateToOneWithWhereWithoutItemsInput,
        CartUpdateWithoutItemsInput
      >,
      CartUncheckedUpdateWithoutItemsInput
    >;
  };

  export type GameUpdateOneRequiredWithoutCartItemsNestedInput = {
    create?: XOR<
      GameCreateWithoutCartItemsInput,
      GameUncheckedCreateWithoutCartItemsInput
    >;
    connectOrCreate?: GameCreateOrConnectWithoutCartItemsInput;
    upsert?: GameUpsertWithoutCartItemsInput;
    connect?: GameWhereUniqueInput;
    update?: XOR<
      XOR<
        GameUpdateToOneWithWhereWithoutCartItemsInput,
        GameUpdateWithoutCartItemsInput
      >,
      GameUncheckedUpdateWithoutCartItemsInput
    >;
  };

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<
      UserCreateWithoutOrdersInput,
      UserUncheckedCreateWithoutOrdersInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput;
    connect?: UserWhereUniqueInput;
  };

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?:
      | XOR<
          OrderItemCreateWithoutOrderInput,
          OrderItemUncheckedCreateWithoutOrderInput
        >
      | OrderItemCreateWithoutOrderInput[]
      | OrderItemUncheckedCreateWithoutOrderInput[];
    connectOrCreate?:
      | OrderItemCreateOrConnectWithoutOrderInput
      | OrderItemCreateOrConnectWithoutOrderInput[];
    createMany?: OrderItemCreateManyOrderInputEnvelope;
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
  };

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?:
      | XOR<
          OrderItemCreateWithoutOrderInput,
          OrderItemUncheckedCreateWithoutOrderInput
        >
      | OrderItemCreateWithoutOrderInput[]
      | OrderItemUncheckedCreateWithoutOrderInput[];
    connectOrCreate?:
      | OrderItemCreateOrConnectWithoutOrderInput
      | OrderItemCreateOrConnectWithoutOrderInput[];
    createMany?: OrderItemCreateManyOrderInputEnvelope;
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
  };

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<
      UserCreateWithoutOrdersInput,
      UserUncheckedCreateWithoutOrdersInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput;
    upsert?: UserUpsertWithoutOrdersInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutOrdersInput,
        UserUpdateWithoutOrdersInput
      >,
      UserUncheckedUpdateWithoutOrdersInput
    >;
  };

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?:
      | XOR<
          OrderItemCreateWithoutOrderInput,
          OrderItemUncheckedCreateWithoutOrderInput
        >
      | OrderItemCreateWithoutOrderInput[]
      | OrderItemUncheckedCreateWithoutOrderInput[];
    connectOrCreate?:
      | OrderItemCreateOrConnectWithoutOrderInput
      | OrderItemCreateOrConnectWithoutOrderInput[];
    upsert?:
      | OrderItemUpsertWithWhereUniqueWithoutOrderInput
      | OrderItemUpsertWithWhereUniqueWithoutOrderInput[];
    createMany?: OrderItemCreateManyOrderInputEnvelope;
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    update?:
      | OrderItemUpdateWithWhereUniqueWithoutOrderInput
      | OrderItemUpdateWithWhereUniqueWithoutOrderInput[];
    updateMany?:
      | OrderItemUpdateManyWithWhereWithoutOrderInput
      | OrderItemUpdateManyWithWhereWithoutOrderInput[];
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[];
  };

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?:
      | XOR<
          OrderItemCreateWithoutOrderInput,
          OrderItemUncheckedCreateWithoutOrderInput
        >
      | OrderItemCreateWithoutOrderInput[]
      | OrderItemUncheckedCreateWithoutOrderInput[];
    connectOrCreate?:
      | OrderItemCreateOrConnectWithoutOrderInput
      | OrderItemCreateOrConnectWithoutOrderInput[];
    upsert?:
      | OrderItemUpsertWithWhereUniqueWithoutOrderInput
      | OrderItemUpsertWithWhereUniqueWithoutOrderInput[];
    createMany?: OrderItemCreateManyOrderInputEnvelope;
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[];
    update?:
      | OrderItemUpdateWithWhereUniqueWithoutOrderInput
      | OrderItemUpdateWithWhereUniqueWithoutOrderInput[];
    updateMany?:
      | OrderItemUpdateManyWithWhereWithoutOrderInput
      | OrderItemUpdateManyWithWhereWithoutOrderInput[];
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[];
  };

  export type GameCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<
      GameCreateWithoutOrderItemsInput,
      GameUncheckedCreateWithoutOrderItemsInput
    >;
    connectOrCreate?: GameCreateOrConnectWithoutOrderItemsInput;
    connect?: GameWhereUniqueInput;
  };

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<
      OrderCreateWithoutItemsInput,
      OrderUncheckedCreateWithoutItemsInput
    >;
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput;
    connect?: OrderWhereUniqueInput;
  };

  export type GameUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<
      GameCreateWithoutOrderItemsInput,
      GameUncheckedCreateWithoutOrderItemsInput
    >;
    connectOrCreate?: GameCreateOrConnectWithoutOrderItemsInput;
    upsert?: GameUpsertWithoutOrderItemsInput;
    connect?: GameWhereUniqueInput;
    update?: XOR<
      XOR<
        GameUpdateToOneWithWhereWithoutOrderItemsInput,
        GameUpdateWithoutOrderItemsInput
      >,
      GameUncheckedUpdateWithoutOrderItemsInput
    >;
  };

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<
      OrderCreateWithoutItemsInput,
      OrderUncheckedCreateWithoutItemsInput
    >;
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput;
    upsert?: OrderUpsertWithoutItemsInput;
    connect?: OrderWhereUniqueInput;
    update?: XOR<
      XOR<
        OrderUpdateToOneWithWhereWithoutItemsInput,
        OrderUpdateWithoutItemsInput
      >,
      OrderUncheckedUpdateWithoutItemsInput
    >;
  };

  export type GameCreateNestedOneWithoutFeaturedGamesInput = {
    create?: XOR<
      GameCreateWithoutFeaturedGamesInput,
      GameUncheckedCreateWithoutFeaturedGamesInput
    >;
    connectOrCreate?: GameCreateOrConnectWithoutFeaturedGamesInput;
    connect?: GameWhereUniqueInput;
  };

  export type GameUpdateOneRequiredWithoutFeaturedGamesNestedInput = {
    create?: XOR<
      GameCreateWithoutFeaturedGamesInput,
      GameUncheckedCreateWithoutFeaturedGamesInput
    >;
    connectOrCreate?: GameCreateOrConnectWithoutFeaturedGamesInput;
    upsert?: GameUpsertWithoutFeaturedGamesInput;
    connect?: GameWhereUniqueInput;
    update?: XOR<
      XOR<
        GameUpdateToOneWithWhereWithoutFeaturedGamesInput,
        GameUpdateWithoutFeaturedGamesInput
      >,
      GameUncheckedUpdateWithoutFeaturedGamesInput
    >;
  };

  export type GameCreateNestedOneWithoutRecommendedMainInput = {
    create?: XOR<
      GameCreateWithoutRecommendedMainInput,
      GameUncheckedCreateWithoutRecommendedMainInput
    >;
    connectOrCreate?: GameCreateOrConnectWithoutRecommendedMainInput;
    connect?: GameWhereUniqueInput;
  };

  export type GameCreateNestedOneWithoutRecommendedRelInput = {
    create?: XOR<
      GameCreateWithoutRecommendedRelInput,
      GameUncheckedCreateWithoutRecommendedRelInput
    >;
    connectOrCreate?: GameCreateOrConnectWithoutRecommendedRelInput;
    connect?: GameWhereUniqueInput;
  };

  export type EnumRecommendationTypeFieldUpdateOperationsInput = {
    set?: $Enums.RecommendationType;
  };

  export type GameUpdateOneRequiredWithoutRecommendedMainNestedInput = {
    create?: XOR<
      GameCreateWithoutRecommendedMainInput,
      GameUncheckedCreateWithoutRecommendedMainInput
    >;
    connectOrCreate?: GameCreateOrConnectWithoutRecommendedMainInput;
    upsert?: GameUpsertWithoutRecommendedMainInput;
    connect?: GameWhereUniqueInput;
    update?: XOR<
      XOR<
        GameUpdateToOneWithWhereWithoutRecommendedMainInput,
        GameUpdateWithoutRecommendedMainInput
      >,
      GameUncheckedUpdateWithoutRecommendedMainInput
    >;
  };

  export type GameUpdateOneWithoutRecommendedRelNestedInput = {
    create?: XOR<
      GameCreateWithoutRecommendedRelInput,
      GameUncheckedCreateWithoutRecommendedRelInput
    >;
    connectOrCreate?: GameCreateOrConnectWithoutRecommendedRelInput;
    upsert?: GameUpsertWithoutRecommendedRelInput;
    disconnect?: GameWhereInput | boolean;
    delete?: GameWhereInput | boolean;
    connect?: GameWhereUniqueInput;
    update?: XOR<
      XOR<
        GameUpdateToOneWithWhereWithoutRecommendedRelInput,
        GameUpdateWithoutRecommendedRelInput
      >,
      GameUncheckedUpdateWithoutRecommendedRelInput
    >;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
      notIn?:
        | Date[]
        | string[]
        | ListDateTimeFieldRefInput<$PrismaModel>
        | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?:
        | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
        | Date
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedDateTimeNullableFilter<$PrismaModel>;
      _max?: NestedDateTimeNullableFilter<$PrismaModel>;
    };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedEnumGameStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumGameStatusFilter<$PrismaModel> | $Enums.GameStatus;
  };

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type NestedEnumGameStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumGameStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.GameStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumGameStatusFilter<$PrismaModel>;
    _max?: NestedEnumGameStatusFilter<$PrismaModel>;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedEnumRecommendationTypeFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.RecommendationType
      | EnumRecommendationTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.RecommendationType[]
      | ListEnumRecommendationTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.RecommendationType[]
      | ListEnumRecommendationTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumRecommendationTypeFilter<$PrismaModel>
      | $Enums.RecommendationType;
  };

  export type NestedEnumRecommendationTypeWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.RecommendationType
      | EnumRecommendationTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.RecommendationType[]
      | ListEnumRecommendationTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.RecommendationType[]
      | ListEnumRecommendationTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumRecommendationTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.RecommendationType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRecommendationTypeFilter<$PrismaModel>;
    _max?: NestedEnumRecommendationTypeFilter<$PrismaModel>;
  };

  export type AccountCreateWithoutUserInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput;
    create: XOR<
      AccountCreateWithoutUserInput,
      AccountUncheckedCreateWithoutUserInput
    >;
  };

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type SessionCreateWithoutUserInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
  };

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
  };

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput;
    create: XOR<
      SessionCreateWithoutUserInput,
      SessionUncheckedCreateWithoutUserInput
    >;
  };

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type CartCreateWithoutUserInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    items?: CartItemCreateNestedManyWithoutCartInput;
  };

  export type CartUncheckedCreateWithoutUserInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput;
  };

  export type CartCreateOrConnectWithoutUserInput = {
    where: CartWhereUniqueInput;
    create: XOR<
      CartCreateWithoutUserInput,
      CartUncheckedCreateWithoutUserInput
    >;
  };

  export type OrderCreateWithoutUserInput = {
    id?: string;
    totalAmount: number;
    status?: string;
    createdAt?: Date | string;
    items?: OrderItemCreateNestedManyWithoutOrderInput;
  };

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string;
    totalAmount: number;
    status?: string;
    createdAt?: Date | string;
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput;
  };

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput;
    create: XOR<
      OrderCreateWithoutUserInput,
      OrderUncheckedCreateWithoutUserInput
    >;
  };

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type ReviewCreateWithoutUserInput = {
    id?: string;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    game: GameCreateNestedOneWithoutReviewsInput;
  };

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: string;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    gameId: string;
  };

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput;
    create: XOR<
      ReviewCreateWithoutUserInput,
      ReviewUncheckedCreateWithoutUserInput
    >;
  };

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput;
    update: XOR<
      AccountUpdateWithoutUserInput,
      AccountUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      AccountCreateWithoutUserInput,
      AccountUncheckedCreateWithoutUserInput
    >;
  };

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput;
    data: XOR<
      AccountUpdateWithoutUserInput,
      AccountUncheckedUpdateWithoutUserInput
    >;
  };

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput;
    data: XOR<
      AccountUpdateManyMutationInput,
      AccountUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[];
    OR?: AccountScalarWhereInput[];
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[];
    id?: StringFilter<"Account"> | string;
    userId?: StringFilter<"Account"> | string;
    type?: StringFilter<"Account"> | string;
    provider?: StringFilter<"Account"> | string;
    providerAccountId?: StringFilter<"Account"> | string;
    refresh_token?: StringNullableFilter<"Account"> | string | null;
    access_token?: StringNullableFilter<"Account"> | string | null;
    expires_at?: IntNullableFilter<"Account"> | number | null;
    token_type?: StringNullableFilter<"Account"> | string | null;
    scope?: StringNullableFilter<"Account"> | string | null;
    id_token?: StringNullableFilter<"Account"> | string | null;
    session_state?: StringNullableFilter<"Account"> | string | null;
  };

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput;
    update: XOR<
      SessionUpdateWithoutUserInput,
      SessionUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      SessionCreateWithoutUserInput,
      SessionUncheckedCreateWithoutUserInput
    >;
  };

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput;
    data: XOR<
      SessionUpdateWithoutUserInput,
      SessionUncheckedUpdateWithoutUserInput
    >;
  };

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput;
    data: XOR<
      SessionUpdateManyMutationInput,
      SessionUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[];
    OR?: SessionScalarWhereInput[];
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[];
    id?: StringFilter<"Session"> | string;
    sessionToken?: StringFilter<"Session"> | string;
    userId?: StringFilter<"Session"> | string;
    expires?: DateTimeFilter<"Session"> | Date | string;
  };

  export type CartUpsertWithoutUserInput = {
    update: XOR<
      CartUpdateWithoutUserInput,
      CartUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      CartCreateWithoutUserInput,
      CartUncheckedCreateWithoutUserInput
    >;
    where?: CartWhereInput;
  };

  export type CartUpdateToOneWithWhereWithoutUserInput = {
    where?: CartWhereInput;
    data: XOR<CartUpdateWithoutUserInput, CartUncheckedUpdateWithoutUserInput>;
  };

  export type CartUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    items?: CartItemUpdateManyWithoutCartNestedInput;
  };

  export type CartUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput;
  };

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput;
    update: XOR<
      OrderUpdateWithoutUserInput,
      OrderUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      OrderCreateWithoutUserInput,
      OrderUncheckedCreateWithoutUserInput
    >;
  };

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput;
    data: XOR<
      OrderUpdateWithoutUserInput,
      OrderUncheckedUpdateWithoutUserInput
    >;
  };

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput;
    data: XOR<
      OrderUpdateManyMutationInput,
      OrderUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[];
    OR?: OrderScalarWhereInput[];
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[];
    id?: StringFilter<"Order"> | string;
    userId?: StringFilter<"Order"> | string;
    totalAmount?: FloatFilter<"Order"> | number;
    status?: StringFilter<"Order"> | string;
    createdAt?: DateTimeFilter<"Order"> | Date | string;
  };

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput;
    update: XOR<
      ReviewUpdateWithoutUserInput,
      ReviewUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      ReviewCreateWithoutUserInput,
      ReviewUncheckedCreateWithoutUserInput
    >;
  };

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput;
    data: XOR<
      ReviewUpdateWithoutUserInput,
      ReviewUncheckedUpdateWithoutUserInput
    >;
  };

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput;
    data: XOR<
      ReviewUpdateManyMutationInput,
      ReviewUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
    OR?: ReviewScalarWhereInput[];
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
    id?: StringFilter<"Review"> | string;
    rating?: FloatFilter<"Review"> | number;
    comment?: StringNullableFilter<"Review"> | string | null;
    createdAt?: DateTimeFilter<"Review"> | Date | string;
    userId?: StringFilter<"Review"> | string;
    gameId?: StringFilter<"Review"> | string;
  };

  export type UserCreateWithoutAccountsInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    address?: string | null;
    phone?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    cart?: CartCreateNestedOneWithoutUserInput;
    orders?: OrderCreateNestedManyWithoutUserInput;
    reviews?: ReviewCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    address?: string | null;
    phone?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    cart?: CartUncheckedCreateNestedOneWithoutUserInput;
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutAccountsInput,
      UserUncheckedCreateWithoutAccountsInput
    >;
  };

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<
      UserUpdateWithoutAccountsInput,
      UserUncheckedUpdateWithoutAccountsInput
    >;
    create: XOR<
      UserCreateWithoutAccountsInput,
      UserUncheckedCreateWithoutAccountsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutAccountsInput,
      UserUncheckedUpdateWithoutAccountsInput
    >;
  };

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    cart?: CartUpdateOneWithoutUserNestedInput;
    orders?: OrderUpdateManyWithoutUserNestedInput;
    reviews?: ReviewUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    cart?: CartUncheckedUpdateOneWithoutUserNestedInput;
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateWithoutSessionsInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    address?: string | null;
    phone?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    cart?: CartCreateNestedOneWithoutUserInput;
    orders?: OrderCreateNestedManyWithoutUserInput;
    reviews?: ReviewCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    address?: string | null;
    phone?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    cart?: CartUncheckedCreateNestedOneWithoutUserInput;
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutSessionsInput,
      UserUncheckedCreateWithoutSessionsInput
    >;
  };

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<
      UserUpdateWithoutSessionsInput,
      UserUncheckedUpdateWithoutSessionsInput
    >;
    create: XOR<
      UserCreateWithoutSessionsInput,
      UserUncheckedCreateWithoutSessionsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutSessionsInput,
      UserUncheckedUpdateWithoutSessionsInput
    >;
  };

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    cart?: CartUpdateOneWithoutUserNestedInput;
    orders?: OrderUpdateManyWithoutUserNestedInput;
    reviews?: ReviewUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    cart?: CartUncheckedUpdateOneWithoutUserNestedInput;
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type CartItemCreateWithoutGameInput = {
    id?: string;
    quantity?: number;
    addedAt?: Date | string;
    cart: CartCreateNestedOneWithoutItemsInput;
  };

  export type CartItemUncheckedCreateWithoutGameInput = {
    id?: string;
    cartId: string;
    quantity?: number;
    addedAt?: Date | string;
  };

  export type CartItemCreateOrConnectWithoutGameInput = {
    where: CartItemWhereUniqueInput;
    create: XOR<
      CartItemCreateWithoutGameInput,
      CartItemUncheckedCreateWithoutGameInput
    >;
  };

  export type CartItemCreateManyGameInputEnvelope = {
    data: CartItemCreateManyGameInput | CartItemCreateManyGameInput[];
    skipDuplicates?: boolean;
  };

  export type GameGenreCreateWithoutGameInput = {
    genre: GenreCreateNestedOneWithoutGamesInput;
  };

  export type GameGenreUncheckedCreateWithoutGameInput = {
    genreId: string;
  };

  export type GameGenreCreateOrConnectWithoutGameInput = {
    where: GameGenreWhereUniqueInput;
    create: XOR<
      GameGenreCreateWithoutGameInput,
      GameGenreUncheckedCreateWithoutGameInput
    >;
  };

  export type GameGenreCreateManyGameInputEnvelope = {
    data: GameGenreCreateManyGameInput | GameGenreCreateManyGameInput[];
    skipDuplicates?: boolean;
  };

  export type OrderItemCreateWithoutGameInput = {
    id?: string;
    price: number;
    quantity: number;
    order: OrderCreateNestedOneWithoutItemsInput;
  };

  export type OrderItemUncheckedCreateWithoutGameInput = {
    id?: string;
    orderId: string;
    price: number;
    quantity: number;
  };

  export type OrderItemCreateOrConnectWithoutGameInput = {
    where: OrderItemWhereUniqueInput;
    create: XOR<
      OrderItemCreateWithoutGameInput,
      OrderItemUncheckedCreateWithoutGameInput
    >;
  };

  export type OrderItemCreateManyGameInputEnvelope = {
    data: OrderItemCreateManyGameInput | OrderItemCreateManyGameInput[];
    skipDuplicates?: boolean;
  };

  export type ReviewCreateWithoutGameInput = {
    id?: string;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutReviewsInput;
  };

  export type ReviewUncheckedCreateWithoutGameInput = {
    id?: string;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    userId: string;
  };

  export type ReviewCreateOrConnectWithoutGameInput = {
    where: ReviewWhereUniqueInput;
    create: XOR<
      ReviewCreateWithoutGameInput,
      ReviewUncheckedCreateWithoutGameInput
    >;
  };

  export type ReviewCreateManyGameInputEnvelope = {
    data: ReviewCreateManyGameInput | ReviewCreateManyGameInput[];
    skipDuplicates?: boolean;
  };

  export type ScreenshotCreateWithoutGameInput = {
    id?: string;
    imageUrl: string;
    caption?: string | null;
  };

  export type ScreenshotUncheckedCreateWithoutGameInput = {
    id?: string;
    imageUrl: string;
    caption?: string | null;
  };

  export type ScreenshotCreateOrConnectWithoutGameInput = {
    where: ScreenshotWhereUniqueInput;
    create: XOR<
      ScreenshotCreateWithoutGameInput,
      ScreenshotUncheckedCreateWithoutGameInput
    >;
  };

  export type ScreenshotCreateManyGameInputEnvelope = {
    data: ScreenshotCreateManyGameInput | ScreenshotCreateManyGameInput[];
    skipDuplicates?: boolean;
  };

  export type FeaturedGameCreateWithoutGameInput = {
    id?: string;
    startDate: Date | string;
    endDate: Date | string;
    priority?: number;
    createdAt?: Date | string;
  };

  export type FeaturedGameUncheckedCreateWithoutGameInput = {
    id?: string;
    startDate: Date | string;
    endDate: Date | string;
    priority?: number;
    createdAt?: Date | string;
  };

  export type FeaturedGameCreateOrConnectWithoutGameInput = {
    where: FeaturedGameWhereUniqueInput;
    create: XOR<
      FeaturedGameCreateWithoutGameInput,
      FeaturedGameUncheckedCreateWithoutGameInput
    >;
  };

  export type FeaturedGameCreateManyGameInputEnvelope = {
    data: FeaturedGameCreateManyGameInput | FeaturedGameCreateManyGameInput[];
    skipDuplicates?: boolean;
  };

  export type RecommendedGameCreateWithoutGameInput = {
    id?: string;
    recommendationType: $Enums.RecommendationType;
    startDate: Date | string;
    endDate?: Date | string | null;
    priority?: number;
    createdAt?: Date | string;
    relatedGame?: GameCreateNestedOneWithoutRecommendedRelInput;
  };

  export type RecommendedGameUncheckedCreateWithoutGameInput = {
    id?: string;
    recommendationType: $Enums.RecommendationType;
    relatedGameId?: string | null;
    startDate: Date | string;
    endDate?: Date | string | null;
    priority?: number;
    createdAt?: Date | string;
  };

  export type RecommendedGameCreateOrConnectWithoutGameInput = {
    where: RecommendedGameWhereUniqueInput;
    create: XOR<
      RecommendedGameCreateWithoutGameInput,
      RecommendedGameUncheckedCreateWithoutGameInput
    >;
  };

  export type RecommendedGameCreateManyGameInputEnvelope = {
    data:
      | RecommendedGameCreateManyGameInput
      | RecommendedGameCreateManyGameInput[];
    skipDuplicates?: boolean;
  };

  export type RecommendedGameCreateWithoutRelatedGameInput = {
    id?: string;
    recommendationType: $Enums.RecommendationType;
    startDate: Date | string;
    endDate?: Date | string | null;
    priority?: number;
    createdAt?: Date | string;
    game: GameCreateNestedOneWithoutRecommendedMainInput;
  };

  export type RecommendedGameUncheckedCreateWithoutRelatedGameInput = {
    id?: string;
    gameId: string;
    recommendationType: $Enums.RecommendationType;
    startDate: Date | string;
    endDate?: Date | string | null;
    priority?: number;
    createdAt?: Date | string;
  };

  export type RecommendedGameCreateOrConnectWithoutRelatedGameInput = {
    where: RecommendedGameWhereUniqueInput;
    create: XOR<
      RecommendedGameCreateWithoutRelatedGameInput,
      RecommendedGameUncheckedCreateWithoutRelatedGameInput
    >;
  };

  export type RecommendedGameCreateManyRelatedGameInputEnvelope = {
    data:
      | RecommendedGameCreateManyRelatedGameInput
      | RecommendedGameCreateManyRelatedGameInput[];
    skipDuplicates?: boolean;
  };

  export type CartItemUpsertWithWhereUniqueWithoutGameInput = {
    where: CartItemWhereUniqueInput;
    update: XOR<
      CartItemUpdateWithoutGameInput,
      CartItemUncheckedUpdateWithoutGameInput
    >;
    create: XOR<
      CartItemCreateWithoutGameInput,
      CartItemUncheckedCreateWithoutGameInput
    >;
  };

  export type CartItemUpdateWithWhereUniqueWithoutGameInput = {
    where: CartItemWhereUniqueInput;
    data: XOR<
      CartItemUpdateWithoutGameInput,
      CartItemUncheckedUpdateWithoutGameInput
    >;
  };

  export type CartItemUpdateManyWithWhereWithoutGameInput = {
    where: CartItemScalarWhereInput;
    data: XOR<
      CartItemUpdateManyMutationInput,
      CartItemUncheckedUpdateManyWithoutGameInput
    >;
  };

  export type CartItemScalarWhereInput = {
    AND?: CartItemScalarWhereInput | CartItemScalarWhereInput[];
    OR?: CartItemScalarWhereInput[];
    NOT?: CartItemScalarWhereInput | CartItemScalarWhereInput[];
    id?: StringFilter<"CartItem"> | string;
    cartId?: StringFilter<"CartItem"> | string;
    gameId?: StringFilter<"CartItem"> | string;
    quantity?: IntFilter<"CartItem"> | number;
    addedAt?: DateTimeFilter<"CartItem"> | Date | string;
  };

  export type GameGenreUpsertWithWhereUniqueWithoutGameInput = {
    where: GameGenreWhereUniqueInput;
    update: XOR<
      GameGenreUpdateWithoutGameInput,
      GameGenreUncheckedUpdateWithoutGameInput
    >;
    create: XOR<
      GameGenreCreateWithoutGameInput,
      GameGenreUncheckedCreateWithoutGameInput
    >;
  };

  export type GameGenreUpdateWithWhereUniqueWithoutGameInput = {
    where: GameGenreWhereUniqueInput;
    data: XOR<
      GameGenreUpdateWithoutGameInput,
      GameGenreUncheckedUpdateWithoutGameInput
    >;
  };

  export type GameGenreUpdateManyWithWhereWithoutGameInput = {
    where: GameGenreScalarWhereInput;
    data: XOR<
      GameGenreUpdateManyMutationInput,
      GameGenreUncheckedUpdateManyWithoutGameInput
    >;
  };

  export type GameGenreScalarWhereInput = {
    AND?: GameGenreScalarWhereInput | GameGenreScalarWhereInput[];
    OR?: GameGenreScalarWhereInput[];
    NOT?: GameGenreScalarWhereInput | GameGenreScalarWhereInput[];
    gameId?: StringFilter<"GameGenre"> | string;
    genreId?: StringFilter<"GameGenre"> | string;
  };

  export type OrderItemUpsertWithWhereUniqueWithoutGameInput = {
    where: OrderItemWhereUniqueInput;
    update: XOR<
      OrderItemUpdateWithoutGameInput,
      OrderItemUncheckedUpdateWithoutGameInput
    >;
    create: XOR<
      OrderItemCreateWithoutGameInput,
      OrderItemUncheckedCreateWithoutGameInput
    >;
  };

  export type OrderItemUpdateWithWhereUniqueWithoutGameInput = {
    where: OrderItemWhereUniqueInput;
    data: XOR<
      OrderItemUpdateWithoutGameInput,
      OrderItemUncheckedUpdateWithoutGameInput
    >;
  };

  export type OrderItemUpdateManyWithWhereWithoutGameInput = {
    where: OrderItemScalarWhereInput;
    data: XOR<
      OrderItemUpdateManyMutationInput,
      OrderItemUncheckedUpdateManyWithoutGameInput
    >;
  };

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[];
    OR?: OrderItemScalarWhereInput[];
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[];
    id?: StringFilter<"OrderItem"> | string;
    orderId?: StringFilter<"OrderItem"> | string;
    gameId?: StringFilter<"OrderItem"> | string;
    price?: FloatFilter<"OrderItem"> | number;
    quantity?: IntFilter<"OrderItem"> | number;
  };

  export type ReviewUpsertWithWhereUniqueWithoutGameInput = {
    where: ReviewWhereUniqueInput;
    update: XOR<
      ReviewUpdateWithoutGameInput,
      ReviewUncheckedUpdateWithoutGameInput
    >;
    create: XOR<
      ReviewCreateWithoutGameInput,
      ReviewUncheckedCreateWithoutGameInput
    >;
  };

  export type ReviewUpdateWithWhereUniqueWithoutGameInput = {
    where: ReviewWhereUniqueInput;
    data: XOR<
      ReviewUpdateWithoutGameInput,
      ReviewUncheckedUpdateWithoutGameInput
    >;
  };

  export type ReviewUpdateManyWithWhereWithoutGameInput = {
    where: ReviewScalarWhereInput;
    data: XOR<
      ReviewUpdateManyMutationInput,
      ReviewUncheckedUpdateManyWithoutGameInput
    >;
  };

  export type ScreenshotUpsertWithWhereUniqueWithoutGameInput = {
    where: ScreenshotWhereUniqueInput;
    update: XOR<
      ScreenshotUpdateWithoutGameInput,
      ScreenshotUncheckedUpdateWithoutGameInput
    >;
    create: XOR<
      ScreenshotCreateWithoutGameInput,
      ScreenshotUncheckedCreateWithoutGameInput
    >;
  };

  export type ScreenshotUpdateWithWhereUniqueWithoutGameInput = {
    where: ScreenshotWhereUniqueInput;
    data: XOR<
      ScreenshotUpdateWithoutGameInput,
      ScreenshotUncheckedUpdateWithoutGameInput
    >;
  };

  export type ScreenshotUpdateManyWithWhereWithoutGameInput = {
    where: ScreenshotScalarWhereInput;
    data: XOR<
      ScreenshotUpdateManyMutationInput,
      ScreenshotUncheckedUpdateManyWithoutGameInput
    >;
  };

  export type ScreenshotScalarWhereInput = {
    AND?: ScreenshotScalarWhereInput | ScreenshotScalarWhereInput[];
    OR?: ScreenshotScalarWhereInput[];
    NOT?: ScreenshotScalarWhereInput | ScreenshotScalarWhereInput[];
    id?: StringFilter<"Screenshot"> | string;
    gameId?: StringFilter<"Screenshot"> | string;
    imageUrl?: StringFilter<"Screenshot"> | string;
    caption?: StringNullableFilter<"Screenshot"> | string | null;
  };

  export type FeaturedGameUpsertWithWhereUniqueWithoutGameInput = {
    where: FeaturedGameWhereUniqueInput;
    update: XOR<
      FeaturedGameUpdateWithoutGameInput,
      FeaturedGameUncheckedUpdateWithoutGameInput
    >;
    create: XOR<
      FeaturedGameCreateWithoutGameInput,
      FeaturedGameUncheckedCreateWithoutGameInput
    >;
  };

  export type FeaturedGameUpdateWithWhereUniqueWithoutGameInput = {
    where: FeaturedGameWhereUniqueInput;
    data: XOR<
      FeaturedGameUpdateWithoutGameInput,
      FeaturedGameUncheckedUpdateWithoutGameInput
    >;
  };

  export type FeaturedGameUpdateManyWithWhereWithoutGameInput = {
    where: FeaturedGameScalarWhereInput;
    data: XOR<
      FeaturedGameUpdateManyMutationInput,
      FeaturedGameUncheckedUpdateManyWithoutGameInput
    >;
  };

  export type FeaturedGameScalarWhereInput = {
    AND?: FeaturedGameScalarWhereInput | FeaturedGameScalarWhereInput[];
    OR?: FeaturedGameScalarWhereInput[];
    NOT?: FeaturedGameScalarWhereInput | FeaturedGameScalarWhereInput[];
    id?: StringFilter<"FeaturedGame"> | string;
    gameId?: StringFilter<"FeaturedGame"> | string;
    startDate?: DateTimeFilter<"FeaturedGame"> | Date | string;
    endDate?: DateTimeFilter<"FeaturedGame"> | Date | string;
    priority?: IntFilter<"FeaturedGame"> | number;
    createdAt?: DateTimeFilter<"FeaturedGame"> | Date | string;
  };

  export type RecommendedGameUpsertWithWhereUniqueWithoutGameInput = {
    where: RecommendedGameWhereUniqueInput;
    update: XOR<
      RecommendedGameUpdateWithoutGameInput,
      RecommendedGameUncheckedUpdateWithoutGameInput
    >;
    create: XOR<
      RecommendedGameCreateWithoutGameInput,
      RecommendedGameUncheckedCreateWithoutGameInput
    >;
  };

  export type RecommendedGameUpdateWithWhereUniqueWithoutGameInput = {
    where: RecommendedGameWhereUniqueInput;
    data: XOR<
      RecommendedGameUpdateWithoutGameInput,
      RecommendedGameUncheckedUpdateWithoutGameInput
    >;
  };

  export type RecommendedGameUpdateManyWithWhereWithoutGameInput = {
    where: RecommendedGameScalarWhereInput;
    data: XOR<
      RecommendedGameUpdateManyMutationInput,
      RecommendedGameUncheckedUpdateManyWithoutGameInput
    >;
  };

  export type RecommendedGameScalarWhereInput = {
    AND?: RecommendedGameScalarWhereInput | RecommendedGameScalarWhereInput[];
    OR?: RecommendedGameScalarWhereInput[];
    NOT?: RecommendedGameScalarWhereInput | RecommendedGameScalarWhereInput[];
    id?: StringFilter<"RecommendedGame"> | string;
    gameId?: StringFilter<"RecommendedGame"> | string;
    recommendationType?:
      | EnumRecommendationTypeFilter<"RecommendedGame">
      | $Enums.RecommendationType;
    relatedGameId?: StringNullableFilter<"RecommendedGame"> | string | null;
    startDate?: DateTimeFilter<"RecommendedGame"> | Date | string;
    endDate?: DateTimeNullableFilter<"RecommendedGame"> | Date | string | null;
    priority?: IntFilter<"RecommendedGame"> | number;
    createdAt?: DateTimeFilter<"RecommendedGame"> | Date | string;
  };

  export type RecommendedGameUpsertWithWhereUniqueWithoutRelatedGameInput = {
    where: RecommendedGameWhereUniqueInput;
    update: XOR<
      RecommendedGameUpdateWithoutRelatedGameInput,
      RecommendedGameUncheckedUpdateWithoutRelatedGameInput
    >;
    create: XOR<
      RecommendedGameCreateWithoutRelatedGameInput,
      RecommendedGameUncheckedCreateWithoutRelatedGameInput
    >;
  };

  export type RecommendedGameUpdateWithWhereUniqueWithoutRelatedGameInput = {
    where: RecommendedGameWhereUniqueInput;
    data: XOR<
      RecommendedGameUpdateWithoutRelatedGameInput,
      RecommendedGameUncheckedUpdateWithoutRelatedGameInput
    >;
  };

  export type RecommendedGameUpdateManyWithWhereWithoutRelatedGameInput = {
    where: RecommendedGameScalarWhereInput;
    data: XOR<
      RecommendedGameUpdateManyMutationInput,
      RecommendedGameUncheckedUpdateManyWithoutRelatedGameInput
    >;
  };

  export type GameGenreCreateWithoutGenreInput = {
    game: GameCreateNestedOneWithoutGenresInput;
  };

  export type GameGenreUncheckedCreateWithoutGenreInput = {
    gameId: string;
  };

  export type GameGenreCreateOrConnectWithoutGenreInput = {
    where: GameGenreWhereUniqueInput;
    create: XOR<
      GameGenreCreateWithoutGenreInput,
      GameGenreUncheckedCreateWithoutGenreInput
    >;
  };

  export type GameGenreCreateManyGenreInputEnvelope = {
    data: GameGenreCreateManyGenreInput | GameGenreCreateManyGenreInput[];
    skipDuplicates?: boolean;
  };

  export type GenreCreateWithoutSubGenresInput = {
    id?: string;
    name: string;
    games?: GameGenreCreateNestedManyWithoutGenreInput;
    parent?: GenreCreateNestedOneWithoutSubGenresInput;
  };

  export type GenreUncheckedCreateWithoutSubGenresInput = {
    id?: string;
    name: string;
    parentId?: string | null;
    games?: GameGenreUncheckedCreateNestedManyWithoutGenreInput;
  };

  export type GenreCreateOrConnectWithoutSubGenresInput = {
    where: GenreWhereUniqueInput;
    create: XOR<
      GenreCreateWithoutSubGenresInput,
      GenreUncheckedCreateWithoutSubGenresInput
    >;
  };

  export type GenreCreateWithoutParentInput = {
    id?: string;
    name: string;
    games?: GameGenreCreateNestedManyWithoutGenreInput;
    subGenres?: GenreCreateNestedManyWithoutParentInput;
  };

  export type GenreUncheckedCreateWithoutParentInput = {
    id?: string;
    name: string;
    games?: GameGenreUncheckedCreateNestedManyWithoutGenreInput;
    subGenres?: GenreUncheckedCreateNestedManyWithoutParentInput;
  };

  export type GenreCreateOrConnectWithoutParentInput = {
    where: GenreWhereUniqueInput;
    create: XOR<
      GenreCreateWithoutParentInput,
      GenreUncheckedCreateWithoutParentInput
    >;
  };

  export type GenreCreateManyParentInputEnvelope = {
    data: GenreCreateManyParentInput | GenreCreateManyParentInput[];
    skipDuplicates?: boolean;
  };

  export type GameGenreUpsertWithWhereUniqueWithoutGenreInput = {
    where: GameGenreWhereUniqueInput;
    update: XOR<
      GameGenreUpdateWithoutGenreInput,
      GameGenreUncheckedUpdateWithoutGenreInput
    >;
    create: XOR<
      GameGenreCreateWithoutGenreInput,
      GameGenreUncheckedCreateWithoutGenreInput
    >;
  };

  export type GameGenreUpdateWithWhereUniqueWithoutGenreInput = {
    where: GameGenreWhereUniqueInput;
    data: XOR<
      GameGenreUpdateWithoutGenreInput,
      GameGenreUncheckedUpdateWithoutGenreInput
    >;
  };

  export type GameGenreUpdateManyWithWhereWithoutGenreInput = {
    where: GameGenreScalarWhereInput;
    data: XOR<
      GameGenreUpdateManyMutationInput,
      GameGenreUncheckedUpdateManyWithoutGenreInput
    >;
  };

  export type GenreUpsertWithoutSubGenresInput = {
    update: XOR<
      GenreUpdateWithoutSubGenresInput,
      GenreUncheckedUpdateWithoutSubGenresInput
    >;
    create: XOR<
      GenreCreateWithoutSubGenresInput,
      GenreUncheckedCreateWithoutSubGenresInput
    >;
    where?: GenreWhereInput;
  };

  export type GenreUpdateToOneWithWhereWithoutSubGenresInput = {
    where?: GenreWhereInput;
    data: XOR<
      GenreUpdateWithoutSubGenresInput,
      GenreUncheckedUpdateWithoutSubGenresInput
    >;
  };

  export type GenreUpdateWithoutSubGenresInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    games?: GameGenreUpdateManyWithoutGenreNestedInput;
    parent?: GenreUpdateOneWithoutSubGenresNestedInput;
  };

  export type GenreUncheckedUpdateWithoutSubGenresInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    games?: GameGenreUncheckedUpdateManyWithoutGenreNestedInput;
  };

  export type GenreUpsertWithWhereUniqueWithoutParentInput = {
    where: GenreWhereUniqueInput;
    update: XOR<
      GenreUpdateWithoutParentInput,
      GenreUncheckedUpdateWithoutParentInput
    >;
    create: XOR<
      GenreCreateWithoutParentInput,
      GenreUncheckedCreateWithoutParentInput
    >;
  };

  export type GenreUpdateWithWhereUniqueWithoutParentInput = {
    where: GenreWhereUniqueInput;
    data: XOR<
      GenreUpdateWithoutParentInput,
      GenreUncheckedUpdateWithoutParentInput
    >;
  };

  export type GenreUpdateManyWithWhereWithoutParentInput = {
    where: GenreScalarWhereInput;
    data: XOR<
      GenreUpdateManyMutationInput,
      GenreUncheckedUpdateManyWithoutParentInput
    >;
  };

  export type GenreScalarWhereInput = {
    AND?: GenreScalarWhereInput | GenreScalarWhereInput[];
    OR?: GenreScalarWhereInput[];
    NOT?: GenreScalarWhereInput | GenreScalarWhereInput[];
    id?: StringFilter<"Genre"> | string;
    name?: StringFilter<"Genre"> | string;
    parentId?: StringNullableFilter<"Genre"> | string | null;
  };

  export type GameCreateWithoutGenresInput = {
    id?: string;
    title: string;
    description: string;
    price: number;
    releaseDate: Date | string;
    developer: string;
    publisher: string;
    coverImageUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    rating?: number;
    discountedPrice?: number | null;
    status?: $Enums.GameStatus;
    cartItems?: CartItemCreateNestedManyWithoutGameInput;
    orderItems?: OrderItemCreateNestedManyWithoutGameInput;
    reviews?: ReviewCreateNestedManyWithoutGameInput;
    screenshots?: ScreenshotCreateNestedManyWithoutGameInput;
    featuredGames?: FeaturedGameCreateNestedManyWithoutGameInput;
    recommendedMain?: RecommendedGameCreateNestedManyWithoutGameInput;
    recommendedRel?: RecommendedGameCreateNestedManyWithoutRelatedGameInput;
  };

  export type GameUncheckedCreateWithoutGenresInput = {
    id?: string;
    title: string;
    description: string;
    price: number;
    releaseDate: Date | string;
    developer: string;
    publisher: string;
    coverImageUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    rating?: number;
    discountedPrice?: number | null;
    status?: $Enums.GameStatus;
    cartItems?: CartItemUncheckedCreateNestedManyWithoutGameInput;
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutGameInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutGameInput;
    screenshots?: ScreenshotUncheckedCreateNestedManyWithoutGameInput;
    featuredGames?: FeaturedGameUncheckedCreateNestedManyWithoutGameInput;
    recommendedMain?: RecommendedGameUncheckedCreateNestedManyWithoutGameInput;
    recommendedRel?: RecommendedGameUncheckedCreateNestedManyWithoutRelatedGameInput;
  };

  export type GameCreateOrConnectWithoutGenresInput = {
    where: GameWhereUniqueInput;
    create: XOR<
      GameCreateWithoutGenresInput,
      GameUncheckedCreateWithoutGenresInput
    >;
  };

  export type GenreCreateWithoutGamesInput = {
    id?: string;
    name: string;
    parent?: GenreCreateNestedOneWithoutSubGenresInput;
    subGenres?: GenreCreateNestedManyWithoutParentInput;
  };

  export type GenreUncheckedCreateWithoutGamesInput = {
    id?: string;
    name: string;
    parentId?: string | null;
    subGenres?: GenreUncheckedCreateNestedManyWithoutParentInput;
  };

  export type GenreCreateOrConnectWithoutGamesInput = {
    where: GenreWhereUniqueInput;
    create: XOR<
      GenreCreateWithoutGamesInput,
      GenreUncheckedCreateWithoutGamesInput
    >;
  };

  export type GameUpsertWithoutGenresInput = {
    update: XOR<
      GameUpdateWithoutGenresInput,
      GameUncheckedUpdateWithoutGenresInput
    >;
    create: XOR<
      GameCreateWithoutGenresInput,
      GameUncheckedCreateWithoutGenresInput
    >;
    where?: GameWhereInput;
  };

  export type GameUpdateToOneWithWhereWithoutGenresInput = {
    where?: GameWhereInput;
    data: XOR<
      GameUpdateWithoutGenresInput,
      GameUncheckedUpdateWithoutGenresInput
    >;
  };

  export type GameUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    developer?: StringFieldUpdateOperationsInput | string;
    publisher?: StringFieldUpdateOperationsInput | string;
    coverImageUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus;
    cartItems?: CartItemUpdateManyWithoutGameNestedInput;
    orderItems?: OrderItemUpdateManyWithoutGameNestedInput;
    reviews?: ReviewUpdateManyWithoutGameNestedInput;
    screenshots?: ScreenshotUpdateManyWithoutGameNestedInput;
    featuredGames?: FeaturedGameUpdateManyWithoutGameNestedInput;
    recommendedMain?: RecommendedGameUpdateManyWithoutGameNestedInput;
    recommendedRel?: RecommendedGameUpdateManyWithoutRelatedGameNestedInput;
  };

  export type GameUncheckedUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    developer?: StringFieldUpdateOperationsInput | string;
    publisher?: StringFieldUpdateOperationsInput | string;
    coverImageUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus;
    cartItems?: CartItemUncheckedUpdateManyWithoutGameNestedInput;
    orderItems?: OrderItemUncheckedUpdateManyWithoutGameNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutGameNestedInput;
    screenshots?: ScreenshotUncheckedUpdateManyWithoutGameNestedInput;
    featuredGames?: FeaturedGameUncheckedUpdateManyWithoutGameNestedInput;
    recommendedMain?: RecommendedGameUncheckedUpdateManyWithoutGameNestedInput;
    recommendedRel?: RecommendedGameUncheckedUpdateManyWithoutRelatedGameNestedInput;
  };

  export type GenreUpsertWithoutGamesInput = {
    update: XOR<
      GenreUpdateWithoutGamesInput,
      GenreUncheckedUpdateWithoutGamesInput
    >;
    create: XOR<
      GenreCreateWithoutGamesInput,
      GenreUncheckedCreateWithoutGamesInput
    >;
    where?: GenreWhereInput;
  };

  export type GenreUpdateToOneWithWhereWithoutGamesInput = {
    where?: GenreWhereInput;
    data: XOR<
      GenreUpdateWithoutGamesInput,
      GenreUncheckedUpdateWithoutGamesInput
    >;
  };

  export type GenreUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    parent?: GenreUpdateOneWithoutSubGenresNestedInput;
    subGenres?: GenreUpdateManyWithoutParentNestedInput;
  };

  export type GenreUncheckedUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    subGenres?: GenreUncheckedUpdateManyWithoutParentNestedInput;
  };

  export type GameCreateWithoutScreenshotsInput = {
    id?: string;
    title: string;
    description: string;
    price: number;
    releaseDate: Date | string;
    developer: string;
    publisher: string;
    coverImageUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    rating?: number;
    discountedPrice?: number | null;
    status?: $Enums.GameStatus;
    cartItems?: CartItemCreateNestedManyWithoutGameInput;
    genres?: GameGenreCreateNestedManyWithoutGameInput;
    orderItems?: OrderItemCreateNestedManyWithoutGameInput;
    reviews?: ReviewCreateNestedManyWithoutGameInput;
    featuredGames?: FeaturedGameCreateNestedManyWithoutGameInput;
    recommendedMain?: RecommendedGameCreateNestedManyWithoutGameInput;
    recommendedRel?: RecommendedGameCreateNestedManyWithoutRelatedGameInput;
  };

  export type GameUncheckedCreateWithoutScreenshotsInput = {
    id?: string;
    title: string;
    description: string;
    price: number;
    releaseDate: Date | string;
    developer: string;
    publisher: string;
    coverImageUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    rating?: number;
    discountedPrice?: number | null;
    status?: $Enums.GameStatus;
    cartItems?: CartItemUncheckedCreateNestedManyWithoutGameInput;
    genres?: GameGenreUncheckedCreateNestedManyWithoutGameInput;
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutGameInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutGameInput;
    featuredGames?: FeaturedGameUncheckedCreateNestedManyWithoutGameInput;
    recommendedMain?: RecommendedGameUncheckedCreateNestedManyWithoutGameInput;
    recommendedRel?: RecommendedGameUncheckedCreateNestedManyWithoutRelatedGameInput;
  };

  export type GameCreateOrConnectWithoutScreenshotsInput = {
    where: GameWhereUniqueInput;
    create: XOR<
      GameCreateWithoutScreenshotsInput,
      GameUncheckedCreateWithoutScreenshotsInput
    >;
  };

  export type GameUpsertWithoutScreenshotsInput = {
    update: XOR<
      GameUpdateWithoutScreenshotsInput,
      GameUncheckedUpdateWithoutScreenshotsInput
    >;
    create: XOR<
      GameCreateWithoutScreenshotsInput,
      GameUncheckedCreateWithoutScreenshotsInput
    >;
    where?: GameWhereInput;
  };

  export type GameUpdateToOneWithWhereWithoutScreenshotsInput = {
    where?: GameWhereInput;
    data: XOR<
      GameUpdateWithoutScreenshotsInput,
      GameUncheckedUpdateWithoutScreenshotsInput
    >;
  };

  export type GameUpdateWithoutScreenshotsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    developer?: StringFieldUpdateOperationsInput | string;
    publisher?: StringFieldUpdateOperationsInput | string;
    coverImageUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus;
    cartItems?: CartItemUpdateManyWithoutGameNestedInput;
    genres?: GameGenreUpdateManyWithoutGameNestedInput;
    orderItems?: OrderItemUpdateManyWithoutGameNestedInput;
    reviews?: ReviewUpdateManyWithoutGameNestedInput;
    featuredGames?: FeaturedGameUpdateManyWithoutGameNestedInput;
    recommendedMain?: RecommendedGameUpdateManyWithoutGameNestedInput;
    recommendedRel?: RecommendedGameUpdateManyWithoutRelatedGameNestedInput;
  };

  export type GameUncheckedUpdateWithoutScreenshotsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    developer?: StringFieldUpdateOperationsInput | string;
    publisher?: StringFieldUpdateOperationsInput | string;
    coverImageUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus;
    cartItems?: CartItemUncheckedUpdateManyWithoutGameNestedInput;
    genres?: GameGenreUncheckedUpdateManyWithoutGameNestedInput;
    orderItems?: OrderItemUncheckedUpdateManyWithoutGameNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutGameNestedInput;
    featuredGames?: FeaturedGameUncheckedUpdateManyWithoutGameNestedInput;
    recommendedMain?: RecommendedGameUncheckedUpdateManyWithoutGameNestedInput;
    recommendedRel?: RecommendedGameUncheckedUpdateManyWithoutRelatedGameNestedInput;
  };

  export type GameCreateWithoutReviewsInput = {
    id?: string;
    title: string;
    description: string;
    price: number;
    releaseDate: Date | string;
    developer: string;
    publisher: string;
    coverImageUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    rating?: number;
    discountedPrice?: number | null;
    status?: $Enums.GameStatus;
    cartItems?: CartItemCreateNestedManyWithoutGameInput;
    genres?: GameGenreCreateNestedManyWithoutGameInput;
    orderItems?: OrderItemCreateNestedManyWithoutGameInput;
    screenshots?: ScreenshotCreateNestedManyWithoutGameInput;
    featuredGames?: FeaturedGameCreateNestedManyWithoutGameInput;
    recommendedMain?: RecommendedGameCreateNestedManyWithoutGameInput;
    recommendedRel?: RecommendedGameCreateNestedManyWithoutRelatedGameInput;
  };

  export type GameUncheckedCreateWithoutReviewsInput = {
    id?: string;
    title: string;
    description: string;
    price: number;
    releaseDate: Date | string;
    developer: string;
    publisher: string;
    coverImageUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    rating?: number;
    discountedPrice?: number | null;
    status?: $Enums.GameStatus;
    cartItems?: CartItemUncheckedCreateNestedManyWithoutGameInput;
    genres?: GameGenreUncheckedCreateNestedManyWithoutGameInput;
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutGameInput;
    screenshots?: ScreenshotUncheckedCreateNestedManyWithoutGameInput;
    featuredGames?: FeaturedGameUncheckedCreateNestedManyWithoutGameInput;
    recommendedMain?: RecommendedGameUncheckedCreateNestedManyWithoutGameInput;
    recommendedRel?: RecommendedGameUncheckedCreateNestedManyWithoutRelatedGameInput;
  };

  export type GameCreateOrConnectWithoutReviewsInput = {
    where: GameWhereUniqueInput;
    create: XOR<
      GameCreateWithoutReviewsInput,
      GameUncheckedCreateWithoutReviewsInput
    >;
  };

  export type UserCreateWithoutReviewsInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    address?: string | null;
    phone?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    cart?: CartCreateNestedOneWithoutUserInput;
    orders?: OrderCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    address?: string | null;
    phone?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    cart?: CartUncheckedCreateNestedOneWithoutUserInput;
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutReviewsInput,
      UserUncheckedCreateWithoutReviewsInput
    >;
  };

  export type GameUpsertWithoutReviewsInput = {
    update: XOR<
      GameUpdateWithoutReviewsInput,
      GameUncheckedUpdateWithoutReviewsInput
    >;
    create: XOR<
      GameCreateWithoutReviewsInput,
      GameUncheckedCreateWithoutReviewsInput
    >;
    where?: GameWhereInput;
  };

  export type GameUpdateToOneWithWhereWithoutReviewsInput = {
    where?: GameWhereInput;
    data: XOR<
      GameUpdateWithoutReviewsInput,
      GameUncheckedUpdateWithoutReviewsInput
    >;
  };

  export type GameUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    developer?: StringFieldUpdateOperationsInput | string;
    publisher?: StringFieldUpdateOperationsInput | string;
    coverImageUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus;
    cartItems?: CartItemUpdateManyWithoutGameNestedInput;
    genres?: GameGenreUpdateManyWithoutGameNestedInput;
    orderItems?: OrderItemUpdateManyWithoutGameNestedInput;
    screenshots?: ScreenshotUpdateManyWithoutGameNestedInput;
    featuredGames?: FeaturedGameUpdateManyWithoutGameNestedInput;
    recommendedMain?: RecommendedGameUpdateManyWithoutGameNestedInput;
    recommendedRel?: RecommendedGameUpdateManyWithoutRelatedGameNestedInput;
  };

  export type GameUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    developer?: StringFieldUpdateOperationsInput | string;
    publisher?: StringFieldUpdateOperationsInput | string;
    coverImageUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus;
    cartItems?: CartItemUncheckedUpdateManyWithoutGameNestedInput;
    genres?: GameGenreUncheckedUpdateManyWithoutGameNestedInput;
    orderItems?: OrderItemUncheckedUpdateManyWithoutGameNestedInput;
    screenshots?: ScreenshotUncheckedUpdateManyWithoutGameNestedInput;
    featuredGames?: FeaturedGameUncheckedUpdateManyWithoutGameNestedInput;
    recommendedMain?: RecommendedGameUncheckedUpdateManyWithoutGameNestedInput;
    recommendedRel?: RecommendedGameUncheckedUpdateManyWithoutRelatedGameNestedInput;
  };

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<
      UserUpdateWithoutReviewsInput,
      UserUncheckedUpdateWithoutReviewsInput
    >;
    create: XOR<
      UserCreateWithoutReviewsInput,
      UserUncheckedCreateWithoutReviewsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutReviewsInput,
      UserUncheckedUpdateWithoutReviewsInput
    >;
  };

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    cart?: CartUpdateOneWithoutUserNestedInput;
    orders?: OrderUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    cart?: CartUncheckedUpdateOneWithoutUserNestedInput;
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateWithoutCartInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    address?: string | null;
    phone?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    orders?: OrderCreateNestedManyWithoutUserInput;
    reviews?: ReviewCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutCartInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    address?: string | null;
    phone?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutCartInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutCartInput,
      UserUncheckedCreateWithoutCartInput
    >;
  };

  export type CartItemCreateWithoutCartInput = {
    id?: string;
    quantity?: number;
    addedAt?: Date | string;
    game: GameCreateNestedOneWithoutCartItemsInput;
  };

  export type CartItemUncheckedCreateWithoutCartInput = {
    id?: string;
    gameId: string;
    quantity?: number;
    addedAt?: Date | string;
  };

  export type CartItemCreateOrConnectWithoutCartInput = {
    where: CartItemWhereUniqueInput;
    create: XOR<
      CartItemCreateWithoutCartInput,
      CartItemUncheckedCreateWithoutCartInput
    >;
  };

  export type CartItemCreateManyCartInputEnvelope = {
    data: CartItemCreateManyCartInput | CartItemCreateManyCartInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutCartInput = {
    update: XOR<
      UserUpdateWithoutCartInput,
      UserUncheckedUpdateWithoutCartInput
    >;
    create: XOR<
      UserCreateWithoutCartInput,
      UserUncheckedCreateWithoutCartInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutCartInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutCartInput, UserUncheckedUpdateWithoutCartInput>;
  };

  export type UserUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    orders?: OrderUpdateManyWithoutUserNestedInput;
    reviews?: ReviewUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type CartItemUpsertWithWhereUniqueWithoutCartInput = {
    where: CartItemWhereUniqueInput;
    update: XOR<
      CartItemUpdateWithoutCartInput,
      CartItemUncheckedUpdateWithoutCartInput
    >;
    create: XOR<
      CartItemCreateWithoutCartInput,
      CartItemUncheckedCreateWithoutCartInput
    >;
  };

  export type CartItemUpdateWithWhereUniqueWithoutCartInput = {
    where: CartItemWhereUniqueInput;
    data: XOR<
      CartItemUpdateWithoutCartInput,
      CartItemUncheckedUpdateWithoutCartInput
    >;
  };

  export type CartItemUpdateManyWithWhereWithoutCartInput = {
    where: CartItemScalarWhereInput;
    data: XOR<
      CartItemUpdateManyMutationInput,
      CartItemUncheckedUpdateManyWithoutCartInput
    >;
  };

  export type CartCreateWithoutItemsInput = {
    id?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutCartInput;
  };

  export type CartUncheckedCreateWithoutItemsInput = {
    id?: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CartCreateOrConnectWithoutItemsInput = {
    where: CartWhereUniqueInput;
    create: XOR<
      CartCreateWithoutItemsInput,
      CartUncheckedCreateWithoutItemsInput
    >;
  };

  export type GameCreateWithoutCartItemsInput = {
    id?: string;
    title: string;
    description: string;
    price: number;
    releaseDate: Date | string;
    developer: string;
    publisher: string;
    coverImageUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    rating?: number;
    discountedPrice?: number | null;
    status?: $Enums.GameStatus;
    genres?: GameGenreCreateNestedManyWithoutGameInput;
    orderItems?: OrderItemCreateNestedManyWithoutGameInput;
    reviews?: ReviewCreateNestedManyWithoutGameInput;
    screenshots?: ScreenshotCreateNestedManyWithoutGameInput;
    featuredGames?: FeaturedGameCreateNestedManyWithoutGameInput;
    recommendedMain?: RecommendedGameCreateNestedManyWithoutGameInput;
    recommendedRel?: RecommendedGameCreateNestedManyWithoutRelatedGameInput;
  };

  export type GameUncheckedCreateWithoutCartItemsInput = {
    id?: string;
    title: string;
    description: string;
    price: number;
    releaseDate: Date | string;
    developer: string;
    publisher: string;
    coverImageUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    rating?: number;
    discountedPrice?: number | null;
    status?: $Enums.GameStatus;
    genres?: GameGenreUncheckedCreateNestedManyWithoutGameInput;
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutGameInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutGameInput;
    screenshots?: ScreenshotUncheckedCreateNestedManyWithoutGameInput;
    featuredGames?: FeaturedGameUncheckedCreateNestedManyWithoutGameInput;
    recommendedMain?: RecommendedGameUncheckedCreateNestedManyWithoutGameInput;
    recommendedRel?: RecommendedGameUncheckedCreateNestedManyWithoutRelatedGameInput;
  };

  export type GameCreateOrConnectWithoutCartItemsInput = {
    where: GameWhereUniqueInput;
    create: XOR<
      GameCreateWithoutCartItemsInput,
      GameUncheckedCreateWithoutCartItemsInput
    >;
  };

  export type CartUpsertWithoutItemsInput = {
    update: XOR<
      CartUpdateWithoutItemsInput,
      CartUncheckedUpdateWithoutItemsInput
    >;
    create: XOR<
      CartCreateWithoutItemsInput,
      CartUncheckedCreateWithoutItemsInput
    >;
    where?: CartWhereInput;
  };

  export type CartUpdateToOneWithWhereWithoutItemsInput = {
    where?: CartWhereInput;
    data: XOR<
      CartUpdateWithoutItemsInput,
      CartUncheckedUpdateWithoutItemsInput
    >;
  };

  export type CartUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutCartNestedInput;
  };

  export type CartUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type GameUpsertWithoutCartItemsInput = {
    update: XOR<
      GameUpdateWithoutCartItemsInput,
      GameUncheckedUpdateWithoutCartItemsInput
    >;
    create: XOR<
      GameCreateWithoutCartItemsInput,
      GameUncheckedCreateWithoutCartItemsInput
    >;
    where?: GameWhereInput;
  };

  export type GameUpdateToOneWithWhereWithoutCartItemsInput = {
    where?: GameWhereInput;
    data: XOR<
      GameUpdateWithoutCartItemsInput,
      GameUncheckedUpdateWithoutCartItemsInput
    >;
  };

  export type GameUpdateWithoutCartItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    developer?: StringFieldUpdateOperationsInput | string;
    publisher?: StringFieldUpdateOperationsInput | string;
    coverImageUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus;
    genres?: GameGenreUpdateManyWithoutGameNestedInput;
    orderItems?: OrderItemUpdateManyWithoutGameNestedInput;
    reviews?: ReviewUpdateManyWithoutGameNestedInput;
    screenshots?: ScreenshotUpdateManyWithoutGameNestedInput;
    featuredGames?: FeaturedGameUpdateManyWithoutGameNestedInput;
    recommendedMain?: RecommendedGameUpdateManyWithoutGameNestedInput;
    recommendedRel?: RecommendedGameUpdateManyWithoutRelatedGameNestedInput;
  };

  export type GameUncheckedUpdateWithoutCartItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    developer?: StringFieldUpdateOperationsInput | string;
    publisher?: StringFieldUpdateOperationsInput | string;
    coverImageUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus;
    genres?: GameGenreUncheckedUpdateManyWithoutGameNestedInput;
    orderItems?: OrderItemUncheckedUpdateManyWithoutGameNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutGameNestedInput;
    screenshots?: ScreenshotUncheckedUpdateManyWithoutGameNestedInput;
    featuredGames?: FeaturedGameUncheckedUpdateManyWithoutGameNestedInput;
    recommendedMain?: RecommendedGameUncheckedUpdateManyWithoutGameNestedInput;
    recommendedRel?: RecommendedGameUncheckedUpdateManyWithoutRelatedGameNestedInput;
  };

  export type UserCreateWithoutOrdersInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    address?: string | null;
    phone?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    cart?: CartCreateNestedOneWithoutUserInput;
    reviews?: ReviewCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    password?: string | null;
    address?: string | null;
    phone?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    cart?: CartUncheckedCreateNestedOneWithoutUserInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutOrdersInput,
      UserUncheckedCreateWithoutOrdersInput
    >;
  };

  export type OrderItemCreateWithoutOrderInput = {
    id?: string;
    price: number;
    quantity: number;
    game: GameCreateNestedOneWithoutOrderItemsInput;
  };

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string;
    gameId: string;
    price: number;
    quantity: number;
  };

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput;
    create: XOR<
      OrderItemCreateWithoutOrderInput,
      OrderItemUncheckedCreateWithoutOrderInput
    >;
  };

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<
      UserUpdateWithoutOrdersInput,
      UserUncheckedUpdateWithoutOrdersInput
    >;
    create: XOR<
      UserCreateWithoutOrdersInput,
      UserUncheckedCreateWithoutOrdersInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutOrdersInput,
      UserUncheckedUpdateWithoutOrdersInput
    >;
  };

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    cart?: CartUpdateOneWithoutUserNestedInput;
    reviews?: ReviewUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    cart?: CartUncheckedUpdateOneWithoutUserNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput;
    update: XOR<
      OrderItemUpdateWithoutOrderInput,
      OrderItemUncheckedUpdateWithoutOrderInput
    >;
    create: XOR<
      OrderItemCreateWithoutOrderInput,
      OrderItemUncheckedCreateWithoutOrderInput
    >;
  };

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput;
    data: XOR<
      OrderItemUpdateWithoutOrderInput,
      OrderItemUncheckedUpdateWithoutOrderInput
    >;
  };

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput;
    data: XOR<
      OrderItemUpdateManyMutationInput,
      OrderItemUncheckedUpdateManyWithoutOrderInput
    >;
  };

  export type GameCreateWithoutOrderItemsInput = {
    id?: string;
    title: string;
    description: string;
    price: number;
    releaseDate: Date | string;
    developer: string;
    publisher: string;
    coverImageUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    rating?: number;
    discountedPrice?: number | null;
    status?: $Enums.GameStatus;
    cartItems?: CartItemCreateNestedManyWithoutGameInput;
    genres?: GameGenreCreateNestedManyWithoutGameInput;
    reviews?: ReviewCreateNestedManyWithoutGameInput;
    screenshots?: ScreenshotCreateNestedManyWithoutGameInput;
    featuredGames?: FeaturedGameCreateNestedManyWithoutGameInput;
    recommendedMain?: RecommendedGameCreateNestedManyWithoutGameInput;
    recommendedRel?: RecommendedGameCreateNestedManyWithoutRelatedGameInput;
  };

  export type GameUncheckedCreateWithoutOrderItemsInput = {
    id?: string;
    title: string;
    description: string;
    price: number;
    releaseDate: Date | string;
    developer: string;
    publisher: string;
    coverImageUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    rating?: number;
    discountedPrice?: number | null;
    status?: $Enums.GameStatus;
    cartItems?: CartItemUncheckedCreateNestedManyWithoutGameInput;
    genres?: GameGenreUncheckedCreateNestedManyWithoutGameInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutGameInput;
    screenshots?: ScreenshotUncheckedCreateNestedManyWithoutGameInput;
    featuredGames?: FeaturedGameUncheckedCreateNestedManyWithoutGameInput;
    recommendedMain?: RecommendedGameUncheckedCreateNestedManyWithoutGameInput;
    recommendedRel?: RecommendedGameUncheckedCreateNestedManyWithoutRelatedGameInput;
  };

  export type GameCreateOrConnectWithoutOrderItemsInput = {
    where: GameWhereUniqueInput;
    create: XOR<
      GameCreateWithoutOrderItemsInput,
      GameUncheckedCreateWithoutOrderItemsInput
    >;
  };

  export type OrderCreateWithoutItemsInput = {
    id?: string;
    totalAmount: number;
    status?: string;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutOrdersInput;
  };

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: string;
    userId: string;
    totalAmount: number;
    status?: string;
    createdAt?: Date | string;
  };

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput;
    create: XOR<
      OrderCreateWithoutItemsInput,
      OrderUncheckedCreateWithoutItemsInput
    >;
  };

  export type GameUpsertWithoutOrderItemsInput = {
    update: XOR<
      GameUpdateWithoutOrderItemsInput,
      GameUncheckedUpdateWithoutOrderItemsInput
    >;
    create: XOR<
      GameCreateWithoutOrderItemsInput,
      GameUncheckedCreateWithoutOrderItemsInput
    >;
    where?: GameWhereInput;
  };

  export type GameUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: GameWhereInput;
    data: XOR<
      GameUpdateWithoutOrderItemsInput,
      GameUncheckedUpdateWithoutOrderItemsInput
    >;
  };

  export type GameUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    developer?: StringFieldUpdateOperationsInput | string;
    publisher?: StringFieldUpdateOperationsInput | string;
    coverImageUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus;
    cartItems?: CartItemUpdateManyWithoutGameNestedInput;
    genres?: GameGenreUpdateManyWithoutGameNestedInput;
    reviews?: ReviewUpdateManyWithoutGameNestedInput;
    screenshots?: ScreenshotUpdateManyWithoutGameNestedInput;
    featuredGames?: FeaturedGameUpdateManyWithoutGameNestedInput;
    recommendedMain?: RecommendedGameUpdateManyWithoutGameNestedInput;
    recommendedRel?: RecommendedGameUpdateManyWithoutRelatedGameNestedInput;
  };

  export type GameUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    developer?: StringFieldUpdateOperationsInput | string;
    publisher?: StringFieldUpdateOperationsInput | string;
    coverImageUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus;
    cartItems?: CartItemUncheckedUpdateManyWithoutGameNestedInput;
    genres?: GameGenreUncheckedUpdateManyWithoutGameNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutGameNestedInput;
    screenshots?: ScreenshotUncheckedUpdateManyWithoutGameNestedInput;
    featuredGames?: FeaturedGameUncheckedUpdateManyWithoutGameNestedInput;
    recommendedMain?: RecommendedGameUncheckedUpdateManyWithoutGameNestedInput;
    recommendedRel?: RecommendedGameUncheckedUpdateManyWithoutRelatedGameNestedInput;
  };

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<
      OrderUpdateWithoutItemsInput,
      OrderUncheckedUpdateWithoutItemsInput
    >;
    create: XOR<
      OrderCreateWithoutItemsInput,
      OrderUncheckedCreateWithoutItemsInput
    >;
    where?: OrderWhereInput;
  };

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput;
    data: XOR<
      OrderUpdateWithoutItemsInput,
      OrderUncheckedUpdateWithoutItemsInput
    >;
  };

  export type OrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    totalAmount?: FloatFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput;
  };

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    totalAmount?: FloatFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type GameCreateWithoutFeaturedGamesInput = {
    id?: string;
    title: string;
    description: string;
    price: number;
    releaseDate: Date | string;
    developer: string;
    publisher: string;
    coverImageUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    rating?: number;
    discountedPrice?: number | null;
    status?: $Enums.GameStatus;
    cartItems?: CartItemCreateNestedManyWithoutGameInput;
    genres?: GameGenreCreateNestedManyWithoutGameInput;
    orderItems?: OrderItemCreateNestedManyWithoutGameInput;
    reviews?: ReviewCreateNestedManyWithoutGameInput;
    screenshots?: ScreenshotCreateNestedManyWithoutGameInput;
    recommendedMain?: RecommendedGameCreateNestedManyWithoutGameInput;
    recommendedRel?: RecommendedGameCreateNestedManyWithoutRelatedGameInput;
  };

  export type GameUncheckedCreateWithoutFeaturedGamesInput = {
    id?: string;
    title: string;
    description: string;
    price: number;
    releaseDate: Date | string;
    developer: string;
    publisher: string;
    coverImageUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    rating?: number;
    discountedPrice?: number | null;
    status?: $Enums.GameStatus;
    cartItems?: CartItemUncheckedCreateNestedManyWithoutGameInput;
    genres?: GameGenreUncheckedCreateNestedManyWithoutGameInput;
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutGameInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutGameInput;
    screenshots?: ScreenshotUncheckedCreateNestedManyWithoutGameInput;
    recommendedMain?: RecommendedGameUncheckedCreateNestedManyWithoutGameInput;
    recommendedRel?: RecommendedGameUncheckedCreateNestedManyWithoutRelatedGameInput;
  };

  export type GameCreateOrConnectWithoutFeaturedGamesInput = {
    where: GameWhereUniqueInput;
    create: XOR<
      GameCreateWithoutFeaturedGamesInput,
      GameUncheckedCreateWithoutFeaturedGamesInput
    >;
  };

  export type GameUpsertWithoutFeaturedGamesInput = {
    update: XOR<
      GameUpdateWithoutFeaturedGamesInput,
      GameUncheckedUpdateWithoutFeaturedGamesInput
    >;
    create: XOR<
      GameCreateWithoutFeaturedGamesInput,
      GameUncheckedCreateWithoutFeaturedGamesInput
    >;
    where?: GameWhereInput;
  };

  export type GameUpdateToOneWithWhereWithoutFeaturedGamesInput = {
    where?: GameWhereInput;
    data: XOR<
      GameUpdateWithoutFeaturedGamesInput,
      GameUncheckedUpdateWithoutFeaturedGamesInput
    >;
  };

  export type GameUpdateWithoutFeaturedGamesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    developer?: StringFieldUpdateOperationsInput | string;
    publisher?: StringFieldUpdateOperationsInput | string;
    coverImageUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus;
    cartItems?: CartItemUpdateManyWithoutGameNestedInput;
    genres?: GameGenreUpdateManyWithoutGameNestedInput;
    orderItems?: OrderItemUpdateManyWithoutGameNestedInput;
    reviews?: ReviewUpdateManyWithoutGameNestedInput;
    screenshots?: ScreenshotUpdateManyWithoutGameNestedInput;
    recommendedMain?: RecommendedGameUpdateManyWithoutGameNestedInput;
    recommendedRel?: RecommendedGameUpdateManyWithoutRelatedGameNestedInput;
  };

  export type GameUncheckedUpdateWithoutFeaturedGamesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    developer?: StringFieldUpdateOperationsInput | string;
    publisher?: StringFieldUpdateOperationsInput | string;
    coverImageUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus;
    cartItems?: CartItemUncheckedUpdateManyWithoutGameNestedInput;
    genres?: GameGenreUncheckedUpdateManyWithoutGameNestedInput;
    orderItems?: OrderItemUncheckedUpdateManyWithoutGameNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutGameNestedInput;
    screenshots?: ScreenshotUncheckedUpdateManyWithoutGameNestedInput;
    recommendedMain?: RecommendedGameUncheckedUpdateManyWithoutGameNestedInput;
    recommendedRel?: RecommendedGameUncheckedUpdateManyWithoutRelatedGameNestedInput;
  };

  export type GameCreateWithoutRecommendedMainInput = {
    id?: string;
    title: string;
    description: string;
    price: number;
    releaseDate: Date | string;
    developer: string;
    publisher: string;
    coverImageUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    rating?: number;
    discountedPrice?: number | null;
    status?: $Enums.GameStatus;
    cartItems?: CartItemCreateNestedManyWithoutGameInput;
    genres?: GameGenreCreateNestedManyWithoutGameInput;
    orderItems?: OrderItemCreateNestedManyWithoutGameInput;
    reviews?: ReviewCreateNestedManyWithoutGameInput;
    screenshots?: ScreenshotCreateNestedManyWithoutGameInput;
    featuredGames?: FeaturedGameCreateNestedManyWithoutGameInput;
    recommendedRel?: RecommendedGameCreateNestedManyWithoutRelatedGameInput;
  };

  export type GameUncheckedCreateWithoutRecommendedMainInput = {
    id?: string;
    title: string;
    description: string;
    price: number;
    releaseDate: Date | string;
    developer: string;
    publisher: string;
    coverImageUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    rating?: number;
    discountedPrice?: number | null;
    status?: $Enums.GameStatus;
    cartItems?: CartItemUncheckedCreateNestedManyWithoutGameInput;
    genres?: GameGenreUncheckedCreateNestedManyWithoutGameInput;
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutGameInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutGameInput;
    screenshots?: ScreenshotUncheckedCreateNestedManyWithoutGameInput;
    featuredGames?: FeaturedGameUncheckedCreateNestedManyWithoutGameInput;
    recommendedRel?: RecommendedGameUncheckedCreateNestedManyWithoutRelatedGameInput;
  };

  export type GameCreateOrConnectWithoutRecommendedMainInput = {
    where: GameWhereUniqueInput;
    create: XOR<
      GameCreateWithoutRecommendedMainInput,
      GameUncheckedCreateWithoutRecommendedMainInput
    >;
  };

  export type GameCreateWithoutRecommendedRelInput = {
    id?: string;
    title: string;
    description: string;
    price: number;
    releaseDate: Date | string;
    developer: string;
    publisher: string;
    coverImageUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    rating?: number;
    discountedPrice?: number | null;
    status?: $Enums.GameStatus;
    cartItems?: CartItemCreateNestedManyWithoutGameInput;
    genres?: GameGenreCreateNestedManyWithoutGameInput;
    orderItems?: OrderItemCreateNestedManyWithoutGameInput;
    reviews?: ReviewCreateNestedManyWithoutGameInput;
    screenshots?: ScreenshotCreateNestedManyWithoutGameInput;
    featuredGames?: FeaturedGameCreateNestedManyWithoutGameInput;
    recommendedMain?: RecommendedGameCreateNestedManyWithoutGameInput;
  };

  export type GameUncheckedCreateWithoutRecommendedRelInput = {
    id?: string;
    title: string;
    description: string;
    price: number;
    releaseDate: Date | string;
    developer: string;
    publisher: string;
    coverImageUrl: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    rating?: number;
    discountedPrice?: number | null;
    status?: $Enums.GameStatus;
    cartItems?: CartItemUncheckedCreateNestedManyWithoutGameInput;
    genres?: GameGenreUncheckedCreateNestedManyWithoutGameInput;
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutGameInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutGameInput;
    screenshots?: ScreenshotUncheckedCreateNestedManyWithoutGameInput;
    featuredGames?: FeaturedGameUncheckedCreateNestedManyWithoutGameInput;
    recommendedMain?: RecommendedGameUncheckedCreateNestedManyWithoutGameInput;
  };

  export type GameCreateOrConnectWithoutRecommendedRelInput = {
    where: GameWhereUniqueInput;
    create: XOR<
      GameCreateWithoutRecommendedRelInput,
      GameUncheckedCreateWithoutRecommendedRelInput
    >;
  };

  export type GameUpsertWithoutRecommendedMainInput = {
    update: XOR<
      GameUpdateWithoutRecommendedMainInput,
      GameUncheckedUpdateWithoutRecommendedMainInput
    >;
    create: XOR<
      GameCreateWithoutRecommendedMainInput,
      GameUncheckedCreateWithoutRecommendedMainInput
    >;
    where?: GameWhereInput;
  };

  export type GameUpdateToOneWithWhereWithoutRecommendedMainInput = {
    where?: GameWhereInput;
    data: XOR<
      GameUpdateWithoutRecommendedMainInput,
      GameUncheckedUpdateWithoutRecommendedMainInput
    >;
  };

  export type GameUpdateWithoutRecommendedMainInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    developer?: StringFieldUpdateOperationsInput | string;
    publisher?: StringFieldUpdateOperationsInput | string;
    coverImageUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus;
    cartItems?: CartItemUpdateManyWithoutGameNestedInput;
    genres?: GameGenreUpdateManyWithoutGameNestedInput;
    orderItems?: OrderItemUpdateManyWithoutGameNestedInput;
    reviews?: ReviewUpdateManyWithoutGameNestedInput;
    screenshots?: ScreenshotUpdateManyWithoutGameNestedInput;
    featuredGames?: FeaturedGameUpdateManyWithoutGameNestedInput;
    recommendedRel?: RecommendedGameUpdateManyWithoutRelatedGameNestedInput;
  };

  export type GameUncheckedUpdateWithoutRecommendedMainInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    developer?: StringFieldUpdateOperationsInput | string;
    publisher?: StringFieldUpdateOperationsInput | string;
    coverImageUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus;
    cartItems?: CartItemUncheckedUpdateManyWithoutGameNestedInput;
    genres?: GameGenreUncheckedUpdateManyWithoutGameNestedInput;
    orderItems?: OrderItemUncheckedUpdateManyWithoutGameNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutGameNestedInput;
    screenshots?: ScreenshotUncheckedUpdateManyWithoutGameNestedInput;
    featuredGames?: FeaturedGameUncheckedUpdateManyWithoutGameNestedInput;
    recommendedRel?: RecommendedGameUncheckedUpdateManyWithoutRelatedGameNestedInput;
  };

  export type GameUpsertWithoutRecommendedRelInput = {
    update: XOR<
      GameUpdateWithoutRecommendedRelInput,
      GameUncheckedUpdateWithoutRecommendedRelInput
    >;
    create: XOR<
      GameCreateWithoutRecommendedRelInput,
      GameUncheckedCreateWithoutRecommendedRelInput
    >;
    where?: GameWhereInput;
  };

  export type GameUpdateToOneWithWhereWithoutRecommendedRelInput = {
    where?: GameWhereInput;
    data: XOR<
      GameUpdateWithoutRecommendedRelInput,
      GameUncheckedUpdateWithoutRecommendedRelInput
    >;
  };

  export type GameUpdateWithoutRecommendedRelInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    developer?: StringFieldUpdateOperationsInput | string;
    publisher?: StringFieldUpdateOperationsInput | string;
    coverImageUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus;
    cartItems?: CartItemUpdateManyWithoutGameNestedInput;
    genres?: GameGenreUpdateManyWithoutGameNestedInput;
    orderItems?: OrderItemUpdateManyWithoutGameNestedInput;
    reviews?: ReviewUpdateManyWithoutGameNestedInput;
    screenshots?: ScreenshotUpdateManyWithoutGameNestedInput;
    featuredGames?: FeaturedGameUpdateManyWithoutGameNestedInput;
    recommendedMain?: RecommendedGameUpdateManyWithoutGameNestedInput;
  };

  export type GameUncheckedUpdateWithoutRecommendedRelInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    releaseDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    developer?: StringFieldUpdateOperationsInput | string;
    publisher?: StringFieldUpdateOperationsInput | string;
    coverImageUrl?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    discountedPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus;
    cartItems?: CartItemUncheckedUpdateManyWithoutGameNestedInput;
    genres?: GameGenreUncheckedUpdateManyWithoutGameNestedInput;
    orderItems?: OrderItemUncheckedUpdateManyWithoutGameNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutGameNestedInput;
    screenshots?: ScreenshotUncheckedUpdateManyWithoutGameNestedInput;
    featuredGames?: FeaturedGameUncheckedUpdateManyWithoutGameNestedInput;
    recommendedMain?: RecommendedGameUncheckedUpdateManyWithoutGameNestedInput;
  };

  export type AccountCreateManyUserInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type SessionCreateManyUserInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
  };

  export type OrderCreateManyUserInput = {
    id?: string;
    totalAmount: number;
    status?: string;
    createdAt?: Date | string;
  };

  export type ReviewCreateManyUserInput = {
    id?: string;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    gameId: string;
  };

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    totalAmount?: FloatFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    items?: OrderItemUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    totalAmount?: FloatFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    totalAmount?: FloatFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    game?: GameUpdateOneRequiredWithoutReviewsNestedInput;
  };

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    gameId?: StringFieldUpdateOperationsInput | string;
  };

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    gameId?: StringFieldUpdateOperationsInput | string;
  };

  export type CartItemCreateManyGameInput = {
    id?: string;
    cartId: string;
    quantity?: number;
    addedAt?: Date | string;
  };

  export type GameGenreCreateManyGameInput = {
    genreId: string;
  };

  export type OrderItemCreateManyGameInput = {
    id?: string;
    orderId: string;
    price: number;
    quantity: number;
  };

  export type ReviewCreateManyGameInput = {
    id?: string;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    userId: string;
  };

  export type ScreenshotCreateManyGameInput = {
    id?: string;
    imageUrl: string;
    caption?: string | null;
  };

  export type FeaturedGameCreateManyGameInput = {
    id?: string;
    startDate: Date | string;
    endDate: Date | string;
    priority?: number;
    createdAt?: Date | string;
  };

  export type RecommendedGameCreateManyGameInput = {
    id?: string;
    recommendationType: $Enums.RecommendationType;
    relatedGameId?: string | null;
    startDate: Date | string;
    endDate?: Date | string | null;
    priority?: number;
    createdAt?: Date | string;
  };

  export type RecommendedGameCreateManyRelatedGameInput = {
    id?: string;
    gameId: string;
    recommendationType: $Enums.RecommendationType;
    startDate: Date | string;
    endDate?: Date | string | null;
    priority?: number;
    createdAt?: Date | string;
  };

  export type CartItemUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    cart?: CartUpdateOneRequiredWithoutItemsNestedInput;
  };

  export type CartItemUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string;
    cartId?: StringFieldUpdateOperationsInput | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CartItemUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string;
    cartId?: StringFieldUpdateOperationsInput | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type GameGenreUpdateWithoutGameInput = {
    genre?: GenreUpdateOneRequiredWithoutGamesNestedInput;
  };

  export type GameGenreUncheckedUpdateWithoutGameInput = {
    genreId?: StringFieldUpdateOperationsInput | string;
  };

  export type GameGenreUncheckedUpdateManyWithoutGameInput = {
    genreId?: StringFieldUpdateOperationsInput | string;
  };

  export type OrderItemUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    quantity?: IntFieldUpdateOperationsInput | number;
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput;
  };

  export type OrderItemUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orderId?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    quantity?: IntFieldUpdateOperationsInput | number;
  };

  export type OrderItemUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orderId?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    quantity?: IntFieldUpdateOperationsInput | number;
  };

  export type ReviewUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput;
  };

  export type ReviewUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type ReviewUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rating?: FloatFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type ScreenshotUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string;
    imageUrl?: StringFieldUpdateOperationsInput | string;
    caption?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ScreenshotUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string;
    imageUrl?: StringFieldUpdateOperationsInput | string;
    caption?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ScreenshotUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string;
    imageUrl?: StringFieldUpdateOperationsInput | string;
    caption?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type FeaturedGameUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    priority?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FeaturedGameUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    priority?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FeaturedGameUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    priority?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RecommendedGameUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string;
    recommendationType?:
      | EnumRecommendationTypeFieldUpdateOperationsInput
      | $Enums.RecommendationType;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    priority?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    relatedGame?: GameUpdateOneWithoutRecommendedRelNestedInput;
  };

  export type RecommendedGameUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string;
    recommendationType?:
      | EnumRecommendationTypeFieldUpdateOperationsInput
      | $Enums.RecommendationType;
    relatedGameId?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    priority?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RecommendedGameUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string;
    recommendationType?:
      | EnumRecommendationTypeFieldUpdateOperationsInput
      | $Enums.RecommendationType;
    relatedGameId?: NullableStringFieldUpdateOperationsInput | string | null;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    priority?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RecommendedGameUpdateWithoutRelatedGameInput = {
    id?: StringFieldUpdateOperationsInput | string;
    recommendationType?:
      | EnumRecommendationTypeFieldUpdateOperationsInput
      | $Enums.RecommendationType;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    priority?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    game?: GameUpdateOneRequiredWithoutRecommendedMainNestedInput;
  };

  export type RecommendedGameUncheckedUpdateWithoutRelatedGameInput = {
    id?: StringFieldUpdateOperationsInput | string;
    gameId?: StringFieldUpdateOperationsInput | string;
    recommendationType?:
      | EnumRecommendationTypeFieldUpdateOperationsInput
      | $Enums.RecommendationType;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    priority?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RecommendedGameUncheckedUpdateManyWithoutRelatedGameInput = {
    id?: StringFieldUpdateOperationsInput | string;
    gameId?: StringFieldUpdateOperationsInput | string;
    recommendationType?:
      | EnumRecommendationTypeFieldUpdateOperationsInput
      | $Enums.RecommendationType;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    priority?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type GameGenreCreateManyGenreInput = {
    gameId: string;
  };

  export type GenreCreateManyParentInput = {
    id?: string;
    name: string;
  };

  export type GameGenreUpdateWithoutGenreInput = {
    game?: GameUpdateOneRequiredWithoutGenresNestedInput;
  };

  export type GameGenreUncheckedUpdateWithoutGenreInput = {
    gameId?: StringFieldUpdateOperationsInput | string;
  };

  export type GameGenreUncheckedUpdateManyWithoutGenreInput = {
    gameId?: StringFieldUpdateOperationsInput | string;
  };

  export type GenreUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    games?: GameGenreUpdateManyWithoutGenreNestedInput;
    subGenres?: GenreUpdateManyWithoutParentNestedInput;
  };

  export type GenreUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    games?: GameGenreUncheckedUpdateManyWithoutGenreNestedInput;
    subGenres?: GenreUncheckedUpdateManyWithoutParentNestedInput;
  };

  export type GenreUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
  };

  export type CartItemCreateManyCartInput = {
    id?: string;
    gameId: string;
    quantity?: number;
    addedAt?: Date | string;
  };

  export type CartItemUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    game?: GameUpdateOneRequiredWithoutCartItemsNestedInput;
  };

  export type CartItemUncheckedUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string;
    gameId?: StringFieldUpdateOperationsInput | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CartItemUncheckedUpdateManyWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string;
    gameId?: StringFieldUpdateOperationsInput | string;
    quantity?: IntFieldUpdateOperationsInput | number;
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderItemCreateManyOrderInput = {
    id?: string;
    gameId: string;
    price: number;
    quantity: number;
  };

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    quantity?: IntFieldUpdateOperationsInput | number;
    game?: GameUpdateOneRequiredWithoutOrderItemsNestedInput;
  };

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string;
    gameId?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    quantity?: IntFieldUpdateOperationsInput | number;
  };

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string;
    gameId?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    quantity?: IntFieldUpdateOperationsInput | number;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
